<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>假期生活总结</title>
    <url>/2023/08/14/20230814-end-of-vacation/</url>
    <content><![CDATA[<p>为期两周的假期以一种仓促而并不美好的方式终究还是走到了尽头。纵使这个假期和大学相比过于短暂，纵使假期末尾的科目二挂科导致连续几天愤愤不平满心遗憾，事已至此，总归该开始正常的学习和工作生活了。</p>
<span id="more"></span>

<p>7月27号讲完组会，和老师申请了两个星期多的假期。周末两天在上海市区转了转，买了一些东西，之后回了家。</p>
<p>整个假期，一直在练车，为此甚至养成了早上5点半起床9点再补觉的离谱作息。倒库学了三天，侧方、转弯、直角弯各学一天，坡道在教练的训斥声中练了两天，之后一直在跑大圈。然而如此匆忙训练的后果就是基础不扎实，考场上的两次考试机会都被我浪费在了短短的坡道上了。下车一度没站稳，拿着科目二考试不合格的成绩单哆哆嗦嗦挪向了公交站。</p>
<p>周六几乎躺了一天，补了不少觉。周日白天和初中同学吃了个饭、看了电影《孤掷一注》，顺带聊了一下初中同学们的近况以及一些人生规划的问题。晚上匆匆收拾行李，又赶去高铁站坐7点的高铁，差不多10点40才到研究生宿舍。假期结束了，该认真干活了，不是吗？</p>
<p>在回上海的高铁上，看完了一本书，黄仁宇《万历十五年》。早在高中写模拟卷子时就知道这是本好书，然而直到真正读完才知道书好在哪里。黄仁宇创新性的提出了大局史观，告诉大家明朝灭亡的根本原因在于社会制度，在于稳定但僵化的社会组织形态，因此纵使有张居正、海瑞、戚继光等一众人才，大明仍然不可救药的走向灭亡，被兴起于辽东建州的新生力量所取代。</p>
<p>刚刚过去的假期生活大抵如此。也不知道驾照什么时候能拿到手。但也许还有更紧迫的事情等着我。谁知道呢？</p>
<p>以上。</p>
]]></content>
      <categories>
        <category>杂思</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title>更新日志（2023-11-04）</title>
    <url>/2023/11/04/20231104_updatelog/</url>
    <content><![CDATA[<p>今天进行了一次比较大的更新，主要改动了下面三点内容：</p>
<ol>
<li>修改了页面主题</li>
<li>关闭了部分拖慢加载速度的动画效果</li>
<li>恢复了原先WordPress版博客的背景图片</li>
</ol>
<p>此外，未来计划更新两方面的文章：</p>
<ol>
<li>计算机技术向的博客（会整理近半年来积攒的一些代码，并陆续更新）</li>
<li>生物学知识，重点是一些生理学方面的内容</li>
</ol>
<p>生活感悟类的文章依然会不定期发表。</p>
<span id="more"></span>

<hr>
<p>原先博客的背景图，是在香山上俯拍北京城的画面。我还记得<a href="/2022/02/26/%E6%97%A9%E6%98%A5%E6%B8%B8%E9%A6%99%E5%B1%B1%EF%BC%9A%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95%E5%92%8C%E4%B8%80%E4%BA%9B%E6%80%9D%E7%B4%A2/">那天的故事</a>。</p>
<p>所以，北京城，那是个我永远也忘不了的地方，对吗？</p>
<p>依然怀念那些在北京的日子，以及那里的一草一木。</p>
<p>念去去，千里烟波，暮霭沉沉楚天阔。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>更新日志</tag>
      </tags>
  </entry>
  <entry>
    <title>更新日志（2023-11-19）</title>
    <url>/2023/11/19/20231119_updatelog/</url>
    <content><![CDATA[<p>【点击查看更多】</p>
<span id="more"></span>

<p>本周更新了四篇（不算本篇）博客文章。</p>
<p>原计划本周还有一篇更新，《如何让zotero和obisidian联动，以及构建引文网络》。可是，说好的更新怕是要鸽了QAQ。昨天晚上装好了obisidian和几个插件，然后太困回去睡觉了。今天大半天都在外面，晚上整理文章又花了很久（呜呜😭）。也许，下周更新的时候，可以把这篇文章带上。</p>
<ul>
<li>今天主要是参加了一个科技青年交流活动。说是交流，主要还是听学术报告，其中倒是有一场关于三代纳米孔RNA测序技术的报告比较有意思。</li>
<li>目前的RNA测序主要是通过将RNA逆转录为cDNA进行的，这会丢失RNA分子上的修饰信息。</li>
<li>研究者基于氮化硅薄膜和石墨烯构建出了一种纳米孔材料，并基于此开发了RNA单分子纳米操作技术和检测技术，实现了对RNA单分子的高精确度直测，在生物学研究中有着巨大的应用潜力。</li>
</ul>
<p>这周更新的内容也是比较多的。样条函数那篇文章和huggingface那篇文章是周中查文献的时候的偶然发现与探寻，南方周末文章的转载则属于是引起了自己的一些共鸣。而基因消融技术的那篇文章，是某天组里同学问起这个话题时进行的一番查询。</p>
<p>废话不多说了，准备推送了hhhhh。倒是还有一些话想说，那就留到下周啦。</p>
<p>以上。</p>
<p>（修改于2023-11-25）</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>更新日志</tag>
      </tags>
  </entry>
  <entry>
    <title>更新日志（2023-10-31）</title>
    <url>/2023/10/31/20231031_updatelog/</url>
    <content><![CDATA[<p>漫长的10月终于快过完了啊。今天更新博客，主要进行了下面三项工作：</p>
<ol>
<li>移除了之前博客中的重复篇目，并对一些文章中遗失的图片进行了增补。</li>
<li>WordPress评论区的恢复已完成。目前的评论系统建立在github discussion之上，之前的评论可以浏览，但是无法回复。推荐使用新版评论系统进行评论和回复。</li>
<li>更新了一篇技术文章。</li>
</ol>
<span id="more"></span>

<hr>
<p>上个月事情很多，所以博客一直没有更新。</p>
<p>今天终于得到了一点时间用于打理博客，但时间不多，只能做一些缝缝补补的工作。</p>
<p>后续本博客依然不定期更新，以技术文章为主，夹杂一些生活感悟。欢迎阅读 &amp; 挂链</p>
<p>（等等，<del>我连Hexo系统如何挂链都没学会</del>，为什么还想着别人挂我的链呢 o(TヘTo) ）</p>
<p>以上。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>更新日志</tag>
      </tags>
  </entry>
  <entry>
    <title>更新日志（2023-12-17）</title>
    <url>/2023/12/17/20231217_updatelog/</url>
    <content><![CDATA[<p>本周对博客中的一些历史文章缺失的图片进行了修补，此外对博客页面的外观进行了一点点微调——现在的卡片比之前更圆润了。</p>
<p>这一周更新了三篇文章：《obsidian探索小记（三）——与flomo笔记的联动》《常见服务器作业管理系统》《使用Python的SymPy库求解不定积分》。前两篇文章来自和同学交流中收集到的一些话题，而最后一篇文章来源于科研生活，某天师姐在推导公式时遇到的一个问题。</p>
<span id="more"></span>


<p>在学习SymPy库以后，不由得感慨计算机代数系统（CAS）真是一项改变世界的发明，它解答了从小到大我内心中的一个疑惑，即能不能让计算器/计算机完成一些合并同类项、公式化简、算式推导之类的任务。CAS系统的发明人真™是天才。</p>
<p>这一周没太多新鲜事发生。但是，一股强冷空气的来袭，让许多地方飘起了雪花。也因此，这一周有幸在朋友圈里欣赏了北京和天津的大雪。那雪下的，好家伙，那叫一个大，南方孩子看得很是羡慕——在遥远的江南水乡，初冬的温暖天气持续了好几个星期，前两天才开始降温。大风夹杂着冷雨宣告了冷空气的到来，可即使这样，依然没有飘雪。发现自己对北方的向往又多了一分。</p>
<p>本来今天还想推送一篇文章，讲一讲最近正在写的一个引文文网络可视化工具<a href="https://github.com/cyclinbox/citationMap">citationMap</a> 的，但是目前开发进度缓慢，很多功能都不太完善，所以可能要等到下周或者下下周了。这个工具是摸鱼写的（可见这周我摸鱼了多长时间😰），而且和另一个著名的引文网络可视化工具<a href="https://www.connectedpapers.com/">connected papers</a> 在功能上似乎有太多重复，但我确实需要一个更客制化的工具进行文献调研（有些时候我想批量查找一些文章的共同引文，<a href="https://www.connectedpapers.com/">connected papers</a> 好像做不到这点）。GitHub上的版本会一直更新直到达到稳定版，如果有人对这个工具有兴趣的话也可以多多提意见呀！</p>
<p>以上。</p>
<hr>
<p>附：雪后的怀柔（图片来自<a href="https://mp.weixin.qq.com/s/MS1Hf7ZsJcSdRt9qW8-TlQ">国科大公众号</a>）</p>
<p><img src="https://pic.imgdb.cn/item/657ef7dfc458853aefe61be8.jpg" alt="1"></p>
<p><img src="https://pic.imgdb.cn/item/657ef7f8c458853aefe6f150.jpg" alt="2"></p>
<p><img src="https://pic.imgdb.cn/item/657ef80cc458853aefe78719.jpg" alt="3"></p>
<p><img src="https://pic.imgdb.cn/item/657ef81cc458853aefe806dd.jpg" alt="4"></p>
<p><img src="https://pic.imgdb.cn/item/657ef828c458853aefe86613.jpg" alt="5"></p>
<p><img src="https://pic.imgdb.cn/item/657ef836c458853aefe8cbc0.jpg" alt="6"></p>
<p><img src="https://pic.imgdb.cn/item/657ef841c458853aefe91cd8.jpg" alt="7"></p>
<p><img src="https://pic.imgdb.cn/item/657ef85dc458853aefe9df31.jpg" alt="8"></p>
<p><img src="https://pic.imgdb.cn/item/657ef86cc458853aefea4a03.jpg" alt="9"></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>更新日志</tag>
      </tags>
  </entry>
  <entry>
    <title>520线下交友活动感想</title>
    <url>/2023/05/20/520-chaotic-thoughts/</url>
    <content><![CDATA[<p>今天是520。</p>
<span id="more"></span>

<p>尽管这是平平凡凡的五月中平平凡凡的一天，但是热爱浪漫的中国人为这一天取下了一个浪漫的定义。早在几天前，做恋爱生意的商家就做起了准备，一些单身青年男女也蠢蠢欲动想要做一点什么事情。</p>
<p>我呢，前几天报名了药物所主办的联谊活动，然后一下午都在药物所那边。先是参观实验室，然后搞活动。活动确实很有趣，可惜没有达到520的目标——除了加上一个药物所师姐和若干有机所老哥，以及和P哥、Z哥等同学吃了晚饭。</p>
<p>其实单身太久，还是有些想尝试恋爱的滋味。但是就现在我的状态来看，恋爱离我确实还有些远。晚饭期间，问了一圈同学们对我的看法，得到的结果无非就是“计算机很厉害”以及“可爱”——和几年前在南开的那个互评结果一样。就连一起做活动的另外几位女同学，在休息期间的玩笑中也隐约透露出感觉我幼稚的看法（“很像高中生”）（哦对，这些人还说我长得太白净了，就像没有经历过导师的摧残一样）。</p>
<p>有点无语。并且我不喜欢这样的自己。我更希望能够从别人口中听见张皖豫是个足够强、足够成熟、足够有能力为他人遮风避雨的人，而不是个靠卖萌博取关注和关爱的长不大的小孩。自己什么时候能真正成长起来呢？</p>
<p>晚上回来跑了个步，回实验室后欲工作之，然后看见了南风窗的文章<a href="https://mp.weixin.qq.com/s/mpCae7mLddAob64RzK3efw">《3年相亲47次，找老婆怎么这么难》</a>。看完以后，感慨万千。文章中的主人公其实很优秀，但是多次恋爱未果，评论区里有人指出他有点自卑，如果能自信一点就好了。可是，说的简单，要让一个人真正自信起来，真的很容易吗？</p>
<p>不过，不管怎么说，归根结底，依然要自信。</p>
<p>过程很难，但是如果你还想有幸福的未来，希望能够收获很好的人际关系和甜甜的恋爱，那么一定要努力。</p>
<p>加油。</p>
]]></content>
      <categories>
        <category>杂思</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
        <tag>爱情</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐两个小工具：mermaid和marp</title>
    <url>/2023/04/26/Recommend-two-applet/</url>
    <content><![CDATA[<p>这两个小工具真好用，一个能画流程图，一个能将markdown转换成PPT</p>
<span id="more"></span>

<h2 id="mermaid"><a href="#mermaid" class="headerlink" title="mermaid"></a>mermaid</h2><p>官网：</p>
<p><a href="https://mermaid.js.org/config/usage.html">https://mermaid.js.org/config/usage.html</a></p>
<p>这是一个绘制流程图的小工具</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A --- B</span><br><span class="line">    B--&gt;C[fa:fa-ban forbidden]</span><br><span class="line">    B--&gt;D(fa:fa-spinner);</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<div>
 <script type="module">
      import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
 </script>
 <pre class="mermaid">
  graph LR
      A --- B
      B-->C[fa:fa-ban forbidden]
      B-->D(fa:fa-spinner);
 </pre>
</div>


<h2 id="marp"><a href="#marp" class="headerlink" title="marp"></a>marp</h2><p>这个小工具最初是<a href="https://hazelandinstant.github.io/">Hazel</a>和我聊起chatGPT的各种神奇应用时提到的，当时我们发现chatGPT居然可以生成PPT，而这一魔法的关键就是使用marp将markdown代码转换为PPT文稿。</p>
<p>官网：</p>
<p><a href="https://marp.app/">https://marp.app/</a></p>
<p>有多种版本可以使用，包括最最方便的<a href="https://github.com/marp-team/marp-vscode">marp for vscode插件</a>和逼格很高的<a href="https://github.com/marp-team/marp-cli">命令行版marp</a>，此外还有一些网页端的渲染框架。</p>
<p>使用方法也很简单，在准备编译为PPT的markdown文档中，使用分隔线 <code>---</code> 分隔准备显示在不同页面上的内容（没有这一步的话，编译出的PPT只有一页），然后使用marp编译，就可以获得整洁漂亮的PPT了。</p>
<p>笔者也测试了命令行版marp。使用方法同样简单：安装好可执行文件后，针对要编译的markdown文档，直接运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">marp example.md --pptx --allow-local-files</span><br></pre></td></tr></table></figure>

<p>即可。</p>
<p>还可以修改输出格式参数：<code>--pdf</code> 是编译为幻灯片样的PDF文档，<code>--html</code> 是编译为可以当幻灯片放映的html文档。（总之都好炫酷！）</p>
<p>以上。</p>
<hr>
<p>PS：</p>
<p>之前那个word press的服务器到期了，不太想续费，于是又把hexo博客系统用起来了。</p>
<p>这个系统还不完善，之前服务器上的诸多照片和评论也还没迁移过来。后面会慢慢完善的！</p>
<p>以及，欢迎大家来评论交流！</p>
<p>2023-4-26 Warren Z</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>HuggingFace在线大模型部署方法</title>
    <url>/2023/11/19/HuggingFace%E5%9C%A8%E7%BA%BF%E5%A4%A7%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>【点击查看更多】</p>
<span id="more"></span>

<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>Hugging Face（抱抱脸🤗）是一家美国公司，专门开发用于构建机器学习应用的工具。Hugging Face成立于2016年，最初是一家开发面向青少年的聊天机器人应用程序的公司。在将聊天机器人模型开源后，这家公司转变方向，专注于成为一个机器学习平台。 </p>
<p>目前，Hugging Face的主要服务方向有两个，分别是 <a href="https://github.com/huggingface/transformers">Transformers模型库</a>、<a href="https://huggingface.co/">Hugging Face Hub托管平台</a>。Transformer模型是一种采用自注意力机制的深度学习模型，由谷歌在2017年推出，已逐步取代长短期记忆（LSTM）等RNN模型成为了NLP问题的首选模型，而Hugging Face所开发和维护的 <a href="https://github.com/huggingface/transformers">Transformers模型库</a> 则是一个模型实现，通过对三大开源机器学习库 Flax、PyTorch 或 TensorFlow 的封装，可以帮助开发者快速搭建和分享基于Transformer模型的AI工具（更多信息可以参考 <a href="https://github.com/huggingface/transformers/blob/main/README_zh-hans.md">官方中文文档</a> ）。</p>
<p>此外，Hugging Face生态系统还包括用于其他任务的库，例如数据集处理（“Datasets”），模型评估（“Evaluate”），模拟（“Simulate”），以及机器学习演示（“Gradio”）。 </p>
<h2 id="2-Hugging-Face模型任务列表"><a href="#2-Hugging-Face模型任务列表" class="headerlink" title="2. Hugging Face模型任务列表"></a>2. Hugging Face模型任务列表</h2><p>到目前为止，在Hugging Face Hub上托管的模型数量已经超过了四十万个。包括Meta公司开源的大语言模型<a href="https://huggingface.co/meta-llama">LLama</a>及其一众衍生模型都托管于此。此外，除了一众大语言模型，Hugging Face Hub还托管了图像识别、图片生成、文字转语音工具等模型。</p>
<p>如下图所示，在Hugging Face Hub的 <a href="https://huggingface.co/tasks">Tasks 页面</a>上列出了所有模型可以实现的任务。这些任务包括图像识别和处理、自然语言处理（对话、填空、相似性计算、文字分类、翻译等等）、语音识别和文字转语音等，几乎涵盖了日常生活中AI工具所能涵盖到的方方面面。</p>
<p><img src="https://pic.imgdb.cn/item/6559fac5c458853aef160a11.jpg" alt="Huggingface tasks"></p>
<p>下面举一些比较知名的模型，以及一些个人感觉有趣实用的模型：</p>
<ul>
<li>图生图模型stable-diffusion-xl-refiner-1.0：<a href="https://huggingface.co/stabilityai/stable-diffusion-xl-refiner-1.0">https://huggingface.co/stabilityai/stable-diffusion-xl-refiner-1.0</a></li>
<li>AIGC图像编辑器InstructPix2Pix：<a href="https://huggingface.co/timbrooks/instruct-pix2pix">https://huggingface.co/timbrooks/instruct-pix2pix</a></li>
<li>Meta开源对话模型LLama：<a href="https://huggingface.co/meta-llama">https://huggingface.co/meta-llama</a></li>
<li>微软开源生物医药文献大模型BioGPT：<a href="https://huggingface.co/microsoft/BioGPT-Large">https://huggingface.co/microsoft/BioGPT-Large</a></li>
<li>赫尔辛基大学文本翻译模型：<a href="https://huggingface.co/Helsinki-NLP/opus-mt-zh-en">https://huggingface.co/Helsinki-NLP/opus-mt-zh-en</a></li>
<li>openai语音识别模型whisper：<a href="https://huggingface.co/openai/whisper-large-v2">https://huggingface.co/openai/whisper-large-v2</a></li>
<li>微软文字转语音工具：<a href="https://huggingface.co/microsoft/speecht5_tts">https://huggingface.co/microsoft/speecht5_tts</a></li>
</ul>
<h2 id="3-在线运行Hugging-Face上托管的模型"><a href="#3-在线运行Hugging-Face上托管的模型" class="headerlink" title="3. 在线运行Hugging Face上托管的模型"></a>3. 在线运行Hugging Face上托管的模型</h2><p>得益于英特尔公司的合作，Hugging Face提供了免费的 <a href="https://huggingface.co/blog/zh/inference-update">基于 CPU 的推理解决方案（Intel Xeon 3rd Gen Scalable cpu）</a> 。对于一些不算太大的模型，可以通过这一功能在线试用这些模型。在这一部分中，我们将介绍使用方法：</p>
<h3 id="3-1-使用推理API窗口在线运行"><a href="#3-1-使用推理API窗口在线运行" class="headerlink" title="3.1 使用推理API窗口在线运行"></a>3.1 使用推理API窗口在线运行</h3><p>以AIGC图像编辑器<a href="https://huggingface.co/timbrooks/instruct-pix2pix">InstructPix2Pix</a>为例。打开这一模型的主页以后，可以在页面右侧看到 <strong>“Inference API”</strong> 窗口（如下图的红框所示）。我们可以在这个窗口中在线试用这一模型。</p>
<p><img src="https://pic.imgdb.cn/item/655a0969c458853aef507099.jpg" alt="在线推理"></p>
<p>例如，在图片输入框中上传图片（随手拍摄的街景），再在文本框中输入提示词（“what if it looks when the left white building is a port and the right road is a river”，如果左边的白色大楼是个港口而右边的马路是条河，图片会长什么样子），点击“compute”开始在线推理，大约几秒钟就会得到下面的输出图片：</p>
<p><img src="https://pic.imgdb.cn/item/655a0affc458853aef57b571.jpg" alt="试用在线推理"></p>
<p>还别说，这个在线推理效果真的很不错，生成的图片比原图还壮观一点有木有！</p>
<h3 id="3-2-在程序中调用在线推理API"><a href="#3-2-在程序中调用在线推理API" class="headerlink" title="3.2 在程序中调用在线推理API"></a>3.2 在程序中调用在线推理API</h3><p>在这一部分中，我们以 <a href="https://huggingface.co/microsoft/BioGPT-Large">BioGPT-Large</a> 为例进行讲述。</p>
<p>首先注册并登录Hugging Face，然后在账号设置页面找到tokens设置（ <a href="https://huggingface.co/settings/tokens">https://huggingface.co/settings/tokens</a> ），在此处点击“New token”按钮添加token（如果仅仅只是想跑大模型，而不进行模型训练或微调，token的角色（role）选择read即可）。</p>
<p>之后打开我们想在线推理的模型，点击Deploy按钮，选择Inference API（如下图），此时会弹出一个窗口。</p>
<p><img src="https://pic.imgdb.cn/item/655a0c07c458853aef5c8ba1.jpg" alt="Deploy按钮"></p>
<p>复制弹出窗口的代码，并将其中的token设置（request标头中的Authorization字段）换成上面我们刚刚获得的token即可（如下图）。</p>
<p><img src="https://pic.imgdb.cn/item/655a0ccdc458853aef6026d2.jpg" alt="demo代码复制对话框"></p>
<p>以 <a href="https://huggingface.co/microsoft/BioGPT-Large">BioGPT-Large</a> 的API为例，我们复制得到的调用代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">API_URL = <span class="string">&quot;https://api-inference.huggingface.co/models/microsoft/BioGPT-Large&quot;</span></span><br><span class="line">headers = &#123;<span class="string">&quot;Authorization&quot;</span>: <span class="string">&quot;Bearer xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;</span>&#125; <span class="comment"># xxxx这一段改成你的token</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">payload</span>):</span><br><span class="line">	response = requests.post(API_URL, headers=headers, json=payload)</span><br><span class="line">	<span class="keyword">return</span> response.json()</span><br><span class="line">output = query(&#123;</span><br><span class="line">	<span class="string">&quot;inputs&quot;</span>: <span class="string">&quot;Can you please let us know more details about your &quot;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>为了得到打印输出，我们在上述代码的最后再添加一行代码（这段代码Hugging Face上不会提供，需要自己添加）： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[&#123;&#x27;generated_text&#x27;: &#x27;Can you please let us know more details about your  case? &lt; / FREETEXT &gt; &lt; / TITLE &gt;&#x27;&#125;]</span><br></pre></td></tr></table></figure>

<p>既然有了API，我们可以做的事情就变多了。例如，我们可以对程序进行改造，获得一个可以循环对话的模型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> sys <span class="comment"># 新引入的模块，用于控制程序退出</span></span><br><span class="line">API_URL = <span class="string">&quot;https://api-inference.huggingface.co/models/microsoft/BioGPT-Large&quot;</span></span><br><span class="line">headers = &#123;<span class="string">&quot;Authorization&quot;</span>: <span class="string">&quot;Bearer xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;</span>&#125; <span class="comment"># xxxx这一段改成你的token</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">payload</span>):</span><br><span class="line">	response = requests.post(API_URL, headers=headers, json=payload)</span><br><span class="line">	<span class="keyword">return</span> response.json()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">text</span>):</span><br><span class="line">    output = query(&#123;<span class="string">&quot;inputs&quot;</span>: text,&#125;)</span><br><span class="line">    <span class="built_in">print</span>(output[<span class="number">0</span>][<span class="string">&#x27;generated_text&#x27;</span>])</span><br><span class="line"><span class="keyword">if</span>(__name__==<span class="string">&quot;__main__&quot;</span>):</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">        text = <span class="built_in">input</span>(<span class="string">&quot;\n(BioGPT) &gt;&gt;&gt; &quot;</span>) <span class="comment"># 获取键盘输入</span></span><br><span class="line">        <span class="keyword">if</span>(text==<span class="string">&quot;/exit&quot;</span>): sys.exit(<span class="number">0</span>)  <span class="comment"># 如果输入`/exit`，则退出程序</span></span><br><span class="line">        <span class="keyword">else</span>:              run(text)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(BioGPT) &gt;&gt;&gt; covid-19 is</span><br><span class="line">covid-19 is a novel, potent, and selective inhibitor of the human and mouse 1</span><br><span class="line"></span><br><span class="line">(BioGPT) &gt;&gt;&gt; PD-L1 therapy is</span><br><span class="line">PD-L1 therapy is a promising strategy for the treatment of NSCLC. However, the clinical efficacy of</span><br><span class="line"></span><br><span class="line">(BioGPT) &gt;&gt;&gt; by inhibit IGF receptor, researches</span><br><span class="line">by inhibit IGF receptor, researches have shown that IGF-1R is a potential target for cancer therapy.</span><br><span class="line"></span><br><span class="line">(BioGPT) &gt;&gt;&gt; /exit</span><br><span class="line">请按任意键继续...</span><br></pre></td></tr></table></figure>

<h3 id="3-3-其他注意事项："><a href="#3-3-其他注意事项：" class="headerlink" title="3.3 其他注意事项："></a>3.3 其他注意事项：</h3><ul>
<li>（1）单个账号的在线运行大模型似乎有使用数量的限制（参考 <a href="https://huggingface.co/docs/api-inference/faq">https://huggingface.co/docs/api-inference/faq</a> ）；</li>
<li>（2）不是所有在huggingFace上托管的模型都可以在线运行，例如chatGLM、llama等就无法使用这一功能。</li>
</ul>
<h2 id="4-将Hugging-Face-Hub上托管的大模型下载到本地，并离线运行"><a href="#4-将Hugging-Face-Hub上托管的大模型下载到本地，并离线运行" class="headerlink" title="4. 将Hugging Face Hub上托管的大模型下载到本地，并离线运行"></a>4. 将Hugging Face Hub上托管的大模型下载到本地，并离线运行</h2><p>如题。既然Hugging Face Hub能够托管大模型，那么一定可以下载大模型。半个月前我在博客上发表的文章 <a href="https://wz.anoms.top/2023/11/03/%E3%80%90%E8%BD%AC%E8%BD%BD-%E4%BF%AE%E6%94%B9%E3%80%91%E4%B8%80%E4%B8%AAPC%E7%AB%AF%E7%9A%84%E7%A6%BB%E7%BA%BF%E7%BF%BB%E8%AF%91%E7%A8%8B%E5%BA%8F/#more">《一个PC端的离线翻译程序》</a> 就是示例。</p>
<p>本文则会以另一个模型，微软 <a href="https://huggingface.co/microsoft/speecht5_tts">speecht5_tts文字转语音工具</a>为例进行讲述。这个模型当然可以在线部署和运行，不过此处讲述如何本地运行。</p>
<p>Hugging Face Hub上的大多数模型，依赖于<a href="https://wz.anoms.top/2023/06/19/LSTM/">Transformer架构</a>。因此，下面这些python依赖库必不可少：</p>
<ul>
<li><a href="https://pypi.org/project/transformers/">transformers</a></li>
<li><a href="https://pytorch.org/get-started/locally/">pytorch</a></li>
</ul>
<p>对于 <a href="https://huggingface.co/microsoft/speecht5_tts">speecht5_tts</a> ，还需要安装如下python模块：</p>
<ul>
<li><a href="https://pypi.org/project/datasets/">datasets</a></li>
<li><a href="https://pypi.org/project/sentencepiece/">sentencepiece</a></li>
<li><a href="https://pypi.org/project/soundfile/">soundfile</a></li>
</ul>
<p><code>datasets</code>用于加载必要的数据集，<code>soundfile</code>则是音频数据处理工具。</p>
<p>此外，如果之前安装过 <a href="https://pypi.org/project/transformers/">transformers</a> 模块，那么也需要检查一下是否是最新版，如果不是最新版的话需要进行升级，否则运行下文中的代码可能会出问题。升级指令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install --upgrade transformers</span><br></pre></td></tr></table></figure>

<p>我们可以直接使用文档给出的代码进行程序的运行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> pipeline</span><br><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> load_dataset</span><br><span class="line"><span class="keyword">import</span> soundfile <span class="keyword">as</span> sf</span><br><span class="line"></span><br><span class="line">synthesiser = pipeline(<span class="string">&quot;text-to-speech&quot;</span>, <span class="string">&quot;microsoft/speecht5_tts&quot;</span>)</span><br><span class="line"></span><br><span class="line">embeddings_dataset = load_dataset(<span class="string">&quot;Matthijs/cmu-arctic-xvectors&quot;</span>, split=<span class="string">&quot;validation&quot;</span>)</span><br><span class="line">speaker_embedding = torch.tensor(embeddings_dataset[<span class="number">7306</span>][<span class="string">&quot;xvector&quot;</span>]).unsqueeze(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># You can replace this embedding with your own as well.</span></span><br><span class="line"></span><br><span class="line">speech = synthesiser(<span class="string">&quot;Hello, my dog is cooler than you!&quot;</span>, forward_params=&#123;<span class="string">&quot;speaker_embeddings&quot;</span>: speaker_embedding&#125;)</span><br><span class="line"></span><br><span class="line">sf.write(<span class="string">&quot;speech.wav&quot;</span>, speech[<span class="string">&quot;audio&quot;</span>], samplerate=speech[<span class="string">&quot;sampling_rate&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>第一次运行会从Hugging Face Hub上加载模型（大概几百MB，这一过程中需要科学上网）。之后，后面的代码会运行，由此可以得到一段音频<code>speech.wav</code>，里面是我们想要转语音的文本 <code>&quot;Hello, my dog is cooler than you!&quot;</code> 的内容。</p>
<p>如果想要对其他内容进行文本转语音的朗读，可以改写上面代码的<code>speech = synthesiser(&quot;Hello, my dog is cooler than you!&quot;, forward_params=&#123;&quot;speaker_embeddings&quot;: speaker_embedding&#125;)</code>这一行内容。或者，对模型进一步封装：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="comment"># reference: https://huggingface.co/microsoft/speecht5_tts</span></span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> pipeline</span><br><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> load_dataset</span><br><span class="line"><span class="keyword">import</span> soundfile <span class="keyword">as</span> sf</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">synthesiser = pipeline(<span class="string">&quot;text-to-speech&quot;</span>, <span class="string">&quot;microsoft/speecht5_tts&quot;</span>)</span><br><span class="line">embeddings_dataset = load_dataset(<span class="string">&quot;Matthijs/cmu-arctic-xvectors&quot;</span>, split=<span class="string">&quot;validation&quot;</span>)</span><br><span class="line">speaker_embedding = torch.tensor(embeddings_dataset[<span class="number">7306</span>][<span class="string">&quot;xvector&quot;</span>]).unsqueeze(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># You can replace this embedding with your own as well.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">text</span>):</span><br><span class="line">    speech = synthesiser(text, forward_params=&#123;<span class="string">&quot;speaker_embeddings&quot;</span>: speaker_embedding&#125;)</span><br><span class="line">    sf.write(<span class="string">&quot;speech.wav&quot;</span>, speech[<span class="string">&quot;audio&quot;</span>], samplerate=speech[<span class="string">&quot;sampling_rate&quot;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;wav file saved&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(__name__==<span class="string">&quot;__main__&quot;</span>):</span><br><span class="line">    text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Churchill is known as the &quot;polar bear capital of the world&quot; (you can even get your passport stamped stating as such at the post office) but the beluga whales are the star of the summer season.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>.strip()</span><br><span class="line">    run(text)</span><br></pre></td></tr></table></figure>

<p>改写<code>text=</code>后面的内容即可。输出文件依然是<code>speech.wav</code>。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>huggingface</tag>
        <tag>python</tag>
        <tag>自然语言处理</tag>
        <tag>图生图模型</tag>
        <tag>在线推理API</tag>
      </tags>
  </entry>
  <entry>
    <title>Attention机制、Transformer与GPT（阅读笔记）</title>
    <url>/2023/06/19/LSTM/</url>
    <content><![CDATA[<p>之前读到了一篇使用LSTM检测正选择的算法文章，对LSTM以及衍生出的Transformer很感兴趣，于是花了一晚上了解了一下。下面是一些参考链接和笔记，记得不好，权当抛砖引玉了。</p>
<span id="more"></span>

<p>参考：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/dKbGR4sCkNpik0Xw41QLVw">《从word2vec开始，说下GPT庞大的家族系谱》</a></li>
<li><a href="https://mp.weixin.qq.com/s/M-ToNk8SABoP2JG0xLUBxQ">《后GPT书：从GPT-3开始，续写Transformer庞大家族系谱》</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/46990010">《论文解读:Attention is All you need - 习翔宇的文章 - 知乎》</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/48508221">《详解Transformer （Attention Is All You Need） - 大师兄的文章 - 知乎》</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/42706477">《详解残差网络》</a>（残差网络是一种将不同层之间的神经元连接起来、跳过一些中间层的模型，其可以应对深层神经网络随着层数增多而出现的退化（degradation）问题）</li>
<li><a href="http://jalammar.github.io/illustrated-transformer/">The Illustrated Transformer</a></li>
</ul>
<p>代码实现与练习（pytorch）：</p>
<ul>
<li><a href="https://pytorch.org/tutorials/beginner/transformer_tutorial.html">Language Modeling with nn.Transformerand torchtext</a></li>
</ul>
<p>2013年最早提出了attention机制（ <a href="https://arxiv.org/abs/1409.0473">https://arxiv.org/abs/1409.0473</a> ），当时的attention机制是与RNN/LSTM一起工作的。</p>
<p>2017年，谷歌机器翻译团队提出了Transformer算法，在这个算法中他们改进了attention，使其以self-attention的方式能够单独工作，相关论文见 Attention is All You Need（ <a href="https://arxiv.org/pdf/1706.03762.pdf">https://arxiv.org/pdf/1706.03762.pdf</a> ）。</p>
<p><img src="https://pic.imgdb.cn/item/64a2e3aa1ddac507cc80711a.png"></p>
<p>（上图展示了self-attention的计算细节。attention 机制里主要有三个向量 - key, query 和 value，分别对应公式中的三个向量K、Q和V。其实可以将 Attention 机制看作一种软寻址（Soft Addressing）:Source 可以看作一个中药铺子的储物箱，储物箱里的药品由地址 Key（药品名）和值 Value（药品）组成，当前有个 Key=Query（药方）的查询，目的是取出储物箱里对应的 Value 值（药品），即 Attention 数值。通过 Query 和储物箱内元素 Key 的地址进行相似性比较来寻址，之所以说是软寻址，指的是我们不只从储物箱里面找出一中药物，而是可能从每个 Key 地址都会取出内容，取出内容的重要性（量的多少）根据 Query 和 Key 的相似性来决定，之后对 Value 进行加权求和，这样就可以取出最终的 Value 值（一副中药），也即 Attention 值。所以不少研究人员将 Attention 机制看作软寻址的一种特例，这也是非常有道理的）</p>
<p><img src="https://pic.imgdb.cn/item/64a2e3c01ddac507cc809889.png"></p>
<p>（对于一个词（query），attention可以给出这个词与句子中其他词的相关性概率值）</p>
<p><img src="https://pic.imgdb.cn/item/64a2e3d51ddac507cc80bc1f.png"></p>
<p>（self-attention的机制总结为公式的话就是上图。分母中的 $\sqrt{dk}$ 是为了score归一化，从而保证梯度稳定）</p>
<p>transformer的模型架构如下：</p>
<p><img src="https://pic.imgdb.cn/item/64a2e3ef1ddac507cc80e69e.png"></p>
<p>如果这个图过于复杂，可以参考下面这个简化版的卡通图（来自 <a href="http://jalammar.github.io/illustrated-transformer/">http://jalammar.github.io/illustrated-transformer/</a> ）：</p>
<p><img src="https://pic.imgdb.cn/item/64a2e4031ddac507cc81041d.png"></p>
<p>输入层被一个Encoder处理，再经过一个decoder得到输出。decoder模块比encoder模块多一个encoder-decoder attention层，这个层结合了decoder的输入和encoder的输出。</p>
<p>transformer最初用于机器翻译模型，后来被迁移到文本处理和图像处理上，衍生出了一大堆模型，比较出名的有语言模型GPT和BRAT，以及图像识别模型ViT。其中，ViT抛弃了传统的CNN结构，而是将图形分割成多个区域，并学习不同区域之间的关联性。</p>
<p>其中，GPT继承了decoder的部分，而BRAT继承了encoder的部分。BRAT在文本分类的任务上表现很好，而GPT则展现出了更加通用的能力。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>Attention机制</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>R语言GO富集分析踩坑之HPO.db的安装</title>
    <url>/2023/11/11/R%E8%AF%AD%E8%A8%80GO%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90%E8%B8%A9%E5%9D%91%E4%B9%8BHPO-db%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>之前装clusterProfiler的时候遇到这个问题，死活装不上HPO.db这个依赖包，后来经过了好一番折腾终于解决了。</p>
<span id="more"></span>

<p>太长不看版： 从Github上下载 <a href="https://github.com/huerqiang/HPO.db_MPO.db/tree/main">离线安装包</a> ，然后安装这个版本。</p>
<hr>
<p>在完成基因差异表达分析以后，GO富集分析和KEGG富集分析常常是我们要进行的流程。</p>
<p><a href="https://www.geneontology.org/">基因本体论（gene ontology）数据库</a> 是一个致力于各种生物学数据标准化的项目，这一项目从三个GO domains上描述我们对生物学领域的了解。在每一个domains中都有大量GO term（GO术语），每一条术语包含与之对应的若干基因。</p>
<blockquote>
<p>三个GO domains分别是BP（biological process），MF（molecular function），CC（cellular component）</p>
</blockquote>
<p>例如，在BP domain下面有一条术语”regulation of activated T cell proliferation”（活化T细胞增殖的调控），其包含了与这一功能相关的几十个基因，例如 <code>IGF1/IL23A/JAK3/FOXP3/CD274/ARG1/IL12RB1/SLAMF1/IL18</code> 等。</p>
<p>更多的信息，可以参考知乎文章 <a href="https://zhuanlan.zhihu.com/p/350544360">《Gene Ontology(GO)简介与使用介绍》</a></p>
<p>GO富集分析，则是使用一些统计检验的方法，帮助我们寻找差异基因与哪些生物学通路或大分子复合物有关，从而对我们在实验中发现的差异基因进行功能注释，或用于更下游的探索。南方医科大学的<a href="http://yulab-smu.top/">余光创</a>教授开发了<a href="https://bioconductor.org/packages/release/bioc/html/clusterProfiler.html">clusterProfiler</a>这一R包，可以让我们在R中方便地进行GO富集分析与可视化。然而，这个包依赖了余教授（aka. Y叔）开发的另外多款R包，包括<a href="https://bioconductor.org/packages/release/bioc/html/DOSE.html">DOSE</a> 和 <a href="https://bioconductor.org/packages/release/data/annotation/html/HPO.db.html">HPO.db</a> 等，因此安装过程很漫长，很需要耐心……以及，面对安装失败时的好脾气。</p>
<p><img src="https://pic.imgdb.cn/item/654f9585c458853aefc2a73c.jpg" alt="HPO.db安装失败啦"></p>
<p>（上图：令人高血压的报错）</p>
<p>关于报错的原因，Y叔专门写了一篇文章来说明（<a href="https://mp.weixin.qq.com/s/Gk6szLg3rRiq2uW_1x7etg">《听说你的clusterProfiler装不上了？》</a>），大意是HPO.db用到了一些云服务，需要靠AnnotationHub获取数据，如果AnnotationHub不对则有可能安装失败，也就是说安装失败的锅他们不背。</p>
<p>但是我们总归是要解决这个问题的，要不然科研进度又双叒叕要拖上一阵子了……</p>
<p>所以我们仔细看看报错是怎么报的： </p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">error: Invalid Cache: sqlite file</span><br><span class="line">Hub has not been added to cache</span><br><span class="line">Run again with &#x27;localHub=FALSE&#x27;</span><br></pre></td></tr></table></figure>

<p>报错信息提示我们加上 <code>localHub=FALSE</code> 再去跑一次。然而我试过了，并不行。</p>
<p>R语言的<code>install.packages()</code>函数提供了安装离线版本安装包的能力。既然作者说HPO.db用到了一些云服务，那么如果我们用离线包安装，会不会好一点呢？<a href="https://bioconductor.org/packages/release/data/annotation/html/HPO.db.html">Bioconductor</a>上确实提供了离线包的下载链接（如下图红框），我们把它下载下来安装试一下。</p>
<p><img src="https://pic.imgdb.cn/item/654f98b5c458853aefd2fff8.jpg" alt="红框里为下载地址"></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这个指令用于离线安装，从本地加载安装包</span></span><br><span class="line"><span class="comment"># 第一个参数填入安装包的完整文件路径，下面的路径只是一个示范</span></span><br><span class="line">install.packages<span class="punctuation">(</span><span class="string">&quot;HPO.db_0.99.2.tar.gz&quot;</span><span class="punctuation">,</span>repos<span class="operator">=</span><span class="literal">NULL</span><span class="punctuation">,</span>type<span class="operator">=</span><span class="string">&quot;source&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>本以为这样会好一点，结果还是收到了和刚刚一样的报错。问题出在哪儿呢？百思不得其解。</p>
<p>百般无奈之下，翻起了作者的Github，结果无意中看到一条这样的<a href="https://github.com/YuLab-SMU/HPO.db/issues/4">issue</a> （乐：</p>
<p><img src="https://pic.imgdb.cn/item/654f9a8bc458853aefdc0325.jpg" alt="作者本人回应"></p>
<p>作者大概是知道HPO.db安装失败这回事，于是整理出了一个离线版的包。作者也建议我们从这个存储库（<a href="https://github.com/huerqiang/HPO.db_MPO.db">huerqiang/HPO.db_MPO.db</a>）中下载离线版本的HPO.db包用于安装。我们先把这两个文件下载下来：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/huerqiang/HPO.db_MPO.db.git</span><br><span class="line"><span class="built_in">cd</span> HPO.db_MPO.db</span><br><span class="line"><span class="built_in">ls</span> -lh</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">total 28M</span><br><span class="line">-rw-rw-r--    1 user    user       6.2M Nov 11 23:18 HPO.db_0.99.0.tar.gz</span><br><span class="line">-rw-rw-r--    1 user    user      21.4M Nov 11 23:18 MPO.db_0.99.0.tar.gz</span><br><span class="line">-rw-rw-r--    1 user    user        422 Nov 11 23:18 README.md</span><br></pre></td></tr></table></figure>

<p>从文件体积上看，这个“离线安装版”确实比bioconductor版大了一圈。是离线包无疑了，希望这次能成功。</p>
<p>还用前面的离线安装方法试一下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 和前面一样，第一个参数填入安装包的完整文件路径，下面的路径只是一个示范</span></span><br><span class="line">install.packages<span class="punctuation">(</span><span class="string">&quot;HPO.db_0.99.0.tar.gz&quot;</span><span class="punctuation">,</span>repos<span class="operator">=</span><span class="literal">NULL</span><span class="punctuation">,</span>type<span class="operator">=</span><span class="string">&quot;source&quot;</span><span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span><span class="string">&quot;HPO.db&quot;</span><span class="punctuation">)</span>         <span class="comment"># 如果安装完了，用这个指令test一下，看看能不能加载</span></span><br><span class="line">packageVersion<span class="punctuation">(</span><span class="string">&quot;HPO.db&quot;</span><span class="punctuation">)</span>  <span class="comment"># 以及查看一下版本号</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; install.packages(&quot;HPO.db_0.99.0.tar.gz&quot;,repos=NULL,type=&quot;source&quot;)</span><br><span class="line">* installing *source* package &#x27;HPO.db&#x27; ...</span><br><span class="line">** using staged installation</span><br><span class="line">** R</span><br><span class="line">** inst</span><br><span class="line">** byte-compile and prepare package for lazy loading</span><br><span class="line">** help</span><br><span class="line">*** installing help indices</span><br><span class="line">** building package indices</span><br><span class="line">** installing vignettes</span><br><span class="line">** testing if installed package can be loaded from temporary location</span><br><span class="line">** testing if installed package can be loaded from final location</span><br><span class="line">** testing if installed package keeps a record of temporary installation path</span><br><span class="line">* DONE (HPO.db)</span><br><span class="line">&gt; library(&quot;HPO.db&quot;)</span><br><span class="line">&gt; packageVersion(&quot;HPO.db&quot;)</span><br><span class="line">[1] &#x27;0.99.0&#x27;</span><br></pre></td></tr></table></figure>

<p>如此，终于安装成功！</p>
<p>在这以后，安装clusterProfiler就一帆风顺多了。至于作者提到的AnnotationHub的问题，或许等未来这些依赖库更新后会解决吧。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>生信分析踩坑</tag>
        <tag>clusterProfiler</tag>
      </tags>
  </entry>
  <entry>
    <title>“往前走，别回头”——真的要这样吗？</title>
    <url>/2023/06/26/The-Long-Season/</url>
    <content><![CDATA[<p>在端午假期的尾巴上，偶然知道了一部很好的网剧《漫长的季节》。前两天开二倍速匆匆刷完了正片，却花了许多时间在看解读。有人从悬疑剧的角度分析剧情，有人从偶像剧的角度分析人物关系和情感线索，但是我更喜欢的是站在故事的时代背景下的那些分析，更加“现实”的分析。</p>
<span id="more"></span>

<p>故事背景，东北大下岗。下岗的波涛实在凶猛，以至于连大学生出身的厂办龚彪都没了职业，被迫开出租。看到这里，有人百思不得解，王师傅只会开火车，加上下岗那一年受到了那么多打击，最后靠着捡着了王北才勉强有了活下来的动力，以出租车司机的身份活到了2016年，你龚彪是大学生，而且婚姻不幸福也是自找的，明明你可以不下岗，就算下岗以你大学生身份也能混的很好——可是你咋就也沦落成这个熊样了？</p>
<p>龚彪自身的问题放到后面说，先来讲讲大下岗的结果。事实上，当时钢厂的人没有一个过得好的，王师傅这一家也不算什么。甚至有女工为了照顾孩子、补贴家用不惜下海。那是一代可怕的记忆。</p>
<p>看到大下岗，其实有点共鸣。主要是最近这几年社会压力确实变大了许多，IT行业的轮番裁员大潮也让人心存余悸。年初看到消息说南方某市网约车司机和外卖骑手饱和，昨天又看到旧闻说四月下旬潮汕外卖员因为待遇过低发起过罢工。这一切都让人想起了二十多年前东北的种种现象，因此更想通过《漫长的季节》去了解那个时代的人的所见所思所想所活。</p>
<p>王响师傅在剧末对着年轻时还是火车司机的自己喊“往前看，别回头”，有人说这是要放下执念，接受这操蛋的生活、操蛋的命运所安排的一切。但也有人给出另一种理解：生活总得往后看，往后看是为了不忘记过去，从过去中汲取教训；向前看别回头是一种美好的期望，但要想过好生活，就无法真正做到别回头。</p>
<p>剧中真正身体力行做到了“向前看别回头”的是厂办王彪（也有人认为是他在发现被绿真相以后就彻底摆烂；不过说起来，摆烂和“向前看别回头”好像某种意义上是相通的）。虽然生活过得一塌糊涂，但是人彪子心大，活得开心豁达，人生的最后也是在中彩票的快乐中笑着离开的。可是，这真的就是快乐的人生吗？他确定没有用这种乐观麻痹自己吗？好歹是90年代的大学生，下岗以后完全失去了生活能力，有点可悲可叹。</p>
<p>说点我自己代入到剧中人物后的想法。做人不能一味向前看，也需要经常性回过头：不一定是纠结于过去的执念，而是提醒自己，我过去曾经有过什么样的经历什么样的生活，现在的自己不能愧对过去付出的那些努力、那些时光。纵使世界上充满意外，时代的一粒尘落在每个人身上也都是一座山，但是在时代大潮之下，你也可以用自己的主观能动性、自己的勇敢和不屈不挠，给自己闯下一片天。虽然王师傅和彪子的晚年职业看似相同，但是王师傅是从丧妻丧子之痛中挺了过来，并且一步一步直挺着走到现在的，而昔日大学生、厂办职工龚彪在下岗之后彻底摆烂，开出租车也只是给自己找一份闲职罢了——两个人的精神面貌不可同日而语，二人的人生轨迹也完全不同。我更敬佩王响师傅在绝境中站起来的刚强勇毅，讨厌摆烂后的龚彪得过且过的生活。</p>
<p>站起来，走几步。往前看，但也千万别不回头——偶尔回下头，忘记过去的伤痛，但也要记住自己曾经的辉煌。未来掌控在自己手中，想让它高走它未必会高走（但至少比什么不做要强），但是想要摆烂低走它也会顺势而为。为了自己的理想，为了这操蛋的生活，拼了！</p>
]]></content>
      <categories>
        <category>杂思</category>
      </categories>
      <tags>
        <tag>人生选择</tag>
        <tag>观影感受</tag>
        <tag>《漫长的季节》</tag>
      </tags>
  </entry>
  <entry>
    <title>ACMG SF v3.0与附带发现（secondary findings）基因列表</title>
    <url>/2022/08/03/acmg-sf-v3-0%E4%B8%8E%E9%99%84%E5%B8%A6%E5%8F%91%E7%8E%B0%EF%BC%88secondary-findings%EF%BC%89%E5%9F%BA%E5%9B%A0%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p>先从一页PPT说起</p>
<span id="more"></span>

<p><img src="https://pic.imgdb.cn/item/657ed027c458853aef363c0d.jpg" alt="网络研讨会——西湖大学样本库建设进展及中国人群遗传结构和变异研究"></p>
<p>上图为今年7月15日的网络研讨会中，西湖大学郑厚峰博士的讲座内容。郑老师提到，在西湖大学人群队列中，他们对73个secondary genetic variants genes进行了分析。这里的secondary genetic variants是个什么东西，PhD.郑并没有详细讲述。</p>
<p>在查阅一些资料以后，对这个基因列表有了些了解，就此做下记录。</p>
<p>以下内容摘抄自 <a href="https://blog.csdn.net/fanyucai1/article/details/103988910">https://blog.csdn.net/fanyucai1/article/details/103988910</a></p>
<blockquote>
<p>2012年1月美国医学遗传学与基因组学学会（ACMG，American College of Medical Genetics and Genomics）委员会正式批准成立临床外显子和基因组测序工作小组，此小组的任务就是当病人进行外显子或基因组测序时发现的偶发突变给出推荐性的指导。2013年，ACMG发表了一篇关于临床的官方声明，明确强调了偶发变异可能对揭示患者病情、临床测试以及报告结果的重要性。</p>
</blockquote>
<blockquote>
<p>2016年，ACMG更新了附带发现（secondary findings）的基因列表，他们推荐实验室在临床外显子和基因组测序结果中报告这些基因的突变。附带发现是指这些基因的变异与检测的初始目的没有关系，但会导致严重的疾病，目前关于这些变异的知识可以指导临床实践。ACMG发布这些建议的原因是，临床外显子组和基因组测序检测开始激增，但却缺乏相应的标准。ACMG不断更新的建议可以帮助确定哪些附带发现可以反馈给患者，对成年人和儿童患者都适用。更新后的列表包括59个基因。</p>
</blockquote>
<blockquote>
<p>早在2015年，美国医学遗传学和基因组学（ACMG）以及分子病理学协会（AMP）曾联合出版了变异位点解读指南，基于28个判断标准（criteria）将变异位点分为了Pathogenic、Likely pathogenic、Uncertain significance、Likely benign和Benign五个级别。同样，在2017年，AMP、ASCO和CAP也联合制定了体细胞突变变异位点解读指南，基于变异位点的临床意义将其分为Tier I、Tier II、Tier III、Tier IV四个级别。时隔两年，由中国遗传学会遗传咨询分会领衔的专家团队共同编译了《ACMG遗传变异分类标准与指南》中文版（以下简称“中文版”），并获得美国ACMG的官方授权。中文在线地址：<a href="http://acmg.cbgc.org.cn/doku.php?id=start">http://acmg.cbgc.org.cn/doku.php?id=start</a></p>
</blockquote>
<blockquote>
<p>2019年ACMG又提供了关于拷贝数变异检测的临床指导意见，在分类上同样。</p>
</blockquote>
<p>也就是说，这个gene list是用于临床指导患病风险预测的列表，经过大量临床研究确定了这些variants与疾病存在关联性，并依据关联性是否显著，对这些基因的预测能力进行了分级。变异可以分为**(i) pathogenic（P，致病）, (ii) likely pathogenic（LP，可能致病）, (iii) uncertain significance（意义不明）, (iv) likely benign（可能良好）, 以及 (v) benign（良好）**。而针对致病变异的标准又可分为非常强(very strong，PVS1)，强(strong，PS1-4); 中等(moderate，PM1-6)，或辅助证据(supporting，PP1-5)。良性变异证据可分为独立(stand-alone，BA1)，强(strong，BS1-4)，或辅助证据(BP1-6)。其中，数字只是作为有助于参考的分类标注，不具有任何意义。每个类别中的数字不表示分类的任何差异，仅用来标记以帮助指代不同的规则。</p>
<p>下列论文（SF v3.0）供参考。文中提到，</p>
<p>“<strong>The goal of the SF gene list is to guide clinical laboratories as to which medically actionable genes unrelated to the indication for testing should be evaluated as part of clinical exome and genome sequencing (ES/GS), while maintaining a minimum list to balance the interests of patients with the additional burden placed on laboratories providing sequencing.</strong>“</p>
<p>大致意思就是说，在提供测序服务（包括外显子测序和全基因组测序）的临床诊断实验室中，被测序的基因不应该仅仅是患者的疾病所关联的那些基因（或者患者关心的那些基因），还应该关注基因组上可能造成其他疾病的潜在变异位点，而<strong>这份清单的目的就是列出来这些风险基因位点，使得临床诊断既能够准确地发现风险，从而指导治疗和预防，又能够控制测序成本</strong>。</p>
<p>这些gene list所包含的基因及其变异，依据已发表的临床数据，可以预测个体患病的风险。因此，在中国人群中，研究这个gene list上的基因的变异分布情况，可以对中国人群的整体健康风险有所了解。</p>
<p><strong>参考资料</strong></p>
<p><a href="http://acmg.cbgc.org.cn/doku.php?id=start">http://acmg.cbgc.org.cn/doku.php?id=start</a></p>
<p><a href="https://github.com/fanyucai1/ACMG_CAP">https://github.com/fanyucai1/ACMG_CAP</a></p>
<p><a href="https://blog.csdn.net/fanyucai1/article/details/103988910">https://blog.csdn.net/fanyucai1/article/details/103988910</a></p>
<p><a href="https://www.gimjournal.org/article/S1098-3600(21)05076-0/fulltext">https://www.gimjournal.org/article/S1098-3600(21)05076-0/fulltext</a></p>
]]></content>
      <categories>
        <category>生物</category>
      </categories>
      <tags>
        <tag>ACMGSF</tag>
        <tag>附带发现基因列表</tag>
      </tags>
  </entry>
  <entry>
    <title>Attention机制与self-attention详解（二）——Transformer架构</title>
    <url>/2023/12/09/attention_architecture_2/</url>
    <content><![CDATA[<p>时隔半年，再次复习一下attention机制，并学习一下什么是self-attention。</p>
<span id="more"></span>


<blockquote>
<p>参考： <a href="https://www.bilibili.com/video/BV1v3411r78R">https://www.bilibili.com/video/BV1v3411r78R</a></p>
</blockquote>
<h2 id="一、引言：Self-attention（Seq2seq）的常见应用"><a href="#一、引言：Self-attention（Seq2seq）的常见应用" class="headerlink" title="一、引言：Self-attention（Seq2seq）的常见应用"></a>一、引言：Self-attention（Seq2seq）的常见应用</h2><ul>
<li>语音识别</li>
<li>文本翻译</li>
<li>语音翻译（直接将一种语言的音频转化为另一种语言的音频，对于一些没有语言的文字，或者一些语言方言的翻译很有用）</li>
</ul>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231209131238.png" alt="image.png"></p>
<p>上图：使用1500小时的台语（闽南语？）乡土剧视频资料（带有中文字幕）进行训练，训练前不处理背景音乐的noise问题、语音与字母可能对不上的问题等（所谓“硬train一发”），得到的机器学习模型依然表现出了很强的闽南语识别与翻译的能力。</p>
<ul>
<li><p>Seq2seq用于聊天机器人任务（ChatBot）</p>
<ul>
<li>训练集：对话数据。</li>
<li><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231209131916.png" alt="image.png"></li>
<li>许多任务也可以抽象为“Question-Answering（QA）”的模型，例如文本翻译、文章摘要、情感判断等，并使用Transformer训练。<ul>
<li>当然，对于这些特定任务，其实也不一定用QA这种模型，用一些针对特定任务设计的专用模型可能更好（所谓杀鸡焉用牛刀）</li>
</ul>
</li>
<li><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231209132152.png" alt="image.png"></li>
</ul>
</li>
<li><p>seq2seq用于文法剖析（syntactic parsing）</p>
<ul>
<li><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231209132546.png" alt="image.png"></li>
</ul>
</li>
<li><p>seq2seq用于多标签分类问题（multi-label classification）</p>
<ul>
<li>注意与多类别分类问题（multi-class classification）的区别：一个输入对象可能属于多个分类（class），但只对应一个标签（label）</li>
<li><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231209132932.png" alt="image.png"></li>
</ul>
</li>
</ul>
<ul>
<li>seq2seq也可以用于图像中的对象识别（虽然有一种硬解的味道在里面）<ul>
<li><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231209133005.png" alt="image.png"></li>
</ul>
</li>
</ul>
<h2 id="二、transformer模型（Seq2seq模型）的结构"><a href="#二、transformer模型（Seq2seq模型）的结构" class="headerlink" title="二、transformer模型（Seq2seq模型）的结构"></a>二、transformer模型（Seq2seq模型）的结构</h2><h3 id="（一）结构：Encoder-Decoder"><a href="#（一）结构：Encoder-Decoder" class="headerlink" title="（一）结构：Encoder-Decoder"></a>（一）结构：Encoder-Decoder</h3><p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231209133108.png" alt="image.png"></p>
<p>上图是最早提出的Seq2seq模型，用于文本翻译。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231209133246.png" alt="image.png"></p>
<p>改进后的seq2seq模型，即Transformer</p>
<h4 id="1-Encoder"><a href="#1-Encoder" class="headerlink" title="1. Encoder"></a>1. Encoder</h4><p>结构图如下：</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231209133352.png" alt="image.png"></p>
<p>在encoder内部，是self-attention结构。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231209133536.png" alt="image.png"></p>
<p>更具体地来看，一个encoder包含了多个block，每个block都是self-attention和全连接神经网络（Fully-connected netwok，FC）的叠加。</p>
<p>下面看看每个block内部的情况：</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231209134025.png" alt="image.png"></p>
<p>如上图，对于Transformer模型的self-attention层，其采用了一种residual network的机制，其输出等于self-attention的输出与输入的线性加和。此后经过一个layer norm层，输出经过归一化的向量。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231209134443.png" alt="image.png"></p>
<p>在self-attention层之后，还需要经过FC层的处理。和self-attention层类似，FC层处理后也需要经过residual network的加和处理和norm layer的归一化。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231209134649.png" alt="image.png"></p>
<h4 id="2-Decoder"><a href="#2-Decoder" class="headerlink" title="2. Decoder"></a>2. Decoder</h4><h5 id="2-1-autoregressive-decoder-AT"><a href="#2-1-autoregressive-decoder-AT" class="headerlink" title="2.1 autoregressive decoder (AT)"></a>2.1 autoregressive decoder (AT)</h5><p>最常用的decoder叫做autoregressive decoder</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231209232823.png" alt="image.png"></p>
<p>如上图，autoregressive的输入是一个特殊标识符“BEGIN”。（当然，autoregressive decoder也接受encoder的输入，但这一块内容将在后文中讲述）</p>
<p>当一个标识符输入时，autoregressive会输出一个长度为V的向量（其中V代表token词表的大小。以中文文本处理模型为例，token词表是所有汉字，那么V就是所有的汉字数量），这个输出向量的每个元素代表对应token出现在当前位置上的概率。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231209233212.png" alt="image.png"></p>
<p>autoregressive会依次产生输出向量，并且第一位的输出会作为第二位的输入进行处理，从而顺序地预测出下一个将要出现的词的概率（可以回想一下，chatGPT在对话的时候，输出内容是一句话一句话往外蹦出的，因为先输出的文字会再次作为输入以用于预测下一句话的输出）</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231209234236.png" alt="image.png"></p>
<p>上图为transformer的结构，其中左边为encoder部分，右边为decoder部分。如果我们将decoder部分中间的那个block（图中绿色阴影部分）删除，则decoder与encoder的结构完全一致。也就是说，decoder其实和encoder很像，除了decoder多了中间那一部分的结构。</p>
<p>另外注意一下，decoder的第一个block中，使用的是masked的多头注意力机制，这与encoder也不一样。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231209234436.png" alt="image.png"></p>
<p>所谓“masked”，其具体内容如下图所示，即预测当前位置的输出时，只使用当前位置之前的输入信息，而不考虑这个位置以后的信息。例如，预测 $b^2$ 时，只使用 $[a^1,a^2]$ 的信息；预测 $b^3$ 时，只使用 $[a^1,a^2,a^3]$ 的信息。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231209234529.png" alt="image.png"></p>
<p>这么做的原因很符合直觉。在transformer模型中，encoder要做的是处理所有输入，因此使用的是没有masked的self-attention；而decoder要做的是按顺序的输出信息，后输出的内容要建立在先前输出的内容的基础上（就像人类思考和说话那样），因此需要这样一个mask的机制。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231209235154.png" alt="image.png"></p>
<p>另一个问题是decoder如何决定停下。例如，decoder的前四个输出是“机器学习”，如果没有停止机制，则decoder可能将第四个输出“习”作为输入，然后预测出第五个输出“惯”（假定这个decoder在训练中学习过“习惯”这个词）。</p>
<p>为了防止这种情况产生，我们还需要加入一个特殊的符号“END”，用来表示停止输出，这样，在输出“机器学习”四个字以后，继续输出得到“END”符号，那么此时的模型就知道输出结束，从而停下。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231209235637.png" alt="image.png"></p>
<h5 id="2-2-non-autoregressive-decoder-NAT"><a href="#2-2-non-autoregressive-decoder-NAT" class="headerlink" title="2.2 non-autoregressive decoder (NAT)"></a>2.2 non-autoregressive decoder (NAT)</h5><p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231209235809.png" alt="image.png"></p>
<p>二者的区别如上图。autoregressive decoder只接受一个begin，后续的的输入都来自前一个输出，而non-autogressive decoder可以同时接受多个begin，并同时产生一整句话的输出。</p>
<ul>
<li>如何决定NAT解码器的输出长度？<ul>
<li>使用另一个预测器获得输出长度</li>
<li>或者输出一个很长的序列，然后忽略END之后的标记</li>
</ul>
</li>
<li>优点：NAT可以并行处理加速输出，输出长度可控</li>
<li>缺点：NAT的表现并不如AT，其中的问题有很多，例如multi-modality问题</li>
</ul>
<h3 id="（二）Encoder与Decoder的连接"><a href="#（二）Encoder与Decoder的连接" class="headerlink" title="（二）Encoder与Decoder的连接"></a>（二）Encoder与Decoder的连接</h3><p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231210000746.png" alt="image.png"></p>
<p>Encoder与Decoder的连接使用了一种叫做cross-attention的机制，如上图所示。这张图就是之前那张transformer结构图中，绿色阴影部分的block内部的结构。</p>
<ul>
<li>注意到，在上图中，encoder部分对输入进行处理，得到一组向量 $[a^1,a^2,a^3,…]$ ，这一组向量再通过数学上的处理得到 $K,V$ 矩阵（即上图的 $[k^1,k^2,k^3,…]$ 和 $[v^1,v^2,v^3,…]$  ）。</li>
<li>与此同时，decoder部分也会进行处理，从第一个token即“BEGIN”开始，通过数学上的处理得到 $Q$ 矩阵（即上图的 $[q,…]$）。</li>
<li>随后就是矩阵乘法的操作即 $\text{softmax}(\frac{Q\times K^T}{\sqrt{d_k}})V$ ，得到输出矩阵 $V$ （即上图中的 $[v,…]$ ）</li>
<li>输出还会经过全连接神经网络（FC）的处理，从而进入下一层。</li>
</ul>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231210001954.png" alt="image.png"></p>
<p>cross-attention机制最早在一项语音翻译模型的工作中被提出，此时还没有Transformer的架构。如上图，展示了cross-attention的attention score，其中横坐标是输入的音频信号的frame位置，纵坐标是输出的字母的位置，图中方块颜色的深浅代表了对应音频信号frame获得的注意力大小，颜色越深注意力越强。。</p>
<ul>
<li>输出从上到下进行，每生成一个字母，这个模型都会将当前字母和输入的音频信号进行处理，并计算最有可能出现在下一个位置上的字母</li>
<li>而图中的热图就代表了每输出一个字母时，音频信号中的哪一部分获得了最大的注意。</li>
<li>这就是为什么随着输出的进行，注意力最集中的位置也在随音频frame的进行而向右移动（但是这种移动不是完全向右不带回头的）</li>
</ul>
<h2 id="三、Transformer的训练"><a href="#三、Transformer的训练" class="headerlink" title="三、Transformer的训练"></a>三、Transformer的训练</h2><h3 id="（一）输出结果度量"><a href="#（一）输出结果度量" class="headerlink" title="（一）输出结果度量"></a>（一）输出结果度量</h3><p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231210003140.png" alt="image.png"></p>
<p>transformer使用交叉熵（cross-entropy）对输出结果进行度量，如上图所示，所谓交叉熵度量的是模型在一个位置的输出与这个位置上的真实输出（ground-truth）之间的差异性。训练目标是最小化交叉熵。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231210003505.png" alt="image.png"></p>
<p>对于每个位置上的输出，都会计算一次交叉熵。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231210003545.png" alt="image.png"></p>
<p>在训练过程中还使用了一种策略，叫做“teacher forcing”，就是在训练时，不论上一个位置上的实际输出是什么，在预测下一个位置上的输出时都使用ground truth的字符作为输入。</p>
<h3 id="（二）扩展知识点"><a href="#（二）扩展知识点" class="headerlink" title="（二）扩展知识点"></a>（二）扩展知识点</h3><p><strong>复制机制（copy-mechanism）</strong>：模型的输出不一定需要自己生成，也可以直接从输入的内容中复制一小部分。如下图，在聊天机器人任务中，输出内容的部分词汇来自输入的情况很常见；此外，在文章摘要任务中，输出内容来自输入的文章的主旨段落，因此也需要这种机制。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231210003903.png" alt="image.png"></p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231210004139.png" alt="image.png"></p>
<p>想要了解更多，可以查看上述论文。</p>
<p><strong>引导学习（guided attention）</strong> ：硬train一发可能出问题，例如模型忽略了输入中的一些文字，导致输出内容不全（例如文本翻译中一些句子被忽略；语音合成中部分文字被忽略，如下图）。一种方法是通过人工的方法，告诉机器必须采用我们所指定的顺序和方式处理输入内容，从而保证所有的输入都会被用到。一些关键词：Monotonic Attention, Location-aware attention</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231210005034.png" alt="image.png"></p>
<p><strong>集束搜索（Beam Search）</strong> ：如下图，decoder在产生每一步的输出时，会采用一种贪心算法选择当前最有可能的那个输出（红色路径）。然而，全局最优的输出可能是通过绿色的那条搜索路径获得的（但绿色路径在某些位置上不是局部最优）。要想获得全局最优，可以使用集束搜索的策略。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231210005433.png" alt="image.png"></p>
<p>集束搜索也不一定在所有时候都好。因为这种策略类似于在模型中引入了一些随机性，这种随机性并不一定是好的。当进行语音识别任务时，当然是越精准越好，此时不应该有随机性的成分在里面；而在进行文本续写、文章创作、语音合成时，引入一定的随机性反而会使生成的结果富含创造性。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231210005808.png" alt="image.png"></p>
<p>扩展：对输出结果的衡量标准能否进行优化？</p>
<ul>
<li>如下图，左边是使用交叉熵衡量输出结果的准确性，相当于每个词各自计算相关性，然而这样有时候并不太好。</li>
<li>另一种方法是将输出的整个句子和ground-truth进行相关性的比较，如右图所示，可以使用一种叫做BLEU score的方法进行。</li>
<li>然而后者的计算量很大，模型也更复杂，所以不是很推荐</li>
<li>如果真的要使用BLEU score，或许可以配合上reinforcement learning的策略，“硬train一发”，就可以得到很好的结果</li>
</ul>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231210010238.png" alt="image.png"></p>
<p><strong>计划采样（Scheduled sampling）</strong>： 在训练过程中引入噪音（例如，随机替换输入中的一些字符），以增强模型的稳健性。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231210010740.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>Attention机制</tag>
        <tag>机器学习</tag>
        <tag>Transformer</tag>
      </tags>
  </entry>
  <entry>
    <title>Attention机制与self-attention详解（一）——基础知识</title>
    <url>/2023/12/03/attention_architecture_1/</url>
    <content><![CDATA[<p>时隔半年，再次复习一下attention机制，并学习一下什么是self-attention。</p>
<span id="more"></span>

<blockquote>
<p>参考： <a href="https://www.bilibili.com/video/BV1v3411r78R">https://www.bilibili.com/video/BV1v3411r78R</a></p>
</blockquote>
<h2 id="一、attention机制"><a href="#一、attention机制" class="headerlink" title="一、attention机制"></a>一、attention机制</h2><h3 id="（一）attention要解决的问题"><a href="#（一）attention要解决的问题" class="headerlink" title="（一）attention要解决的问题"></a>（一）attention要解决的问题</h3><ul>
<li>当输入是一个可变长度的sequence时（就是说，输入一组向量vector，但是向量总数不确定），传统的神经网络适应能力不佳<ul>
<li>可变长度的输入示例：文本序列、音频序列、图片<ul>
<li>对于文本序列输入，需要一步预处理，将文本中的每个单词用向量进行编码<ul>
<li>一种表示方法是one-hot encoding，但会导致向量维度太高，并且无法反映词汇之间的关系</li>
<li>另一种方法是word embedding</li>
</ul>
</li>
<li>音频序列一般会按帧长度将序列分割成一段一段的帧，每一帧转化为一个向量</li>
</ul>
</li>
</ul>
</li>
<li>输出任务：<ul>
<li>1、each vector has a label，每个向量预测一个标签。例如词性标注（每个单词都输出一个词性的标签）、语音识别<ul>
<li><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231126183733.png" alt="image.png"></li>
</ul>
</li>
<li>2、the whole sequence has one label，整条序列预测一个标签。例如文本情感标注，输入一段话（由若干单词组成），输出一个情感类别的符号。<ul>
<li><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231126183920.png" alt="image.png"></li>
</ul>
</li>
<li>3、输出的标签个数由模型自己决定，即seq2seq任务，例如翻译任务（输入的向量数量和输出的标签数量并不存在一对一的关系）<ul>
<li><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231126184016.png" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="（二）self-attention的结构"><a href="#（二）self-attention的结构" class="headerlink" title="（二）self-attention的结构"></a>（二）self-attention的结构</h3><ul>
<li>sequence labeling问题（上述输出任务1）<ul>
<li>一种方法是用fully-connected network（FC network），即全连接神经网络</li>
<li><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231126184355.png" alt="image.png"></li>
<li>但是输入的文本是可变长度的，如果FC network要想考虑全部的输入，需要开一个很大的window，但这会导致模型过于庞大</li>
<li>另一种解决方法是使用self-attention的结构</li>
<li><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231126184524.png" alt="image.png"></li>
<li>在上图的模型中，self-attention用于处理全部的输入（即处理上下文信息），FC层用于专注于处理某个位置的信息。</li>
<li>self-attention层也可以叠加</li>
</ul>
</li>
<li>self-attention层内的结构<ul>
<li><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231126185214.png" alt="image.png"></li>
<li>输入元素之间互相计算相关性得到输出</li>
</ul>
</li>
<li>self-attention的计算方法：向量点积<ul>
<li><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231126185349.png" alt="image.png"></li>
<li>主要以左图为主；右图的加性模型用得少。</li>
<li>计算方法：首先计算q和k的点积 <img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231126191354.png" alt="image.png"></li>
<li>然后计算softmax。这一步得到的就是所谓的注意力分数（attention score）  <img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231126191450.png" alt="image.png"></li>
<li>最后和v做叉积 <img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231126191639.png" alt="image.png"></li>
<li>如上图。我们要计算输入向量 $a^1$ 的输出 $b^1$ ，首先对于输入的向量序列$[a^1,a^2,a^3,a^4]$ 分别计算 $K,\ Q,\ V$ 三个矩阵，然后将输入向量 $a^1$ 的 $q^1$ 与 $[k^1,k^2,k^3,k^4]$ 分别做点乘，点乘结果 $[\alpha’_{1,1},\alpha’_{1,2},\alpha’_{1,3},\alpha’_{1,4}]$ 再与 $[v^1,v^2,v^3,v^4]$ 做叉乘，之后做softmax并相加，即可得到 $b^1$  。同理， $[b^2,b^3,b^4]$ 也可以通过类似的方法依次计算。<ul>
<li>三个矩阵： $K=[k^1,k^2,k^3,k^4],\ Q=[q^1,q^2,q^3,q^4],\ V=[v^1,v^2,v^3,v^4]$ </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="（三）self-attention计算方法的矩阵表示："><a href="#（三）self-attention计算方法的矩阵表示：" class="headerlink" title="（三）self-attention计算方法的矩阵表示："></a>（三）self-attention计算方法的矩阵表示：</h3><p>我们以一个长度为4的输入序列为例。用矩阵 $I=[a^1,a^2,a^3,a^4]$ 代表这个输入序列，其中 $a^i$ 向量代表序列中第 $i$ 个元素。矩阵 $I$ 的列数为4，代表输入序列中的4个元素；矩阵的行数在这里不重要，所以不做假设。</p>
<h4 id="1-将输入矩阵-I-映射为-Q-K-V-三个矩阵"><a href="#1-将输入矩阵-I-映射为-Q-K-V-三个矩阵" class="headerlink" title="1. 将输入矩阵 $I$ 映射为 $Q,\ K,\ V$ 三个矩阵"></a>1. 将输入矩阵 $I$ 映射为 $Q,\ K,\ V$ 三个矩阵</h4><p>$$<br>\begin{aligned}<br>q^i=W^qa^i \\<br>k^i=W^ka^i \\<br>v^i=W^va^i \\<br>\end{aligned}<br>$$</p>
<p>其中， $W^q,\ W^k,\ W^v$ 都是可学习的参数</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231126195112.png" alt="image.png"></p>
<h4 id="2-Q-K-V-三个矩阵的处理"><a href="#2-Q-K-V-三个矩阵的处理" class="headerlink" title="2. $Q,\ K,\ V$ 三个矩阵的处理"></a>2. $Q,\ K,\ V$ 三个矩阵的处理</h4><p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231126195509.png" alt="image.png"></p>
<p>$q^1$ 的处理如上图，将其分别与 $k^1,k^2,k^3,k^4$ 做点乘，得到 $\alpha_{1,1},\alpha_{1,2},\alpha_{1,3},\alpha_{1,4}$ 。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231126195612.png" alt="image.png"></p>
<p>对整个输入矩阵$Q$ ， 即 $[q^1,q^2,q^3,q^4]$ 来说，其处理则如上图所示，这个过程可以概括为</p>
<p>$$<br>A=K^TQ<br>$$</p>
<p>其中</p>
<p>$$<br>A=\left[<br>\begin{aligned}<br>&amp; \alpha_{1,1},\ \alpha_{2,1},\ \alpha_{3,1},\ \alpha_{4,1} \\<br>&amp; \alpha_{1,2},\ \alpha_{2,2},\ \alpha_{3,2},\ \alpha_{4,2} \\<br>&amp; \alpha_{1,3},\ \alpha_{2,3},\ \alpha_{3,3},\ \alpha_{4,3} \\<br>&amp; \alpha_{1,4},\ \alpha_{2,4},\ \alpha_{3,4},\ \alpha_{4,4} \\<br>\end{aligned}<br>\right]<br>$$</p>
<p>另外，矩阵 $A$ 在进行下一步处理前，还需要经过softmax的处理</p>
<p>$$<br>A’=\text{softmax}(A)<br>$$</p>
<p>这一步得到的矩阵 $A’$ 是所谓的注意力分数（attention score），代表了组成输入矩阵的不同向量之间的匹配度。</p>
<h4 id="3-输出向量的获得"><a href="#3-输出向量的获得" class="headerlink" title="3. 输出向量的获得"></a>3. 输出向量的获得</h4><p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231126195856.png" alt="image.png"></p>
<p>如上图（纠正一处错误，上图中 $\hat\alpha_{1,1}$ 应该改为 $\alpha’_{1,1}$ ，另外3个符号同理），即self-attention的输出为</p>
<p>$$<br>O=VA’<br>$$</p>
<p>其中 $O=[b^1,b^2,b^3,b^4]$ 。</p>
<p>注意，self-attention的输出是一个向量，这个向量的每一个元素代表输入矩阵中的一列向量。（例如， $b^1$ 元素代表输入矩阵中 $a^1$ 这个向量的输出）</p>
<p>总结一下，self-attention的操作如下：</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231126200246.png" alt="image.png"></p>
<p>$$<br>\begin{aligned}<br>Q&amp;=W^qI \\<br>K&amp;=W^kI \\<br>V&amp;=W^vI \\<br>O&amp;=V\times \text{softmax}(K^TQ)<br>\end{aligned}<br>$$</p>
<p>$I$ 代表输入矩阵，$O$ 代表输出向量。</p>
<p>需要学习的参数只有三个： $W^q,\ W^k,\ W^v$ 。</p>
<h3 id="（四）多头注意力机制（multi-head-self-attention）"><a href="#（四）多头注意力机制（multi-head-self-attention）" class="headerlink" title="（四）多头注意力机制（multi-head self-attention）"></a>（四）多头注意力机制（multi-head self-attention）</h3><p>当我们想要计算输入序列中多种不同的自相关性时，多头注意力机制非常有用。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231126201411.png" alt="image.png"></p>
<p>例如上图，输入序列经过了两个注意力头（attention head）的处理，对于 $a^i$ 这个位置的输入，可以得到两个输出 $[b^{i,1},b^{i,2}]^T$  。这个输出还可以经过全连接层（FC layer）或其他层进一步处理。</p>
<h3 id="（五）其他变种"><a href="#（五）其他变种" class="headerlink" title="（五）其他变种"></a>（五）其他变种</h3><h4 id="1-位置编码（position-encoding）"><a href="#1-位置编码（position-encoding）" class="headerlink" title="1. 位置编码（position encoding）"></a>1. 位置编码（position encoding）</h4><p>原生self-attention并不考虑位置信息。然而，在某些任务中，输入元素的位置可能携带了重要信息（例如，在英文词性标注任务中，动词不太可能出现在句首）。</p>
<p>可以使用一些方法将位置信息编码进去，如下图，第 $i$ 个元素的输入等于 $e^i+a^i$ ，其中 $e^i$ 是位置编码。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231126201800.png" alt="image.png"></p>
<p>但是位置编码的方法还有很大的研究空间（例如可以使用sin函数，可以使用另一个模型学习出来，也可以用RNN等），下面展示了研究论文中报导的一些位置编码的方法。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231126202006.png" alt="image.png"></p>
<h4 id="2-截断的自注意力（Truncated-Self-attention）"><a href="#2-截断的自注意力（Truncated-Self-attention）" class="headerlink" title="2. 截断的自注意力（Truncated Self-attention）"></a>2. 截断的自注意力（Truncated Self-attention）</h4><p>在语音识别任务中，输入的音频信号按一定长度的帧进行分割，得到的输入序列长度 $L$ 可能会是一个很大的数字，这意味着做self-attention时需要进行 $L\times L$ 次点乘操作，其计算量过于巨大。Truncated Self-attention则可以解决这个问题。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231126202456.png" alt="image.png"></p>
<p>如上图，在进行Truncated Self-attention时，我们只计算一段范围内的元素的attention。具体看多大范围的元素，可以人为预设。</p>
<h4 id="3-用于图片的自注意力机制"><a href="#3-用于图片的自注意力机制" class="headerlink" title="3. 用于图片的自注意力机制"></a>3. 用于图片的自注意力机制</h4><p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231126202642.png" alt="image.png"></p>
<p>我们同样可以可以将图片看作vector set（如上图），并对每个像素（即每个vector）进行self-attention处理。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231126202713.png" alt="image.png"></p>
<p>上图是已发表的一种用于图像的attention。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231126202900.png" alt="image.png"></p>
<p>我们可以对比一下self-attention和卷积神经网络（CNN）。在处理一个像素时，self-attention考虑的是这个像素与整张图片的关系，而CNN考虑的则是这个像素与卷积核扫过的一小片区域中的像素的关系。可以理解为，CNN是简化的self-attention（或者说，是一种特例），而self-attention是更复杂的CNN。</p>
<p><a href="https://arxiv.org/pdf/2010.11929.pdf">An Image is Worth 16x16 Words: Transformers for Image Recognition at Scale</a> ：Transformer在图像识别中的应用，并且作者发现训练集越大，Transformer表现越好</p>
<h4 id="4-self-attention与循环神经网络（RNN）的对比"><a href="#4-self-attention与循环神经网络（RNN）的对比" class="headerlink" title="4. self-attention与循环神经网络（RNN）的对比"></a>4. self-attention与循环神经网络（RNN）的对比</h4><p>self-attention与循环神经网络（RNN）都可以用于处理序列数据，但是RNN只能按序列顺序串行处理，依次处理输入数据；而self-attention则可以并行处理。</p>
<p>此外，RNN存在长时程遗忘的问题（在处理序列的最后一个元素时，来自第一个元素的信息有很高的概率会丢失），而self-attention不存在长时程遗忘，在处理任何一个位置的元素时，来自输入序列中的每个元素对于它来说都是一视同仁的。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231126203856.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>Attention机制</tag>
        <tag>机器学习</tag>
        <tag>self-attention</tag>
      </tags>
  </entry>
  <entry>
    <title>6月下旬生活记录</title>
    <url>/2023/07/02/diary-20230702-modified/</url>
    <content><![CDATA[<p>流水账。</p>
<span id="more"></span>

<p>6月16日考细胞生物学，考前一个星期开始复习，考试前两天专门把往年题做了一遍。考完发现有几题写错了，心态有点崩。</p>
<p>6月19日考生物统计学，开卷考试，问题不是很大。 <del>考完摆烂好几天</del></p>
<p>6月22日-24日端午三天假，在宿舍和实验室宅了两天半。第一天天晴，和新来的实习生去黄埔江边转了转，听师妹说了不少本科的经历。后面两天都在下雨，没怎么动弹；当然学习进度有点缓慢，这两天光顾着刷知乎和看网剧，没怎么干正事。看完一部网剧，感慨不少。</p>
<p>端午节后写完遗传与进化结课论文，6月27日-28日把遗传与进化考完了。6月28日下午生化所办了草坪音乐节，在实验室楼上听了全程，效果还行，有几首歌有点跑调。</p>
<p>7月1日去看了话剧《暗恋桃花源》，研究生会办的，请来了上科大的学生社团来演。话剧很好看，情节发人深省（但是也有不少搞笑之处），演职人员都辛苦了。</p>
<p>今天晚上晴转雨，晚饭那会儿下得特别大。</p>
<p>以及，就在周五，所里的昙花开了，甚是好看。</p>
<p>以上。</p>
]]></content>
      <categories>
        <category>杂思</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>html 打印换页(转载)</title>
    <url>/2023/02/05/html-%E6%89%93%E5%8D%B0%E6%8D%A2%E9%A1%B5%E8%BD%AC%E8%BD%BD/</url>
    <content><![CDATA[<p>打印 HTML网页强制换页的方式</p>
 <span id="more"></span>

<blockquote>
<p>wyf1022<br>于 2008-09-07 23:27:00 发布 9386<br>文章标签： html css div ie</p>
</blockquote>
<p>打印 HTML网页强制换页是一件很令人困惑的事，要达到这个功能其实可以通过 CSS 的 Pagebreak 来实现。</p>
<p>强制分页大概只有两种CSS会被用到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; page-break-after: always; /*在标签后换页*/ &#125;</span><br><span class="line">&#123; page-break-before: always; /*在标签前换页*/ &#125; </span><br></pre></td></tr></table></figure>

<p>此二者中，最常用的大概就是page-break-after了，就是在指定的标签后强制换页，下面举一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div STYLE=&quot; page-break-after: always;&quot;&gt; 第一页 &lt;/div&gt;</span><br><span class="line">第二页</span><br></pre></td></tr></table></figure>

<p>在浏览器中点击打印，给出的预览界面中这两个标签确实被分成了两页。</p>
<p>其他相关CSS熟悉可以参考下面的网站：</p>
<p><a href="https://www.w3schools.com/cssref/pr_print_pageba.php">https://www.w3schools.com/cssref/pr_print_pageba.php</a></p>
<p><a href="https://www.w3schools.com/cssref/pr_print_pagebb.php">https://www.w3schools.com/cssref/pr_print_pagebb.php</a></p>
<p><a href="https://www.w3schools.com/cssref/pr_print_pagebi.php">https://www.w3schools.com/cssref/pr_print_pagebi.php</a></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>又是一个小世界</title>
    <url>/2022/04/27/hello-world/</url>
    <content><![CDATA[<p>（点开来阅读！）</p>
<span id="more"></span>

<p>曾几何时，注册过一个微信公众号，想着在上面发一些东西。</p>
<p>太久没打理，已经长满青草了。</p>
<p>又想试试Hexo+GitHub pages搞个人博客，又嫌git太麻烦。</p>
<p>想到有个wordpress可以用，正好有个服务器，于是就迁移过来了。</p>
<p>会在上面不定期发一些想法，记录工作和生活。</p>
<p>服务器租了一年，等一年以后这个网站可能不复存在了，也可能以另一种形式在另一个地方重生。谁知道呢？</p>
<p>这一年来学到的最重要一点就是生活不会按套路出牌。所以啥事也别太早下结论。</p>
<p>毕竟我还挺喜欢这种不确定的生活的哈哈哈哈哈</p>
<hr>
<p>2023-4-23 update</p>
<p>一年过去了</p>
<p>之前租的服务器到期了，综合考虑各种因素后决定不续期。</p>
<p>因此，现在这些帖子全部转移到了hexo的系统上。</p>
<p>博客依然还会不定期更新</p>
<p>(¬‿¬)</p>
<p>—— written by WarrenZ</p>
<hr>
<hr>
<blockquote>
<p>旧评论系统备份：</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cyclin(2022-04-27 22:58:52) : </span><br><span class="line">	你好，世界</span><br><span class="line"></span><br><span class="line">&gt; Eamon(2022-05-20 02:32:27)  : </span><br><span class="line">&gt;	踩踩</span><br><span class="line">&gt;				</span><br><span class="line">&gt; cyclin(2022-05-25 21:47:50) : </span><br><span class="line">&gt;	樊总呜呜呜，刚刚才看到回复</span><br></pre></td></tr></table></figure>













]]></content>
      <categories>
        <category>杂思</category>
      </categories>
      <tags>
        <tag>你好世界</tag>
      </tags>
  </entry>
  <entry>
    <title>ERROR: configuration failed for package ‘gmp’报错的解决方案</title>
    <url>/2022/06/10/error-configuration-failed-for-package-gmp%E6%8A%A5%E9%94%99%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>R包安装时的错误</p>
<span id="more"></span>

<blockquote>
<p>转载自： <a href="https://www.cnblogs.com/chenwenyan/p/13262960.html">https://www.cnblogs.com/chenwenyan/p/13262960.html</a></p>
</blockquote>
<p>安装R包时发生如下报错<code>ERROR: configuration failed for package ‘gmp’</code></p>
<p>用conda安装<code>conda install -c conda-forge r-gmp</code>即可解决这个报错。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>一些线性代数知识点整理</title>
    <url>/2023/08/31/linalg-knowledge-Collection/</url>
    <content><![CDATA[<p>推导线性回归公式时遇到了线性代数方面的问题，于是查点资料补补课。</p>
<span id="more"></span>

<h1 id="一些线性代数知识点整理"><a href="#一些线性代数知识点整理" class="headerlink" title="一些线性代数知识点整理"></a>一些线性代数知识点整理</h1><h2 id="1-共轭矩阵"><a href="#1-共轭矩阵" class="headerlink" title="1. 共轭矩阵"></a>1. 共轭矩阵</h2><h3 id="1-1-共轭复数"><a href="#1-1-共轭复数" class="headerlink" title="1.1 共轭复数"></a>1.1 共轭复数</h3><p>实数部分相同而虚数部分互为相反数的两个复数。 </p>
<p>例如 $x+iy$ 与 $x-iy$ 共轭（其中 $x,y\in R,i=\sqrt{-1}$ ）。</p>
<h2 id="1-2-共轭转置矩阵"><a href="#1-2-共轭转置矩阵" class="headerlink" title="1.2. 共轭转置矩阵"></a>1.2. 共轭转置矩阵</h2><p>把矩阵转置后，再把每一个数换成它的共轭复数，就得到了共轭转置矩阵。</p>
<p>讨论共轭矩阵的前提是被讨论的矩阵 $\mathbf{A}$ 为复矩阵。</p>
<p>当 </p>
<p>$$<br>\begin{aligned}<br>\mathbf{A}&amp;=(a_{ij}) \in \mathbb{C}^{m \times n} \\<br>&amp;=\left[<br>    \begin{array}{}<br>    a_{11} &amp; a_{12} &amp; … &amp; a_{1n} \\<br>    a_{21} &amp; a_{22} &amp; … &amp; a_{2n} \\<br>    … &amp; … &amp; …&amp; … \\<br>    a_{m1} &amp; a_{m2} &amp; … &amp; a_{mn} \\<br>    \end{array}<br>\right]<br>\end{aligned}<br>$$ </p>
<p>为复矩阵时（也就是说 $a_{ij}\in \mathbb{C}$ ， $\mathbb{C}$ 为复数集）</p>
<p>$$<br>\begin{aligned}<br>\mathbf{A}^H&amp;=\overline{\mathbf{A}^T} \\<br>&amp;=(\overline{a_{ji}})\\<br>&amp;=\left[<br>    \begin{array}{}<br>    \overline{a_{11}} &amp; \overline{a_{21}} &amp; … &amp; \overline{a_{m1}} \\<br>    \overline{a_{12}} &amp; \overline{a_{22}} &amp; … &amp; \overline{a_{m2}} \\<br>    … &amp; … &amp; …&amp; … \\<br>    \overline{a_{1n}} &amp; \overline{a_{2n}} &amp; … &amp; \overline{a_{mn}} \\<br>    \end{array}<br>\right]<br>\end{aligned}<br>$$</p>
<p>为其共轭矩阵。其中</p>
<p>$$<br>a_{ij}=\overline{a_{ji}}<br>$$</p>
<p>为共轭算符。</p>
<p><span style="color:#f20;font-weight:bold">共轭转置的运算符为 $\mathbf{A}^H$ 。</span></p>
<h3 id="1-3-自共轭矩阵（Hermite阵）"><a href="#1-3-自共轭矩阵（Hermite阵）" class="headerlink" title="1.3 自共轭矩阵（Hermite阵）"></a>1.3 自共轭矩阵（Hermite阵）</h3><p>每一个第 $i$ 行第 $j$ 列的元素都与第 $j$ 行第 $i$ 列的元素的共轭相等的矩阵。</p>
<p>即</p>
<p>$$<br>\begin{aligned}<br>\mathbf{A}&amp;=(a_{ij}) \in \mathbb{C}^{n \times n} \\<br>&amp;=\left[<br>    \begin{array}{}<br>    a_{11} &amp; a_{12} &amp; … &amp; a_{1n} \\<br>    \overline{a_{12}} &amp; a_{22} &amp; … &amp; a_{2n} \\<br>    … &amp; … &amp; …&amp; … \\<br>    \overline{a_{1n}} &amp; \overline{a_{2n}} &amp; … &amp; a_{nn} \\<br>    \end{array}<br>\right]<br>\end{aligned}<br>$$</p>
<p>自共轭矩阵具有 $\mathbf{A}=\mathbf{A}^H$ 的性质。此外，自共轭矩阵的对角线元素必须是实数（因为其转置之后的位置是其自身）。</p>
<p>对于只包含实数元素的矩阵（实矩阵），如果它是对称阵，即所有元素关于主对角线对称，那么它也是自共轭矩阵（即，实对称阵是Hermite阵的特例）。</p>
<p>一个自共轭矩阵的例子：</p>
<p>$$<br>\left[<br>    \begin{array}{}<br>    3   &amp; 2+i \\<br>    2-i &amp; 1   \\<br>    \end{array}<br>\right]<br>$$</p>
<p>其中， $2+i$ 和 $2-i$ 共轭。</p>
<h2 id="2-酉矩阵（幺正矩阵，Unitary-Matrix）及其与单位矩阵的关系"><a href="#2-酉矩阵（幺正矩阵，Unitary-Matrix）及其与单位矩阵的关系" class="headerlink" title="2. 酉矩阵（幺正矩阵，Unitary Matrix）及其与单位矩阵的关系"></a>2. 酉矩阵（幺正矩阵，Unitary Matrix）及其与单位矩阵的关系</h2><blockquote>
<p><strong>unitary</strong> <br>adj.集中的；统一的；中央集权制的；单一的；<br>【网络】一元的；单式的；单元的</p>
</blockquote>
<p>“酉矩阵”这个翻译不太好，一眼不明觉厉，完全看不出它是什么意思。从英文名称Unitary Matrix上直译，大概要被叫做单元矩阵或者统一矩阵。不过这很容易和单位矩阵（identity matrix）弄混。也许“幺正矩阵”这个词更合适一点吧。</p>
<h3 id="2-1-单位矩阵"><a href="#2-1-单位矩阵" class="headerlink" title="2.1 单位矩阵"></a>2.1 单位矩阵</h3><p>单位矩阵 $\mathbf{I}$ （有时用 $\mathbf{E}$ 表示） 是对角线全为1、其他位置全为0的方阵。例如：</p>
<p>$$<br>\left[<br>    \begin{array}{}<br>    1 &amp; 0 &amp; 0 \\<br>    0 &amp; 1 &amp; 0 \\<br>    0 &amp; 0 &amp; 1 \\<br>    \end{array}<br>\right]<br>$$</p>
<p>是一个大小为 $3\times 3$ 的单位阵。</p>
<h3 id="2-2-酉矩阵"><a href="#2-2-酉矩阵" class="headerlink" title="2.2 酉矩阵"></a>2.2 酉矩阵</h3><p>如果一个矩阵 $\mathbf{A}$ 满足以下条件：</p>
<p>$$<br>\mathbf{A}^H\mathbf{A}=\mathbf{A}\mathbf{A}^H=\mathbf{I}<br>$$</p>
<p>其中 $\mathbf{I}$ 为单位阵，则矩阵 $\mathbf{A}$ 为酉矩阵。</p>
<p>酉矩阵的性质：若 $\mathbf{A}$ 为酉矩阵，则下列描述成立</p>
<ul>
<li>(1) $\mathbf{A}^{-1}$=$\mathbf{A}^H$ </li>
<li>(2) $\mathbf{A}^{-1}$ 也是酉矩阵</li>
<li>(3) 酉矩阵的特征值都是模为1的复数，即分布在复平面的单位圆上，所以  $|det(\mathbf{A})|=1$ ，其中$det()$是矩阵的行列式求值函数。</li>
<li>(4) 矩阵 $\mathbf{A}$ 是酉矩阵的充分条件是矩阵 $\mathbf{A}$ 的 $n$ 个列向量是两两正交的单位向量。（单位向量是指模等于1的向量，向量模运算相当于求空间向量到坐标系原点的欧几里得距离）</li>
</ul>
<h2 id="3-逆矩阵和伪逆矩阵"><a href="#3-逆矩阵和伪逆矩阵" class="headerlink" title="3.逆矩阵和伪逆矩阵"></a>3.逆矩阵和伪逆矩阵</h2><h3 id="3-1-逆矩阵（inverse-matrix）"><a href="#3-1-逆矩阵（inverse-matrix）" class="headerlink" title="3.1 逆矩阵（inverse matrix）"></a>3.1 逆矩阵（inverse matrix）</h3><p>对于矩阵 $\mathbf{A}$ ，如果存在矩阵 $\mathbf{B}$ ，使得 $\mathbf{A}\mathbf{B}=\mathbf{B}\mathbf{A}=\mathbf{I}$ （其中 $\mathbf{I}$ 为与 $\mathbf{A},\ \mathbf{B}$ 维数相同的单位阵），则称 $\mathbf{A}$ 为可逆矩阵，且 $\mathbf{B}$ 是 $\mathbf{A}$ 的逆矩阵，记作 $\mathbf{B}=\mathbf{A}^{-1}$</p>
<p>不是所有矩阵都有逆矩阵。例如，奇异矩阵（行列式为0的方阵）以及非方阵都没有逆矩阵。</p>
<h3 id="3-2-伪逆矩阵（pseudo-inverse-matrix）"><a href="#3-2-伪逆矩阵（pseudo-inverse-matrix）" class="headerlink" title="3.2 伪逆矩阵（pseudo-inverse matrix）"></a>3.2 伪逆矩阵（pseudo-inverse matrix）</h3><p>没有逆矩阵的矩阵可以有伪逆矩阵。</p>
<p>满足 $\mathbf{A}^L\mathbf{A}=\mathbf{I}$ ，但不满足 $\mathbf{A}\mathbf{A}^L=\mathbf{I}$ 的矩阵 $\mathbf{A}^L$ 称为矩阵 $\mathbf{A}$ 的左逆矩阵。</p>
<p>满足 $\mathbf{A}\mathbf{A}^R=\mathbf{I}$ ，但不满足 $\mathbf{A}^R\mathbf{A}=\mathbf{I}$ 的矩阵 $\mathbf{A}^R$ 称为矩阵 $\mathbf{A}$ 的右逆矩阵。</p>
<p>仅当 $m\geq n$ 时，列满秩，矩阵 $\mathbf{A}_{m\times n}$ 有左逆矩阵，为 $(\mathbf{A}^T\mathbf{A})^{-1}\mathbf{A}^T$ （其中 $\mathbf{A}^T$ 为 $\mathbf{A}$ 的转置）。</p>
<p>仅当 $n\geq m$ 时，列满秩，矩阵 $\mathbf{A}_{m\times n}$ 有右逆矩阵，为 $\mathbf{A}^T(\mathbf{A}^T\mathbf{A})^{-1}$ 。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<ul>
<li><a href="https://baike.baidu.com/item/%E5%85%B1%E8%BD%AD%E7%9F%A9%E9%98%B5/0">https://baike.baidu.com/item/%E5%85%B1%E8%BD%AD%E7%9F%A9%E9%98%B5/0</a></li>
<li><a href="https://blog.csdn.net/babychrislee3/article/details/103681724">https://blog.csdn.net/babychrislee3/article/details/103681724</a></li>
<li><a href="https://blog.csdn.net/ms961516792/article/details/107591019">https://blog.csdn.net/ms961516792/article/details/107591019</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/386904316">https://zhuanlan.zhihu.com/p/386904316</a></li>
<li><a href="https://baike.baidu.com/item/%E5%B9%BA%E6%AD%A3%E7%9F%A9%E9%98%B5/1651000">https://baike.baidu.com/item/%E5%B9%BA%E6%AD%A3%E7%9F%A9%E9%98%B5/1651000</a></li>
<li>邱锡鹏.神经网络与机器学习.<a href="https://nndl.github.io/">https://nndl.github.io/</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>解决conda报错: `x86_64-conda_cos6-linux-gnu-cc: command not found`</title>
    <url>/2022/06/10/conda-rstudio-server%E9%94%99%E8%AF%AF-bin-sh-x86-64-conda-cos6-linux-gnu-cc-command-not-found/</url>
    <content><![CDATA[<p>如何解决conda - rstudio-server的这个报错？</p>
<span id="more"></span>

<h2 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h2><p>我在Windows subsystem for Linux下面安装了anaconda，并使用这个anaconda安装了R（顺便配置了一个conda env，叫做r420）。为了更方便的使用这个R，我又安装了R studio server，通过浏览器调用这个Linux版本的R。</p>
<p>最近在使用中，发现了一个问题：安装 R 包时，出现错误：<code>/bin/sh: x86_64-conda_cos6-linux-gnu-cc: command not found</code> ，这导致我没法安装新的软件包</p>
<h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><p>经过检查，如果我在shell中调用R安装R包，则不会出错。因此不是R自带的编译工具链的问题。</p>
<p>经过上网搜索，猜测可能是Rstudio server环境变量中没有包含R自带的编译工具链。</p>
<p>我的Rtools编译工具链的路径为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/home/cyclin/wsl/anaconda3/envs/r420/bin</span><br></pre></td></tr></table></figure>

<p>在Rstudio的控制台中查询Rstudio server的环境变量</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> system<span class="punctuation">(</span><span class="string">&#x27;echo $PATH&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">/</span>usr<span class="operator">/</span>local<span class="operator">/</span>sbin<span class="operator">:</span><span class="operator">/</span>usr<span class="operator">/</span>local<span class="operator">/</span>bin<span class="operator">:</span><span class="operator">/</span>usr<span class="operator">/</span>sbin<span class="operator">:</span><span class="operator">/</span>usr<span class="operator">/</span>bin<span class="operator">:</span><span class="operator">/</span>sbin<span class="operator">:</span><span class="operator">/</span>bin<span class="operator">:</span><span class="operator">/</span>usr<span class="operator">/</span>lib<span class="operator">/</span>rstudio<span class="operator">-</span>server<span class="operator">/</span>bin<span class="operator">/</span>postback</span><br></pre></td></tr></table></figure>

<p>可见，并没有包含Rtools编译工具链的路径。</p>
<p>这个环境变量应该是可以配置的。经过查询资料，发现Rstudio server有一个配置文件叫做/etc/rstudio/env-vars，这个配置文件应该是和环境变量有关的。因此我们修改一下这个文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># set virtual environment for Rstudio server.</span></span><br><span class="line">PATH=/home/cyclin/.local/bin:/home/cyclin/wsl/anaconda3/envs/r420/bin:/home/cyclin/wsl/anaconda3/condabin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br></pre></td></tr></table></figure>

<p>之后，重启Rstudio server的服务进程，在浏览器中重新打开Rstudio sever，在控制台中查询环境变量</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> system<span class="punctuation">(</span><span class="string">&#x27;echo $PATH&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">/</span>home<span class="operator">/</span>cyclin<span class="operator">/</span>.local<span class="operator">/</span>bin<span class="operator">:</span><span class="operator">/</span>home<span class="operator">/</span>cyclin<span class="operator">/</span>wsl<span class="operator">/</span>anaconda3<span class="operator">/</span>envs<span class="operator">/</span>r420<span class="operator">/</span>bin<span class="operator">:</span><span class="operator">/</span>home<span class="operator">/</span>cyclin<span class="operator">/</span>wsl<span class="operator">/</span>anaconda3<span class="operator">/</span>condabin<span class="operator">:</span><span class="operator">/</span>usr<span class="operator">/</span>local<span class="operator">/</span>sbin<span class="operator">:</span><span class="operator">/</span>usr<span class="operator">/</span>local<span class="operator">/</span>bin<span class="operator">:</span><span class="operator">/</span>usr<span class="operator">/</span>sbin<span class="operator">:</span><span class="operator">/</span>usr<span class="operator">/</span>bin<span class="operator">:</span><span class="operator">/</span>sbin<span class="operator">:</span><span class="operator">/</span>bin<span class="operator">:</span><span class="operator">/</span>usr<span class="operator">/</span>lib<span class="operator">/</span>rstudio<span class="operator">-</span>server<span class="operator">/</span>bin<span class="operator">/</span>postback</span><br></pre></td></tr></table></figure>

<p>现在已经有了Rtools编译工具链的路径。</p>
<p>经过测试，现在可以在Rstudio中成功编译安装软件包。问题解决。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>【复习资料】T/B细胞的适应性免疫</title>
    <url>/2023/11/10/immunity-TBcell/</url>
    <content><![CDATA[<p>本文为中科院上海分院Bio2000系列课程之《T/B细胞适应性免疫》的复习资料，整理于今年6月。</p>
<span id="more"></span>


<h2 id="零、免疫应答的概念"><a href="#零、免疫应答的概念" class="headerlink" title="零、免疫应答的概念"></a>零、免疫应答的概念</h2><p>指机体受抗原刺激后，体内抗原特异性淋巴细胞对抗原分子的识别、活化、增殖、分化，并表现出一定生物学效应的全过程</p>
<p>免疫应答的基本过程（三个要素）：</p>
<ol>
<li>识别抗原</li>
<li>活化增殖和分化阶段（其中T/B细胞活化需要双信号）</li>
<li>效应阶段</li>
</ol>
<table>
<thead>
<tr>
<th>识别阶段</th>
<th>活化增殖和分化</th>
<th>效应阶段</th>
</tr>
</thead>
<tbody><tr>
<td>抗原（antigen,Ag）与免疫细胞间的相互作用</td>
<td>免疫细胞间的相互作用</td>
<td>效应细胞和效应分子与靶细胞（或靶分子）间的相互作用</td>
</tr>
<tr>
<td>抗原的摄取、处理、加工、提呈、识别</td>
<td>膜受体交联、膜信号产生与传递、细胞活化增殖与分化、生物活性介质的合成与释放</td>
<td>效应细胞/分子对靶细胞/分子的排异作用、引起组织的损伤作用（炎症）、免疫应答调节</td>
</tr>
<tr>
<td>抗原→APC、T细胞、B细胞</td>
<td>T/B细胞增殖与分化、抗体产生、细胞因子产生、效应T细胞产生、记忆细胞产生（这是免疫记忆产生的条件）</td>
<td>抗体/效应T细胞的排异或排己：免疫保护（抗感染、抗肿瘤）、免疫病理（自身免疫、变态反应、移植排斥、移植物抗宿主反应）。<br/>免疫增强系统：补体、细胞因子、NK细胞、肥大细胞、Macrophage（MΦ）、粒细胞系红细胞、血小板</td>
</tr>
</tbody></table>
<h2 id="一、T细胞抗原识别和活化阶段"><a href="#一、T细胞抗原识别和活化阶段" class="headerlink" title="一、T细胞抗原识别和活化阶段"></a>一、T细胞抗原识别和活化阶段</h2><p><strong>★重点掌握：T细胞活化的双信号要求,包括signal 2的CD28,CTLA‐4,PD‐1的功能。</strong></p>
<h3 id="1-T细胞对抗原的识别"><a href="#1-T细胞对抗原的识别" class="headerlink" title="1. T细胞对抗原的识别"></a>1. T细胞对抗原的识别</h3><ul>
<li>APC与MHC<ul>
<li>三类APC：树突状细胞（DC）、MΦ、B细胞</li>
<li>MHC I 提呈CD8+T细胞（胞毒T细胞）</li>
<li>MHC II提呈CD4+T细胞（助T细胞）</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>项目</th>
<th>MHC I</th>
<th>MHC II</th>
</tr>
</thead>
<tbody><tr>
<td>抗原来源</td>
<td>内源性抗体</td>
<td>外源性抗体</td>
</tr>
<tr>
<td>加工抗原位置</td>
<td>蛋白酶体</td>
<td>溶酶体</td>
</tr>
<tr>
<td>加工抗原细胞</td>
<td>所有有核细胞</td>
<td>专职性APC</td>
</tr>
<tr>
<td>抗原与MHC发生结合的位置</td>
<td>内质网</td>
<td>溶酶体与胞内体</td>
</tr>
<tr>
<td>提呈对象</td>
<td>CD8+T细胞（CTL）</td>
<td>CD4+T细胞（Th）</td>
</tr>
</tbody></table>
<h3 id="2-T-B细胞双活化信号"><a href="#2-T-B细胞双活化信号" class="headerlink" title="2. T/B细胞双活化信号"></a>2. T/B细胞双活化信号</h3><p> </p>
<ul>
<li>T细胞活化的双信号要求<ul>
<li>（1）TCR信号：TCR-CD3，以及来自APC的MHC-antigen分子。</li>
<li>（2）共刺激分子：T细胞表面的CD28，以及APC表面的B7家族（CD80/86）信号等</li>
<li>此外还有其他信号：细胞因子信号（IL-2、IL-R……）、黏附分子（CD2、CD48、CD58……）。</li>
</ul>
</li>
<li>B细胞活化双信号：<ul>
<li>（1）BCR；CD19（CAR-T治疗血液肿瘤）；</li>
<li>（2）B7.1/B7.2、CD40、ICOS-L、PDL-1</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>T细胞表面分子</th>
<th>APC表面分子</th>
</tr>
</thead>
<tbody><tr>
<td>CD40</td>
<td>CD40L</td>
</tr>
<tr>
<td>CD4/CD8、CD3、TCR</td>
<td>MHC II/I-抗原肽</td>
</tr>
<tr>
<td>CD28</td>
<td>CD80/86</td>
</tr>
<tr>
<td>CD2</td>
<td>LFA-3</td>
</tr>
<tr>
<td>LFA-1</td>
<td>ICAM-1</td>
</tr>
</tbody></table>
<p>双信号上调了T细胞的IL-2的表达量以及IL-2受体的亲和力，使得T细胞进入细胞周期，进行多轮增殖和分化。</p>
<p>双信号决定了T细胞命运：</p>
<ul>
<li>（1）只有TCR信号，T细胞无反应或克隆无能（clonal anergy）</li>
<li>（2）TCR信号+共刺激分子（如T细胞表面CD28）：正常克隆扩增</li>
<li>（3）TCR信号+负调控分子（如T细胞表面CTLA-4）：细胞周期捕获（克隆扩增被抑制）</li>
<li> <strong>注意：</strong> CD28和CTLA-4都接受CD80/86信号，具体走向克隆扩增还是克隆抑制取决于T细胞表达哪一种分子<ul>
<li> CD28：是CD80（B7.1）和CD86（B7.2）的受体</li>
<li> CTLA-4：在静息T细胞中低表达，在激活的T细胞中表达增强。是细胞免疫的负调控分子。</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/654f9028c458853aefaabcc2.jpg" alt="CD28与CTLA-4分子的作用机制（医学免疫学.第三版,p201）"></p>
<p>负调控受体：PD-1与CTLA-4（二者都在T细胞上表达，与之对应的APC细胞表面配体分别是B7和PD-L2）。</p>
<ul>
<li>阻断PD-L1与PD-1的相互作用，可以维持T细胞杀伤能力，从而消灭肿瘤。</li>
</ul>
<h2 id="二、T细胞增殖与分化"><a href="#二、T细胞增殖与分化" class="headerlink" title="二、T细胞增殖与分化"></a>二、T细胞增殖与分化</h2><p><strong>★重点：掌握T细胞亚群的分化条件，各亚群的特征性细胞因子和功能。</strong></p>
<h3 id="1、T细胞增殖"><a href="#1、T细胞增殖" class="headerlink" title="1、T细胞增殖"></a>1、T细胞增殖</h3><p>   <br>双信号活化上调了IL-2表达量以及IL-2受体亲和力，T细胞进入细胞周期。</p>
<ul>
<li>一些分化为效应细胞，一些分化为记忆细胞。</li>
</ul>
<p> <br>IL-2R信号激活PI3K并活化NF-κB；IL-2还活化Lck。蛋白酪氨酸激酶JAK1/3也一并活化。<br>   <br>IL-2还刺激有丝分裂原（Mitogen）激活的T淋巴细胞中的ERK信号和/或p38</p>
<p>免疫突触（Immunological synapse）：APC和淋巴细胞之间的界面。</p>
<ul>
<li>c‐SMAC（中心-SMAC）由蛋白激酶c（PKC）、CD4、CD8、CD28、Lck和Fyn组成。</li>
<li>p‐SMAC（外周‐SMAC）含有淋巴细胞功能相关抗原-1（LFA‐1）和细胞骨架蛋白talin。</li>
<li>d‐SMAC（远端‐SMAC）富含CD43和CD45分子。</li>
</ul>
<p>   <br>整合素（Integrins，主要是LFA-1分子）也调控T细胞活化与增殖</p>
<ul>
<li>整合素参与免疫突触的形成，增强T细胞活化。</li>
<li>Inside-out信号通路促进整合素活化和T细胞活化增殖。<ul>
<li>LFA-1表达在T细胞上，其配体为APC上的ICAM分子。</li>
</ul>
</li>
<li>整合素活化模型：Affinity &amp; Avidity<ul>
<li>（1）LFA-1构象变化：亲和力变化（affinity changes）</li>
<li>（2）LFA-1聚类：亲合力变化（avidity changes）</li>
</ul>
</li>
</ul>
<h3 id="2、CD4-T细胞亚群分化"><a href="#2、CD4-T细胞亚群分化" class="headerlink" title="2、CD4+T细胞亚群分化"></a>2、CD4+T细胞亚群分化</h3><table>
<thead>
<tr>
<th>细胞</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Th1</td>
<td>IFN-γ(增强T,NK和巨噬细胞杀伤，增强MHC表达，促进T细胞分化), <br/>IL-2 (促进T细胞增殖）</td>
</tr>
<tr>
<td>Th2</td>
<td>IL-4和IL-13 (Th2分化、诱导B细胞产生IgE, 上调内皮细胞表达VCAM-1和MCP-1),<br/> IL-5(促进嗜酸性粒细胞分化，杀伤寄生虫)</td>
</tr>
<tr>
<td>Treg</td>
<td>抑炎型细胞因子TGF-β(抑制T和巨噬细胞和B细胞的效应功能、抑制T细胞增殖),<br/>IL-10（抑制细胞因子生成、Th1功能、巨噬细胞呈递抗原、B细胞产生抗体）</td>
</tr>
<tr>
<td>Th17</td>
<td>IL-17(招募中性粒细胞,促细胞增殖,促炎症因子产生, 抑制肿瘤),<br/> IL-23(促T细胞增殖,APC产生IFN-γ和IL-12,DC 共刺激功能抑制肿瘤)</td>
</tr>
<tr>
<td>Tfh</td>
<td>Follicular helper T cells，辅助B细胞增殖和产生抗体，参与体液免疫，特别是针对感染疾病、自身免疫病</td>
</tr>
</tbody></table>
<p>CD4+T细胞分化为不同亚群时需要不同转录因子</p>
<ul>
<li>Th1：STAT1、STAT4、T-bet</li>
<li>Th2：STAT6、GATA-3</li>
<li>Th17：RORγt、STAT3</li>
</ul>
<p>CD4+T细胞在自身免疫病中的作用</p>
<ul>
<li>多发性硬化症（Multiple Sclerosis，MS）：自身反应性淋巴细胞引起神经元损伤。</li>
<li>类风湿性关节炎（Rheumatoid Arthritis，RA）：CD4+T细胞分化为Th1和Th17，分泌IFN-γ、IL-17等细胞因子。<ul>
<li>炎性细胞因子（TNF-α、IL-6、IL-1β等）过度释放，破坏骨和软骨。</li>
</ul>
</li>
<li>炎症性肠炎（IBD）：CD4+T细胞分化为Th1和Th17，分泌IFN-γ、IL-17等细胞因子。<ul>
<li>TGF-β分泌型Th3细胞、IL-10分泌型Tr1细胞和Treg细胞可以降低IBD发生。</li>
</ul>
</li>
</ul>
<h3 id="3、CD8-T细胞亚群分化"><a href="#3、CD8-T细胞亚群分化" class="headerlink" title="3、CD8+T细胞亚群分化"></a>3、CD8+T细胞亚群分化</h3><p>（PPT中无相关内容）</p>
<h2 id="三、T细胞的免疫效应"><a href="#三、T细胞的免疫效应" class="headerlink" title="三、T细胞的免疫效应"></a>三、T细胞的免疫效应</h2><p><strong>★重点：CD8+T细胞介导的免疫效应功能,杀伤的机制。</strong></p>
<h3 id="1、细胞免疫应答的基本过程"><a href="#1、细胞免疫应答的基本过程" class="headerlink" title="1、细胞免疫应答的基本过程"></a>1、细胞免疫应答的基本过程</h3><table>
<thead>
<tr>
<th>阶段</th>
<th>CD4+T cell</th>
<th>CD8+T cell</th>
</tr>
</thead>
<tbody><tr>
<td>识别阶段</td>
<td>识别抗原（APC细胞，MHC II）</td>
<td>识别抗原（任何表达MHC I的细胞）</td>
</tr>
<tr>
<td>活化、增殖、分化</td>
<td>IL-2和IL-2R的信号促进增殖</td>
<td>双信号+各种细胞因子</td>
</tr>
<tr>
<td>效应阶段</td>
<td>效应Th1释放CKs介导DTH（迟发型超敏反应）</td>
<td>效应CTL杀伤靶细胞</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>项目</th>
<th>naive T cell</th>
<th>效应T细胞</th>
<th>记忆T细胞</th>
</tr>
</thead>
<tbody><tr>
<td>迁移</td>
<td>外周淋巴组织</td>
<td>炎症组织</td>
<td>炎症组织、黏膜组织</td>
</tr>
<tr>
<td>对特定抗原的响应</td>
<td>极低</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>效应</td>
<td>无</td>
<td>细胞因子分泌、细胞毒性</td>
<td>抗原记忆性</td>
</tr>
<tr>
<td>细胞周期</td>
<td>无</td>
<td>有</td>
<td>+/-</td>
</tr>
<tr>
<td>IL-2R亲和力</td>
<td>低</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>外周淋巴结归巢受体（L-selectin，CD62L）</td>
<td>高</td>
<td>低</td>
<td>低或者可变</td>
</tr>
<tr>
<td>黏附分子（整合素，CD44）</td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>趋化因子受体CCR7</td>
<td>高</td>
<td>低</td>
<td>可变</td>
</tr>
<tr>
<td>主要CD45构型</td>
<td>CD45RA</td>
<td>CD45RO</td>
<td>CD45RO；可变</td>
</tr>
<tr>
<td>形态学</td>
<td>小，胞质少</td>
<td>大，胞质多</td>
<td>小</td>
</tr>
</tbody></table>
<p>记忆T细胞：基于归巢特性和效应功能分类：</p>
<ul>
<li>（1）中心记忆T细胞：表达CCR7和L-selectin，归巢到淋巴结。<ul>
<li>在遇到抗原时展示出的效应功能有限。</li>
<li>一旦出现抗原挑战，产生许多效应细胞。</li>
</ul>
</li>
<li>（2）效应记忆T细胞：不表达CCR7和L-selectin，归巢到外周组织，特别是粘膜。<ul>
<li>一旦受到抗原刺激，产生效应细胞因子。</li>
<li>增殖能力差。</li>
</ul>
</li>
</ul>
<h3 id="2、T细胞介导的免疫效应"><a href="#2、T细胞介导的免疫效应" class="headerlink" title="2、T细胞介导的免疫效应"></a>2、T细胞介导的免疫效应</h3><p>   <br>（1）抗感染作用</p>
<ul>
<li>两种引起靶细胞死亡的方式：<ul>
<li>穿孔素（Perforin）-颗粒酶（丝氨酸蛋白酶serine protease）依赖性杀伤</li>
<li>Fas依赖性杀伤</li>
</ul>
</li>
</ul>
<p>   <br>（2）抗肿瘤作用  </p>
<ul>
<li>杀伤突触（killing synapse）：CD8+CTL-tumor互作。<ul>
<li>CTL与靶细胞结合→靶细胞表面被打孔→靶细胞凋亡/坏死</li>
</ul>
</li>
<li>CTL再循环：连续杀死多个靶细胞。</li>
<li>基于树突状细胞（DC）的疫苗诱导CD8+CTL，增强抗肿瘤响应。</li>
</ul>
<p>   <br>（3）免疫病理作用</p>
<h2 id="四、B细胞的免疫调节作用"><a href="#四、B细胞的免疫调节作用" class="headerlink" title="四、B细胞的免疫调节作用"></a>四、B细胞的免疫调节作用</h2><p><strong>★重点掌握：B细胞活化的第一、第二信号；抗体介导的免疫效应（CDC、ADCC、免疫调理）</strong></p>
<p>（1） B细胞作为抗原递呈细胞：</p>
<ul>
<li>当抗原浓度低时， B细胞则由高亲合力的BCR直接识别处理抗原，供Th细胞识别，可补偿其他APC对低浓度抗原递呈无能的不足。</li>
</ul>
<p>（2） B细胞活化分化成浆细胞，产生抗体：体液免疫</p>
<h3 id="1、抗原"><a href="#1、抗原" class="headerlink" title="1、抗原"></a>1、抗原</h3><p>一类能刺激机体免疫系统产生特异性免疫应答，并能与相应免疫应答产物即抗体和致敏淋巴细胞在体内或体外发生特异性结合的物质 。两个性质：免疫原性（immunogenicity）、反应原性（reactiogenicity）
   </p>
<ul>
<li>非己性： 即外源性，抗原来自系统发育距离越远的物种，其外源性越突出，免疫原性就越强。<ul>
<li>不仅包括来自体外的物质，还应包括某些改变或隐蔽的自身抗原。</li>
</ul>
</li>
<li>抗原剂量：过低将导致免疫无反应，过高则可产生免疫耐受(immune tolerance)</li>
<li>注射次数：在数周内反复注射同一抗原比一次性注射效果好</li>
<li>抗原表位（epitope）：存在于抗原分子表面由几个氨基酸残基组成的特殊序列及空间结构。<ul>
<li>决定抗原特异性，也是免疫反应具有高度特异性的物质基础。</li>
<li>抗原分子量越大，表位就越多，越能有效刺激免疫系统产生免疫应答。</li>
<li>大分子物质抗原形成胶体，在体内不易被破坏和清除，停留时间较长。</li>
</ul>
</li>
<li>佐剂（adjuvant）：与抗原一起或先于抗原注入机体后，增强机体对该抗原的免疫应答能力或改变免疫应答类型的物质。<ul>
<li>作用：增强免疫原性， 提高抗体滴度；</li>
<li>种类：<ul>
<li>无机佐剂：如氢氧化铝等</li>
<li>有机佐剂：如微生物（如分枝杆菌）</li>
<li>合成佐剂：如双链多聚腺苷酸（Poly A）</li>
<li>油剂：如弗氏佐剂、矿物油、植物油等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2、抗体"><a href="#2、抗体" class="headerlink" title="2、抗体"></a>2、抗体</h3><p>是机体免疫细胞被抗原激活后，由分化成熟的浆细胞合成分泌的一类与相应抗原特异性结合的具有免疫功能的球蛋白。主要存在于血液、组织液和粘膜分泌液，因此将抗体介导的免疫称为体液免疫(humoral immunity)。
 </p>
<ul>
<li>按位置分两种Ig：分泌型（sIg）、膜结合型（mIg）</li>
<li>按分子结构分五种Ig：IgG（γ）、IgA（α）、IgM（μ）、IgE（ε）和IgD（δ）</li>
</ul>
<table>
<thead>
<tr>
<th>Ig种类</th>
<th>分子结构与位置</th>
<th>功能与特点</th>
</tr>
</thead>
<tbody><tr>
<td>IgG</td>
<td>单体，血清含量最高（75%-85%）</td>
<td>半衰期最长（≈23d），抗感染，唯一能通过胎盘的抗体</td>
</tr>
<tr>
<td>IgM</td>
<td>膜结合型五聚体（“巨球蛋白”）</td>
<td>最早出现，但半衰期短（先锋免疫作用，可用于早诊）。激活补体、结合抗原、免疫调理。天然血型抗体是IgM</td>
</tr>
<tr>
<td>IgA</td>
<td>血清型（肠系膜浆细胞分泌，单体）、分泌型（呼吸道、消化道等处浆细胞分泌，sIgA双体）</td>
<td>sIgA存在于唾液、泪液、以及呼吸道、消化道和泌尿生殖道黏膜表面的分泌液中</td>
</tr>
<tr>
<td>IgD</td>
<td>膜结合型单体，位于B细胞表面（BCR成分）</td>
<td>在mIgM之后出现，标志着B细胞成熟。对防止免疫耐受有一定作用</td>
</tr>
<tr>
<td>IgE</td>
<td>单体，主要由呼吸道和胃肠道粘膜固有层中的浆细胞产生</td>
<td>血清中含量最低（0.002%），可与肥大细胞、嗜碱性粒细胞上的高亲和力Fcε受体结合，引起I型超敏反应</td>
</tr>
</tbody></table>
<p>  <br>抗体介导的免疫效应</p>
<ul>
<li>（1） 中和反应</li>
<li>（2） 抗体依赖的细胞介导的细胞毒性作用（ADCC）<ul>
<li>抗体与靶细胞表面抗原结合后，通过Fc段与CTL表面Tc受体结合，促进对靶细胞的杀伤。</li>
</ul>
</li>
<li>（3） 免疫调理或促吞噬作用<ul>
<li>IgG结合颗粒性抗原（细菌、病毒等）后，Fc段与MΦ、中性粒细胞表面的IgGFc受体结合⇨</li>
<li>促进对颗粒抗原的吞噬⇨免疫调理（opsonization）</li>
</ul>
</li>
<li>（4） 分泌型IgA的局部抗感染作用</li>
<li>（5） 免疫病理作用</li>
</ul>
<p>   <br>补体依赖的细胞毒性（complement-dependent cytotoxicity， CDC）:</p>
<ul>
<li>通过特异性抗体与细胞膜表面相应抗原结合，形成复合物而激活补体经典途径，所形成的攻膜复合物对靶细胞发挥裂解效应。</li>
</ul>
<h3 id="3、体液免疫应答（humoral-immunity）"><a href="#3、体液免疫应答（humoral-immunity）" class="headerlink" title="3、体液免疫应答（humoral immunity）"></a>3、体液免疫应答（humoral immunity）</h3><p> <br>（1）B细胞对抗原的识别</p>
<ul>
<li>BCR信号通路：Igα/Igβ是BCR的组成成分。</li>
<li>B细胞活化双信号：BCR和第二信号（B7、CD40、ICOSL）。其他信号：细胞因子受体IL-4R、IL-21R、IL-17R。</li>
</ul>
<p>   <br>（2）B细胞抗原识别信号的传导<br>   <br>（3）B细胞增殖分化为浆细胞及生发中心的形成</p>
]]></content>
      <categories>
        <category>生物</category>
      </categories>
      <tags>
        <tag>免疫</tag>
        <tag>T细胞</tag>
        <tag>B细胞</tag>
        <tag>复习资料</tag>
      </tags>
  </entry>
  <entry>
    <title>与AI的围炉夜谈</title>
    <url>/2023/04/07/night-talk-with-AI-1/</url>
    <content><![CDATA[<p>chatGPT很聪明，偶尔可以当心理医生来用。</p>
<span id="more"></span>

<blockquote>
<p><strong>Warren Z:</strong></p>
<p>从小到大，我一直都无法和别人亲近，在处理同学关系和亲密关系上一直都有问题。我还记得因为相处不融洽，小学连换了好几个同桌；初中时，和好几位人很好的同桌都闹掰了；高中和其他同学都很难玩到一起去——即使那时结识了一个特别好的朋友，结果这份友谊只维持到大学第一学期就彻底闹掰，并且事后反思确实是我的问题。现在问题依然存在，我也常常感觉自己很孤独。</p>
<p>之前想到过进行心理咨询。然而心理咨询的费用是奇高无比的，并且我并不敢相信，在短短45分钟里，咨询师可以明白我在处理亲密关系方面的坎坷经历，也不敢相信咨询师可以给出一些靠谱的方法而不是说什么接纳自己的不足之类的废话。能够融入集体，至少是现阶段我希望的目标。</p>
<p>脑海里突然涌现出去年蒲慕明院士的讲话。蒲慕明院士说，读博更重要的是情商。我深以为然，并自认为自己的情商不够——因为，处理不好人际关系确实说明情商低，而无法自控地刷手机导致生活out of control同样也是情商低的表现。我很害怕；并且，我真的很想提高情商——或者说，我希望得到一切在提高情商后能够得到的好处，例如更好的把控自己的生活，例如如鱼得水地处理人际关系，例如更好的处理亲密关系。</p>
<p>有一本书叫做《亲密关系》，作者我忘了，但是总感觉那本书应该会给我一些答案。然而或许还有一些更重要的问题：为了前面你提到的那些想要的东西，你愿意付出些什么代价？</p>
<p>chatGPT，你有什么好方法吗？</p>
</blockquote>
<p><strong>chatGPT:</strong></p>
<p>首先，感谢你对我的信任，能与我分享你的困惑。关于你提到的处理亲密关系的问题，我理解你对这个问题的重视。你提到你在过去的经历中有许多与同桌、室友、朋友的矛盾，你认为这可能是由于自己的问题导致的。首先，我想告诉你，没有任何一个人在处理人际关系时都完美无缺。人际关系本身就是一种相互影响和调整的过程，需要大家共同努力。</p>
<p>同时，我建议你可以先反思一下自己在与别人相处时存在的问题，是否是因为自己难以接受别人的不同意见或观点，或者是因为自己的情绪控制不好等等。如果你能够有意识地改善自己的缺点，提高自己的人际交往能力，那么你就能更好地适应集体生活，与别人建立更为良好的人际关系。</p>
<p>此外，如果你依然感到自己需要帮助来处理这个问题，我建议你可以考虑以下两个途径：</p>
<p>第一，你可以找一些适合你的自助教材或是书籍来学习相关的人际交往技巧，这些书籍可以为你提供一些有用的思路和方法。</p>
<p>第二，你可以考虑参加一些相关的社交活动，比如志愿者活动、兴趣小组等等，这样可以帮助你更好地适应集体生活，结交志同道合的朋友，同时提升你的人际交往技巧。</p>
<p>最后，如果你依然感到需要寻求心理咨询的帮助，但担心费用问题，你可以向一些心理咨询机构或大学心理咨询中心咨询是否有免费或收费较低的咨询服务。</p>
<blockquote>
<p><strong>Warren Z:</strong></p>
<p>我反思了一下，确实在我身上有许多问题，例如控制不好情绪、总是凭借个人感觉去揣测别人的想法而不加以证实等等。这也导致了我对许多同学的误解。然而我确实不太明白什么是正确的相处模式，并且和其他人相处时，因为总担心自己吃亏。这该怎么办呢？另外，可以推荐一些书吗？</p>
</blockquote>
<p><strong>chatGPT:</strong></p>
<p>首先，对于你的问题，我建议你可以多加练习和其他人交往。尝试主动与同学、室友进行对话，试着去倾听他们的想法，用心理解他们的角度，以此来建立互信和友谊。当你学会了相信别人，同时也学会了放下内心的猜疑和防备，这也将帮助你更好地与人相处。</p>
<p>其次，我可以推荐一些书给你，这些书可能会对你在处理人际关系方面有所帮助。其中一些书籍包括：《情商》（作者：戴维·戈尔曼）、《非暴力沟通》（作者：马维·罗森伯格）、《人性的弱点》（作者：戴尔·卡耐基）和《好好说话》（作者：朱学恒）。这些书籍可以帮助你更好地理解和应对与他人的互动，提高你的人际交往能力。</p>
<p>最后，我还要提醒你，人际交往是一项长期的过程，需要不断地练习和尝试。不要过于苛求自己，也不要放弃自己。只要你保持着积极的心态，不断地学习和尝试，相信你一定会慢慢地找到属于自己的正确相处方式。</p>
<blockquote>
<p><strong>Warren Z</strong></p>
<p>谢谢你，chatGPT。</p>
<p>刚刚我又意识到一个问题。这几年互联网上的戾气是越来越严重了，其中一条很重要的表现就是对人际关系的险恶进行大幅度渲染，例如讲室友是如何坑自己的，朋友是如何坑自己的，对象是如何劈腿的，原生家庭是如何悲惨的，婚姻是如何不幸福的。我相信这其中即使有很多人是编故事骗流量，也应该有一部分是真实发生的事情。然而看完那些故事以后，我总是陷入一种防御性状态，极力想要疏远并防御性攻击身边的人，即使是父母也不例外。这种状态让我感到害怕和恐慌，并且在缓解以后感觉很对不起身边的人。</p>
<p>互联网上的这些故事和前面所说的好像又有点矛盾。如果想要融入集体、收获很好的亲密关系，开放包容的心态必不可少；然而这些故事看完以后我只想把自己封闭起来，宁可为千夫所指也不想在人际交往方面吃亏。我想后者是错误的。然而既然有些故事是真的，那么这意味着开发包容的心态确实容易吃亏。所以，如果我既想收获亲密关系，又想有效自我保护，我该怎么做？</p>
</blockquote>
<p><strong>chatGPT:</strong></p>
<p>你提到了一个很重要的问题。互联网上的戾气和负面故事会对我们的心态和态度产生很大的影响。它们可能会让我们对人际关系更加警惕和谨慎，甚至产生一种恐慌感和自我保护的欲望。</p>
<p>但是，我们也要注意到这些故事很多都是极端的例子，不代表绝大多数人际关系都是那样。此外，互联网上的内容往往会存在一定的倾向性，让人们更倾向于关注负面的、激起情绪的信息，这也会影响我们的认知和判断。因此，我们需要对这些内容保持一定的警惕和辨别力，不要被它们所左右。</p>
<p>如果我们想要收获亲密关系，开放包容的心态是必不可少的，但这并不意味着我们要完全忽视自我保护。一方面，我们需要学会识别并避免那些对我们有害的人和关系，但另一方面，我们也需要敢于面对和接受那些可能会造成伤害的风险，因为只有这样才能真正地建立和维护有意义的人际关系。</p>
<p>推荐一些书，例如《非暴力沟通》（作者马歇尔·卢森伯格）和《七个习惯高效人士的自我修养》（作者史蒂芬·柯维），这些书可以帮助你更好地理解和处理人际关系，并提供一些实用的方法和技巧。</p>
]]></content>
      <categories>
        <category>杂思</category>
      </categories>
      <tags>
        <tag>思绪整理</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux客户机和服务器之间配置免密登录（SSH）</title>
    <url>/2023/02/13/linux%E5%AE%A2%E6%88%B7%E6%9C%BA%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E9%85%8D%E7%BD%AE%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%EF%BC%88ssh%EF%BC%89/</url>
    <content><![CDATA[<p>如何配置ssh免密登录？</p>
<span id="more"></span>

<p>客户端通过ssh登录服务器的一般方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh &lt;username&gt;@&lt;ip address&gt;</span><br></pre></td></tr></table></figure>

<p>其中<code>&lt;username&gt;</code>和<code>&lt;ip address&gt;</code>分别填入用户名和远程服务器的IP地址。</p>
<p>如果没有配置免密登录，这一步之后一般会提示输入密码。</p>
<p>但是如果经常要登录，每次都输入密码显然很麻烦。于是我们可以配置免密登录，方法如下：</p>
<h3 id="1、在客户端上输入下列指令，生成客户机的公钥和密钥"><a href="#1、在客户端上输入下列指令，生成客户机的公钥和密钥" class="headerlink" title="1、在客户端上输入下列指令，生成客户机的公钥和密钥"></a>1、在客户端上输入下列指令，生成客户机的公钥和密钥</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>

<p>这个指令的输出大致如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/home/&lt;username&gt;/.ssh/id_rsa):</span><br></pre></td></tr></table></figure>

<p>我们直接接受默认设置，连按三次回车键即可。</p>
<p>此时，客户端会生成两个文件，分别是公钥（<code>~/.ssh/id_rsa.pub</code>）和密钥（<code>~/.ssh/id_rsa</code>）</p>
<h3 id="2、在客户端上输入下列指令，将公钥上传到远程服务器"><a href="#2、在客户端上输入下列指令，将公钥上传到远程服务器" class="headerlink" title="2、在客户端上输入下列指令，将公钥上传到远程服务器"></a>2、在客户端上输入下列指令，将公钥上传到远程服务器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub &lt;username&gt;@&lt;ip address&gt;</span><br></pre></td></tr></table></figure>

<p>其中<code>&lt;username&gt;</code>和<code>&lt;ip address&gt;</code>分别填入用户名和远程服务器的IP地址。</p>
<p>在运行上述指令的过程中，可能会提示输入服务器登录密码。照他的提示做就行。</p>
<h3 id="3、成功完成配置。此时再运行下列指令，无需输入密码即可登录的服务器。"><a href="#3、成功完成配置。此时再运行下列指令，无需输入密码即可登录的服务器。" class="headerlink" title="3、成功完成配置。此时再运行下列指令，无需输入密码即可登录的服务器。"></a>3、成功完成配置。此时再运行下列指令，无需输入密码即可登录的服务器。</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh &lt;username&gt;@&lt;ip address&gt;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<blockquote>
<p>旧评论系统备份：</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Hazel(2023-04-12 20:44:14):</span><br><span class="line">	所以这样的方法不需要在服务器上做什么更改吗？</span><br><span class="line">	还想再学学如何绕过VPN连接，有什么好的软件推荐或者在终端上有什么操作吗？</span><br><span class="line"></span><br><span class="line">&gt; WarrenZhang(2023-04-22 01:05:05):</span><br><span class="line">&gt;	需要的呀，正文里面有一小段《在客户端上输入下列指令，将公钥上传到远程服务器》，讲得就是在服务器端的更改。</span><br><span class="line">&gt;	ssh登录好像一般不会走VPN，如果需要通过VPN进行ssh登录链接，可以在命令行中加一个 &quot;ProxyCommand&quot; 参数，具体用法可以参考此文：https://blog.csdn.net/qq_34139020/article/details/101039791</span><br><span class="line"></span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>ssh</tag>
        <tag>免密登录</tag>
      </tags>
  </entry>
  <entry>
    <title>obsidian探索小记（三）——与flomo笔记的联动</title>
    <url>/2023/12/16/obsidian-flomo-interact-1/</url>
    <content><![CDATA[<p>对obsidian笔记软件的继续探索。</p>
<span id="more"></span>

<h2 id="零、背景"><a href="#零、背景" class="headerlink" title="零、背景"></a>零、背景</h2><p><a href="https://flomoapp.com/">flomo笔记</a> 是一款简洁的闪念笔记记录软件，由两位互联网资深创业者刘少楠（<a href="https://web.okjike.com/u/7B1385A9-FCC9-4446-B8CE-472EAF6817B2">少楠</a>）与刘白光（<a href="https://lightory.notion.site/">Lightory</a>）合作开发。两位作者先前共同打造过二手书漂流网站“摆摆书架”，现在他们的团队除了flomo笔记以外还有两款产品：<a href="https://mubu.com/app">幕布大纲笔记</a>和付费专栏工具<a href="https://xiaobot.net/home.html">“小报童”</a> 。</p>
<p>和一般的笔记思路不同，flomo采取的是一种“闪念笔记”的思路。说人话，就是你走在路上，突然蹦出来一个点子，这个点子你感觉很有价值却不知道记在哪里合适，此时flomo的应用场景就出现了。如下图，flomo的笔记记录以卡片为单位（被称为<code>&quot;MEMO&quot;</code>），支持富文本格式和图片插入，此外各条笔记之间还可以通过 <code>tag</code> 进行联动。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231217155935.png" alt="image.png"></p>
<p>那么这样的笔记软件在何时有用呢？一种场景就是前面提到的“走在路上，突然蹦出来一个点子”。而flomo提供的<code>tag</code>系统和数据统计插件（如下图），也可以帮助我们回顾自己的点子，这或许是另外一种应用场景。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231217160931.png" alt="image.png"></p>
<p>本文主要从<code>obsidian -&gt; flomo</code> 和 <code>flomo -&gt; obsidian</code> 两个方面开展介绍。</p>
<h2 id="一、flomo的注册与配置"><a href="#一、flomo的注册与配置" class="headerlink" title="一、flomo的注册与配置"></a>一、flomo的注册与配置</h2><h3 id="1-注册"><a href="#1-注册" class="headerlink" title="1. 注册"></a>1. 注册</h3><p>根据flomo团队的设计理念（参考<a href="https://help.flomoapp.com/about-us/about-us/company-concept.html">《一个笔记服务的长期主义》</a>），flomo笔记的设计一切从简，包括注册和登录界面。因此，与绝大多数软件服务不同，flomo现在支持的登录（和注册）方式较少，只有邮件登录、短信验证码登录和微信登录三种。</p>
<p>如果没有账号，可以在 <a href="https://v.flomoapp.com/register">https://v.flomoapp.com/register</a> 上进行注册，完成登陆后将进入主界面。主界面内容相当简洁，左边是各种统计面板和 <code>tag</code> 的列表，右边则是<code>MEMO</code>的编辑框和之前记下的各种<code>MEMO</code>记录。</p>
<p>可以直接在网页端使用flomo记录笔记，也可以使用flomo的app或微信服务进行笔记记录。flomo还提供了<a href="https://help.flomoapp.com/advance/api.html">上传API</a> ，允许第三方软件开发者通过<code>POST</code>的方式将笔记上传到flomo中。</p>
<p>（然而很不幸的是，上传API只有会员账号能用，而会员账号一个月要15块钱呢！如果没有会员账号的话，第二节的内容可以全部跳过了——这部分内容需要API😢）</p>
<h3 id="2-API"><a href="#2-API" class="headerlink" title="2. API"></a>2. API</h3><p>如何找到这个API呢？方法很简单。点击网页左上角的用户名按钮，在弹出菜单中选择<code>API &amp; Plugin</code>选项，就能在MEMO API界面中查看到自己的API。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231217165704.png" alt="image.png"></p>
<p>MEMO API界面如下图。注意两点：</p>
<ul>
<li>（1）非会员用户也有自己的API，但是无法使用。（因此为了正常使用这一功能，建议冲个VIP？不过，好像完成任务或者邀请好友也能获得VIP天数）</li>
<li>（2）这个API可以被任何人、任何软件使用，因此为了自己数据的安全，不要轻易泄露API字符串。</li>
</ul>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231217162542.png" alt="image.png"></p>
<h3 id="3-在自己的程序中使用API（非obsidian联动必须）"><a href="#3-在自己的程序中使用API（非obsidian联动必须）" class="headerlink" title="3. 在自己的程序中使用API（非obsidian联动必须）"></a>3. 在自己的程序中使用API（非obsidian联动必须）</h3><p>为了说明这个API的原理，我们可以写一个简单的小程序使用这个API（代码中的<code>API</code>变量需要手动修改为自己的API）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> sys,os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处将变量API的内容改为自己的flomo API</span></span><br><span class="line">API = <span class="string">&quot;https://flomoapp.com/xxx/xxxxxxx/xxxxxxxxxxxxxxx/&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义上传函数，传入要上传的笔记内容（content），完成上传</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upload</span>(<span class="params">content</span>):</span><br><span class="line">	<span class="comment"># 构建POST内容体。POST的内容体是一个包含content的字符串</span></span><br><span class="line">    post_body = json.dumps(&#123;<span class="string">&quot;content&quot;</span>:content&#125;,indent=<span class="string">&quot;\t&quot;</span>,ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># 构建POST标头。标头中必须标明&quot;Content-Type&quot;是json，否则flomo无法识别上传的内容</span></span><br><span class="line">    headers = &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>&#125;</span><br><span class="line">    <span class="built_in">print</span>(post_body) <span class="comment"># 打印出POST内容体</span></span><br><span class="line">    <span class="comment"># 下面的代码调用requests库，实现对笔记内容的POST</span></span><br><span class="line">    req = requests.post(API,data=post_body.encode(<span class="string">&quot;utf-8&quot;</span>),headers=headers)</span><br><span class="line">    req.encoding = <span class="string">&quot;utf-8&quot;</span></span><br><span class="line">    txt = req.text</span><br><span class="line">    <span class="comment"># 打印POST的返回值。返回值也是一个json字符串</span></span><br><span class="line">    <span class="built_in">print</span>(txt)</span><br><span class="line"><span class="comment"># 定义主函数。主函数从命令行参数中读取笔记内容，然后调用upload()进行上传</span></span><br><span class="line"><span class="keyword">if</span>(__name__==<span class="string">&quot;__main__&quot;</span>):</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">len</span>(sys.argv)&lt;<span class="number">2</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;usage: python flomo-api-demo.py &lt;flomo note&gt;&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line">    upload(<span class="string">&quot; &quot;</span>.join(sys.argv[<span class="number">1</span>:]))</span><br></pre></td></tr></table></figure>

<p>程序与网站API交互的方式主要有两种：  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET"><code>GET</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/web/http/methods/post"><code>POST</code></a>  。前者将要上传的内容明文存储在URL字符串中，包括百度翻译API在内的许多网站都使用的是这种方法。而后者将要上传的内容存储在POST payload中，其对于使用者来说是不可见的，网站在收到POST请求后会处理POST payload，这也是flomo笔记API所采用的方法。POST方法可以上传的数据量更大，并且在网站设计规范中也推荐使用POST上传大批量的数据。</p>
<p>如上述代码所示，我们将要上传的笔记内容转换为一个json结构体，然后将其附在对flomo API的post请求中，即可实现上传。</p>
<p>测试指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python flomo-api-demo.py 这条记录上传自命令行 <span class="comment">#computer/api</span></span><br></pre></td></tr></table></figure>

<p>运行结果如下，则说明API正常。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">~$ python flomo-api-demo.py 这条记录上传自命令行 #computer/api</span><br><span class="line">&#123;</span><br><span class="line">        &quot;content&quot;: &quot;这条记录上传自命令行 #computer/api&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#123;&quot;code&quot;:0,&quot;message&quot;:&quot;Saved to flomo.&quot;,&quot;memo&quot;:&#123;&quot;creator_id&quot;:1562134,&quot;source&quot;:&quot;incoming_webhook&quot;,&quot;content&quot;:&quot;&lt;p&gt;\u8fd9\u6761\u8bb0\u5f55\u4e0a\u4f20\u81ea\u547d\u4ee4\u884c #computer\/api&lt;\/p&gt;&quot;,&quot;tags&quot;:[&quot;computer\/api&quot;],&quot;updated_at&quot;:&quot;2023-12-17 16:36:18&quot;,&quot;created_at&quot;:&quot;2023-12-17 16:36:18&quot;,&quot;linked_memos&quot;:[],&quot;linked_count&quot;:0,&quot;slug&quot;:&quot;OTU2MTQyNTQ&quot;&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同时，在网页端我们也能看见这条笔记的信息。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231217164501.png" alt="image.png"></p>
<p>基于这一原理，可以实现笔记从任何第三方软件上传到flomo笔记当中。</p>
<h2 id="二、配置obsidian-gt-flomo"><a href="#二、配置obsidian-gt-flomo" class="headerlink" title="二、配置obsidian -&gt; flomo"></a>二、配置<code>obsidian -&gt; flomo</code></h2><blockquote>
<p>参考 ： <a href="https://blog.csdn.net/diandianxiyu_geek/article/details/128658738">《Obsidian 插件 Obsidian to Flomo 一键同步内容到 Flomo 插件》</a></p>
</blockquote>
<p>这一部分需要flomo的API。</p>
<p>在obsidian中，需要安装一个插件 <a href="https://github.com/metal-young/obsidian-to-flomo"><code>Obsidian to Flomo</code></a> 。在应用内的插件市场搜索<code>Obsidian to Flomo</code>即可搜到。</p>
<p>打开 Obsidian 的偏好设置，找到<strong>第三方插件</strong>，选择<strong>社区插件市场</strong>，即可搜索<code>Obsidian to Flomo</code>。搜索之后点击安装即可。安装完成后，启用这一插件。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231217165259.png" alt="image.png"></p>
<p>在插件启用之后，我们点击选项按钮，到达插件的配置页面。在这里，需要填写我们的flomo API。获取flomo API的方法见前文。</p>
<p>之后，点击“Send a test request”测试，如果看到成功发送到提示，就表示配置成功。回到 Flomo笔记中，还可以看到测试发送的内容，这条内容删掉即可。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231217165309.png" alt="image.png"></p>
<p>如何使用这个插件呢？其实很简单。如下图所示，在 Obsidian 中打开一个文件，然后打开命令面板或快捷键 <code>command</code> + <code>P</code>，输入<code>obsidian to flomo</code>，选择“发送当前内容至Flomo”（Send current content to Flomo）即可。这样，就可以将一条笔记同步到flomo中。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231217160430.png" alt="image.png"></p>
<p>如果不想同步整篇笔记，还可以先选中部分文字内容，然后在obsidian命令面板里面选择“发送选中的内容至Flomo”（Send selected content to Flomo）即可。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231217170445.png" alt="image.png"></p>
<p>打开flomo，就可以看到上传的笔记。可以对这些笔记进行编辑，添加标签，修改其中的段落，或者在不同的MEMO之间建立关联。</p>
<h2 id="三、配置flomo-gt-obsidian"><a href="#三、配置flomo-gt-obsidian" class="headerlink" title="三、配置flomo -&gt; obsidian"></a>三、配置<code>flomo -&gt; obsidian</code></h2><p>很遗憾，这一部分内容我探索的还不够多，所以能写的也很少。不过确实有插件支持<code>flomo -&gt; obsidian</code>的笔记导出。</p>
<p>由于API限制，目前flomo仅支持从API导入笔记，并不支持从API中批量导出笔记。flomo仅支持一键批量导出到HTML（在<a href="https://v.flomoapp.com/mine?source=account"><code>用户名 -&gt; Account -&gt; Data synchronization</code></a>页面中，如下图），这种方式并不灵活，在导出后如果笔记有更新，还需要重新进行手动导入导出以同步笔记。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231217171044.png" alt="image.png"></p>
<p>我也曾试过使用网页调试器进行分析，以期找到对flomo笔记的爬虫方法，但一无所获。</p>
<p>所以，现在只有一键导出到html这一种方法允许我们进行探索。</p>
<p>在obsidian上，有一款插件名为 <a href="https://github.com/jia6y/flomo-to-obsidian"><code>Flomo Importer</code></a> 。这款插件可以从flomo导出的html笔记中导入obsidian。在obsidian的插件商城中搜索插件名称即可进行安装。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231217171751.png" alt="image.png"></p>
<p>安装完成后，在obsidian的左侧工具栏会出现Flomo Importer的图标（如下图红框所示）。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231217172035.png" alt="image.png"></p>
<p>点击这个按钮，会进入Flomo Importer的界面，它提醒我们选取一个文件，从这个文件中导入数据。其他的一些选项保持默认就行。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231217171825.png" alt="image.png"></p>
<p>如此，可以将flomo的笔记导入obsidian。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231217172333.png" alt="image.png"></p>
<p>flomo笔记的产品思路很独特，感觉未来还能继续探索探索。</p>
<p>以上。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>obsidian探索小记</tag>
        <tag>flomo</tag>
        <tag>webAPI</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python的SymPy库求解不定积分</title>
    <url>/2023/12/14/python-sympy-CAS-and-Indefinite-integral/</url>
    <content><![CDATA[<p>如题。</p>
<span id="more"></span>


<p><strong>参考</strong></p>
<blockquote>
<p>  <a href="https://docs.sympy.org/latest/tutorials/intro-tutorial/intro.html">https://docs.sympy.org/latest/tutorials/intro-tutorial/intro.html</a><br>  <a href="https://blog.csdn.net/Havingfunin/article/details/104741277">https://blog.csdn.net/Havingfunin/article/details/104741277</a><br>  <a href="https://blog.csdn.net/t4ngw/article/details/105770161">【sympy】用python的库 sympy 求积分</a><br>  <a href="https://www.jianshu.com/p/3aea36f7a231">https://www.jianshu.com/p/3aea36f7a231</a><br>  <a href="https://www.zhihu.com/question/414548947">https://www.zhihu.com/question/414548947</a><br>  <a href="https://zhuanlan.zhihu.com/p/196784442">用sympy求解积分的一个小例子 - 人生不会倒流的文章 - 知乎</a><br>  <a href="https://zhuanlan.zhihu.com/p/111573239">SymPy 符号计算基本教程 - Longson的文章 - 知乎</a></p>
</blockquote>
<p>计算机代数系统（Computer Algebra System），简称CAS，其标志是能够以字符串作为单位进行运算。科学计算可分为两类，一类是纯数值的计算，例如求函数的值，方程的数值解；另一类计算就是符号计算，这就像我们平时在数学的教学和研究中用笔和纸进行的数学运算一样，用各种字母 $x,y,z$ 代替具体数值，进行算式和方程的推导。</p>
<p>常见的编程语言如python、R、C++、Java等都支持数值计算，用户输入算式，程序输出结果。但是有些时候我们会碰到这样的任务：函数求导（不需要知道某个点的导函数，而是求解整个导函数的表达式）、不定积分（同样是求表达式）、多项式化简等。此时，数值计算就无能为力了。</p>
<p>SymPy是一个符号计算的Python库。它的目标是成为一个全功能的计算机代数系统，同时保持代码简洁、易于理解和扩展。它完全由Python写成，不依赖于外部库。 </p>
<p>在下面这篇文章中，作者详细列出了sympy可以做的事情，本文不再赘述。</p>
<p><a href="https://zhuanlan.zhihu.com/p/111573239">《SymPy 符号计算基本教程》 - Longson的文章 - 知乎</a></p>
<p>本文重点讲述，如何使用sympy计算不定积分：</p>
<p>Sympy是使用<code>integrate(表达式,变量)</code>来求不定积分的，具体来说：</p>
<ul>
<li><code>integrate(f(x),x)</code> 计算不定积分 $\int{f(x)dx}$</li>
<li><code>integrate(f(x),(x,a,b))</code> 计算定积分 $\int_a^b{f(x)dx}$</li>
</ul>
<p>例如</p>
<p>求解定积分</p>
<p>$$<br>F(x)=\int_0^1x^{2} + e^{x} + 1\ \text{d}x<br>$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> *</span><br><span class="line">x = symbols(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(integrate(x**<span class="number">2</span> + exp(x) + <span class="number">1</span>, (x, <span class="number">0</span>, <span class="number">1</span>))) <span class="comment"># 定积分</span></span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1/3 + E</span><br></pre></td></tr></table></figure>


<p>上述程序如果求解的是不定积分，则代码改为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> *</span><br><span class="line">x = symbols(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(integrate(x**<span class="number">2</span> + exp(x) + <span class="number">1</span>, x)) <span class="comment"># 定积分</span></span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">x**3/3 + x + exp(x)</span><br></pre></td></tr></table></figure>

<p>即原函数为</p>
<p>$$<br>F(x)=\frac{x^{3}}{3} + x + e^{x}<br>$$</p>
<p>另一个例子：求解不定积分</p>
<p>$$<br>F(x)=\int\frac{x e^{x}}{\left(e^{x} + 1\right)^{2}} \text{d}x<br>$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> *</span><br><span class="line">x = symbols(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(integrate(x*exp(x)/(exp(x)+<span class="number">1</span>)**<span class="number">2</span>, x))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>output</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">x - x/(exp(x) + 1) - log(exp(x) + 1)</span><br></pre></td></tr></table></figure>

<p>也就是说，原函数为</p>
<p>$$<br>F(x)=x - \frac{x}{e^{x} + 1} - \log{\left(e^{x} + 1 \right)}<br>$$</p>
<p>当然，在某些情况下，sympy可能没法一下子就求出原函数，此时求积分可能需要一些技巧：</p>
<p>例如求解定积分（来自知乎问题  <a href="https://www.zhihu.com/question/414548947">《这个sympy 库为什么求不出这个函数的不定积分？》</a> ）</p>
<p>$$<br>F(x)=\int_0^{\pi/2}\sqrt{1 - \cos{\left(2 x \right)}} \text{d}x<br>$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sympy <span class="keyword">as</span> sym</span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> sin,cos,sec,exp,asin,sqrt,pi  <span class="comment">#必须将特殊的函数和常数导入程序才能运行</span></span><br><span class="line">x = sym.symbols(<span class="string">&#x27;x&#x27;</span>) <span class="comment">#定义符号变量</span></span><br><span class="line">y = sym.symbols(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"></span><br><span class="line">d = sym.Integral(sqrt(<span class="number">1</span>-cos(<span class="number">2</span>*x)),(x,<span class="number">0</span>,pi/<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure>

<p>输出依然为</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Integral(sqrt(1 - cos(2*x)), (x, 0, pi/2))</span><br></pre></td></tr></table></figure>

<p>也就是说，并没有求出具体的解。</p>
<p>但是我们可以用一些方法得到问题的解（参考文章 <a href="https://zhuanlan.zhihu.com/p/196784442">《用sympy求解积分的一个小例子 - 人生不会倒流的文章 - 知乎》</a> ）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sympy <span class="keyword">as</span> sym</span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> sin,cos,sec,exp,asin,sqrt,pi  <span class="comment">#必须将特殊的函数和常数导入程序才能运行</span></span><br><span class="line">x = sym.symbols(<span class="string">&#x27;x&#x27;</span>) <span class="comment">#定义符号变量</span></span><br><span class="line">y = sym.symbols(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"></span><br><span class="line">d = sym.Integral(sqrt(<span class="number">1</span>-cos(<span class="number">2</span>*x)),(x,<span class="number">0</span>,pi/<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="built_in">print</span>(d.simplify())</span><br><span class="line"><span class="built_in">print</span>(d.simplify().simplify())</span><br></pre></td></tr></table></figure>


<p>输出：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">In [20]: d = sym.Integral(sqrt(1-cos(2*x)),(x,0,pi/2))</span><br><span class="line"></span><br><span class="line">In [21]: print(d)</span><br><span class="line">Integral(sqrt(1 - cos(2*x)), (x, 0, pi/2))</span><br><span class="line"></span><br><span class="line">In [22]: print(d.simplify())</span><br><span class="line">Integral(sqrt(2)*sqrt(sin(x)**2), (x, 0, pi/2))</span><br><span class="line"></span><br><span class="line">In [23]: print(d.simplify().simplify())</span><br><span class="line">sqrt(2)</span><br></pre></td></tr></table></figure>

<p>对<code>integrate()</code>的结果，第一次使用<code>simplify()</code>进行化简，得到化简后的表达式，此时的表达式已经能够进行求值了。</p>
<p>$$<br>\int\limits_{0}^{\frac{\pi}{2}} \sqrt{2} \sqrt{\sin^{2}{\left(x \right)}}\ \text{d}x<br>$$</p>
<p>第二次使用<code>simplify()</code>进行化简，则直接得到所求定积分的结果 $\sqrt{2}$ 。这真的很神奇！</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>python</tag>
        <tag>计算机代数系统</tag>
        <tag>SymPy</tag>
        <tag>高等数学</tag>
        <tag>不定积分</tag>
      </tags>
  </entry>
  <entry>
    <title>obsidian探索小记（二）——配置obsidian的自动上传图床</title>
    <url>/2023/11/30/obsidian-image-auto-uploader/</url>
    <content><![CDATA[<p>本文介绍了obsidian图片自动上传插件Image auto upload plugin的配置与使用方法，并配置了腾讯云对象存储服务器作为上传图床。</p>
<span id="more"></span>

<blockquote>
<p>参考： <a href="https://zhuanlan.zhihu.com/p/565218725">https://zhuanlan.zhihu.com/p/565218725</a></p>
</blockquote>
<p>obsidian是一个界面很好看的markdown笔记软件。</p>
<p>markdown文档，其本质上是一个文本文件，虽然其中可以插入图片、链接等外部资源，但是这些资源本质上是通过链接到其他资源实现的。对于obsidian来说，插入文档中的图片会在本地存储，并在markdown文档中新增一条指向这张图片文件的链接。</p>
<p>然而有时候，我们会有分享markdown源代码，或者对markdown文档进行迁移的需求。如果分享文档或迁移文档时时还需要连同图片文件一起移动，则会非常麻烦。幸运的是，有一种方法可以免去这一烦恼，这就是使用互联网图床。</p>
<ul>
<li>图床：互联网中存储图片的空间。举个例子说明：假设你在微博分享一张图片，你的粉丝可以通过互联网看到你分享的图片，那么他是去访问你的手机的相册吗？其实不是的，你分享图片，也就是把图片上传到微博的服务器，微博将为你生成一个独一无二的访问链接，这个链接指向的空间其实就是图床。</li>
</ul>
<p>obsidian提供了一款名为Image auto upload plugin的插件，可以实现自动将图片上传到图床的功能。下面是一些探索。</p>
<h2 id="一、安装插件"><a href="#一、安装插件" class="headerlink" title="一、安装插件"></a>一、安装插件</h2><p>在插件商城中搜索这一插件然后点击安装即可。</p>
<p>插件设置界面如下：</p>
<p><img src="https://pic.imgdb.cn/item/656c7bf6c458853aef7f6f76.jpg" alt="config panel"></p>
<h2 id="二、开通腾讯云对象存储服务"><a href="#二、开通腾讯云对象存储服务" class="headerlink" title="二、开通腾讯云对象存储服务"></a>二、开通腾讯云对象存储服务</h2><p>这款插件支持PicGo和PicGo-core两款图片上传器。先不着急安装图片上传器，我们看看PicGo的文档，确定可以使用的图床范围。</p>
<ul>
<li>PicGo: <a href="https://picgo.github.io/PicGo-Doc/zh/guide/#picgo-is-here">https://picgo.github.io/PicGo-Doc/zh/guide/#picgo-is-here</a><ul>
<li>一个用于快速上传图片并获取图片 URL 链接的工具，基于electron架构开发。</li>
</ul>
</li>
<li>PicGO-core： <a href="https://picgo.github.io/PicGo-Core-Doc/zh/guide/">https://picgo.github.io/PicGo-Core-Doc/zh/guide/</a><ul>
<li>PicGO的内核程序，通过命令行调用，基于nodejs开发</li>
</ul>
</li>
</ul>
<p>PicGo 本体支持如下图床：</p>
<ul>
<li>七牛图床 v1.0</li>
<li>腾讯云 COS v4\v5 版本 v1.1 &amp; v1.5.0</li>
<li>又拍云 v1.2.0</li>
<li>GitHub v1.5.0</li>
<li>SM.MS V2 v2.3.0-beta.0</li>
<li>阿里云 OSS v1.6.0</li>
<li>Imgur v1.6.0</li>
</ul>
<p>PicGo本体不再增加默认的图床支持。可以自行开发第三方图床插件（但为了方便，本文没有对此进行探索）。</p>
<p>第三方图床服务存在跑路风险，为了数据安全性我们尽量选择腾讯云或阿里云的对象存储服务，大企业更放心一点。</p>
<p>由于阿里云的服务比腾讯云略贵，这里我们选择腾讯云在线存储服务。访问腾讯云COS服务购买页面（网址 <a href="https://cloud.tencent.com/product/cos">https://cloud.tencent.com/product/cos</a> ），然后选择基础版服务，付费开通即可。一年的费用大约不到10元，四舍五入只有一顿早饭钱，因此建议开通使用（如果觉得只用来做图床有点空间浪费，还可以使用这个存储服务存一些别的东西）。</p>
<h2 id="三、安装PicGO-core上传器，并配置账号"><a href="#三、安装PicGO-core上传器，并配置账号" class="headerlink" title="三、安装PicGO-core上传器，并配置账号"></a>三、安装PicGO-core上传器，并配置账号</h2><p>接下来，我们安装上传器。根据官网介绍，如果使用PicGO作为上传器，则在使用obsidian编写文档时需要在后台开启PicGO的服务，并会占用一些系统资源，非常不方便。因此，这里我选择PicGO-core作为上传程序。PicGO-core是一个命令行程序，配置好安装路径后就可以不管它了。</p>
<h3 id="（一）安装node-js"><a href="#（一）安装node-js" class="headerlink" title="（一）安装node.js"></a>（一）安装node.js</h3><p>PicGo-core基于JavaScript语言开发，需要使用node.js这一代码解释器运行。（“node.js之于JavaScript，就如python.exe之于python程序”）</p>
<p>因此，要安装PicGO-core，首先需要安装node.js，并将node.js的可执行文件路径加入系统环境变量。</p>
<p>node.js官方网站： <a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p>
<ul>
<li>对于Windows用户，从上述链接中下载exe格式的安装包，并按照提示完成安装即可。</li>
<li>对于macOS用户，除了使用上述链接中提供的pkg格式的安装包外，还可以使用homebrew包管理器进行安装： <code>brew install node</code> 。</li>
<li>对于Linux用户，可以在 <a href="https://nodejs.org/en/download/package-manager">“Installing Node.js via package manager”</a> 文档中寻找特定发行版对应的安装指令，也可以从上述链接中下载tar.gz格式的源代码包从头编译（但不建议这么做）。</li>
</ul>
<p>使用指令<code>node -v</code>和<code>npm -v</code>测试node.js安装结果，如果顺利输出版本号（例如下面这样），则表明安装成功。 （“npm之于JavaScript，就如pip和conda之于python程序”）</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cyclin@desktop:~$ node -v</span><br><span class="line">v18.9.0</span><br><span class="line">cyclin@desktop:~$ npm -v</span><br><span class="line">8.19.1</span><br></pre></td></tr></table></figure>

<h3 id="（二）安装PicGo-core"><a href="#（二）安装PicGo-core" class="headerlink" title="（二）安装PicGo-core"></a>（二）安装PicGo-core</h3><p>下一步，使用指令安装PicoGo-core：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install picgo -g</span><br></pre></td></tr></table></figure>

<p>使用 <code>picgo --version</code>检查安装结果。如果输出了对应的版本号（例如1.5.6），则表明安装成功。</p>
<p>PicGO-core支持的图床有很多，但是需要配置账号。这里参考官方文档的说明（网址： <a href="https://picgo.github.io/PicGo-Core-Doc/zh/guide/config.html">https://picgo.github.io/PicGo-Core-Doc/zh/guide/config.html</a> ）</p>
<p>使用<code>picgo set uploader</code>指令可以进入一个交互式的设置界面，按照提示一步一步填写腾讯云存储服务的APPID、secretID等信息，即可完成配置。腾讯云存储服务的这些ID可以在账户设置的API密钥管理页面中新建（ <a href="https://console.cloud.tencent.com/cam/capi">https://console.cloud.tencent.com/cam/capi</a> ），记得新建密钥后记录一下APPID、SecretId和SecretKey三个信息。存储桶信息（bucket）可以在存储桶列表（ <a href="https://console.cloud.tencent.com/cos/bucket">https://console.cloud.tencent.com/cos/bucket</a> ）中查询，如果这里没有存储桶的话可以新建一个。其他信息可以参考 <a href="https://zhuanlan.zhihu.com/p/565218725">https://zhuanlan.zhihu.com/p/565218725</a> 这篇文章的设置。</p>
<p>picGO-core的默认配置文件存储路径如下</p>
<ul>
<li>picgo 的默认配置文件为 <code>~/.picgo/config.json</code> 。其中 <code>~</code> 为用户目录。不同系统的用户目录不太一样。</li>
<li>linux 和 macOS 均为 <code>~/.picgo/config.json</code> 。</li>
<li>windows 则为 <code>C:\Users\你的用户名\.picgo\config.json</code> 。</li>
</ul>
<p>如果在完成上述设置以后，对配置文件还需要修改，可以访问上述路径下的<code>config.json</code>文件进行手动修改。</p>
<p>接下来，我们可以在terminal中上传一张图片测试一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">picgo upload test.png <span class="comment"># test.png换成任何一张测试图片的名称都行，但必须在当前目录中真实存在</span></span><br></pre></td></tr></table></figure>

<p>如果收到<code>[PicGo SUCCESS]</code>的标签，则表明上传成功。此外，还可以检查腾讯云下面的存储桶文件列表，看一看这张图片是否正确上传。</p>
<h2 id="四、Image-auto-upload-plugin插件配置"><a href="#四、Image-auto-upload-plugin插件配置" class="headerlink" title="四、Image auto upload plugin插件配置"></a>四、Image auto upload plugin插件配置</h2><p>如下图。将默认上传器设置为picGO-core，然后填写picGO-core path即可（可以在terminal中用<code>which picgo</code>指令获得picGO-core的path）<br>其他项目使用默认设置即可。</p>
<p><img src="https://pic.imgdb.cn/item/656c7c36c458853aef80ac0d.jpg" alt="config panel 2"></p>
<p>如果插件无法上传图片，尝试关闭obsidian主程序并重启。一般来说重启后上传功能就能正常。<br>如果依然有问题，可以尝试打开obsidian软件的开发工具（dev Tools），并查询console输出以定位问题。</p>
<ul>
<li>devtools打开方式：<ul>
<li>Linux and Windows: <code>Ctrl + Shift + I</code></li>
<li>macOS: <code>cmd+ option + i</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>obsidian探索小记</tag>
        <tag>图片自动上传</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>python解决开盲盒问题</title>
    <url>/2023/12/01/python%E8%A7%A3%E5%86%B3%E5%BC%80%E7%9B%B2%E7%9B%92%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>这个问题是某天我们年级的一位同学提出的，感觉很有意思，就在这里记录一下。</p>
<p>本题算是数学方法应用在生活中的一个小例子了。</p>
<span id="more"></span>

<h2 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h2><p>开盲盒问题：现在有 12 个盒子，里面分别装了物品A-L。每个盒子都装有一个物品；每个物品都装在一个盒子中。</p>
<p>在开盲盒之前，有一次透视机会，可以知道其中任意一个盒子里是什么（例如开了 3 号盒子可以得知里面是物品 C）。</p>
<p>现在每个盒子有3次提示的机会，提示内容分别是“该盒子中不是 X”（X是物品编号），同一个盒子中的3次提示内容不会重复，但盒子之间的提示是会重复的。此外，还有额外的6次机会，可以随机选 6个盒子，得到第四条提示。</p>
<p>例如：目前开了1个盒子，并对另外两个盒子的物品进行了提示，情况如下：</p>
<table>
<thead>
<tr>
<th>盒子编号</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
</tr>
</thead>
<tbody><tr>
<td>第一次提示</td>
<td>非 A</td>
<td>非 A</td>
<td>是 C</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>第二次提示</td>
<td>非 B</td>
<td>非 D</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>第三次提示</td>
<td>非 C</td>
<td>非 E</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>额外的提示</td>
<td>非 K</td>
<td>非 L</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>编写程序，当输入所有已知条件时，输出物品A-L在每个盒子里的概率。</p>
<h2 id="二、思路与代码"><a href="#二、思路与代码" class="headerlink" title="二、思路与代码"></a>二、思路与代码</h2><h3 id="（一）物品位置状态表的获取"><a href="#（一）物品位置状态表的获取" class="headerlink" title="（一）物品位置状态表的获取"></a>（一）物品位置状态表的获取</h3><p>题干中的表格给了我们很大的提示，我们也可以建立一张表来展示各个物品在不同盒子中的概率。如下表所示，我们建立了一个12x12的状态表，其中每一行代表一个物品（A-L对应第0-11行），每一列代表一个盒子（1-12号盒子对应第0-11列）。</p>
<p>我们定义数字 1代表物品可能在盒子中，0代表物品不可能在盒子中。因此根据题目已知条件，这样的表格如下：</p>
<table>
<thead>
<tr>
<th>盒子编号</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>B</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>C</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>D</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>E</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>F</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>G</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>H</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>I</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>J</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>K</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>L</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>通过代码得到上面的表格并不难，即使输入条件有变化，我们也可以根据输入条件的不同进行改变。</p>
<p>下面是我们的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立一个12x12的状态表</span></span><br><span class="line"><span class="comment"># 每一行代表一个物品（A-L对应第0-11行）</span></span><br><span class="line"><span class="comment"># 每一列代表一个盒子（1-12号盒子对应第0-11列）</span></span><br><span class="line"><span class="comment"># 1代表物品可能在盒子中，0代表物品不可能在盒子中</span></span><br><span class="line">status_table = np.ones([<span class="number">12</span>,<span class="number">12</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#print(status_table)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在一次透视机会中看到的盒子与内容</span></span><br><span class="line"><span class="comment">#----------------------------------#</span></span><br><span class="line"><span class="comment"># 此处根据看到的具体情况进行赋值   #</span></span><br><span class="line"><span class="comment">#----------------------------------#</span></span><br><span class="line">inspect_box  = <span class="number">2</span> <span class="comment"># 3号盒子对应的列下标</span></span><br><span class="line">inspect_item = <span class="number">2</span> <span class="comment"># 物品C对应的行下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新状态表</span></span><br><span class="line">status_table[inspect_item,:] = <span class="number">0</span> <span class="comment"># 这个物品在其他盒子中不可能出现，因此状态赋值为0</span></span><br><span class="line">status_table[:,inspect_box]  = <span class="number">0</span> <span class="comment"># 这个盒子中也不会有其他物品，因此状态赋值为0</span></span><br><span class="line">status_table[inspect_item,inspect_box] = <span class="number">1</span> <span class="comment"># 只有这个物品一定存在，因此赋值为1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过对其他盒子的提示（包括6次额外机会），得到的提示内容</span></span><br><span class="line"><span class="comment">#----------------------------------#</span></span><br><span class="line"><span class="comment"># 此处根据看到的具体情况进行赋值   #</span></span><br><span class="line"><span class="comment">#----------------------------------#</span></span><br><span class="line">tips_table=[</span><br><span class="line">        [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>], <span class="comment"># 1号盒子中不可能出现的物品下标</span></span><br><span class="line">        [<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">11</span>], <span class="comment"># 2号盒子中不可能出现的物品下标</span></span><br><span class="line">        [], <span class="comment"># 3号盒子中不可能出现的物品下标</span></span><br><span class="line">        [], <span class="comment"># 4号盒子中不可能出现的物品下标</span></span><br><span class="line">        [], <span class="comment"># 5号盒子中不可能出现的物品下标</span></span><br><span class="line">        [], <span class="comment"># 6号盒子中不可能出现的物品下标</span></span><br><span class="line">        [], <span class="comment"># 7号盒子中不可能出现的物品下标</span></span><br><span class="line">        [], <span class="comment"># 8号盒子中不可能出现的物品下标</span></span><br><span class="line">        [], <span class="comment"># 9号盒子中不可能出现的物品下标</span></span><br><span class="line">        [], <span class="comment"># 10号盒子中不可能出现的物品下标</span></span><br><span class="line">        [], <span class="comment"># 11号盒子中不可能出现的物品下标</span></span><br><span class="line">        [], <span class="comment"># 12号盒子中不可能出现的物品下标</span></span><br><span class="line">        ]</span><br><span class="line"><span class="comment"># 更新状态表</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    <span class="comment"># i 是盒子的下标。</span></span><br><span class="line">    <span class="comment"># 下面读取tips_table，获取盒子中不可能出现的物品下标</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> tips_table[i]:</span><br><span class="line">        <span class="comment"># 更新状态表</span></span><br><span class="line">        status_table[j][i] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印状态表</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;状态表=&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(status_table)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印每个物品可能出现的盒子编号（盒子编号=盒子下标+1）</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    status_array = status_table[i]</span><br><span class="line">    boxes = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(status_array)):</span><br><span class="line">        <span class="keyword">if</span>(status_array[j]==<span class="number">1</span>):boxes.append(j+<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;物品&#123;&#125;可能出现在盒子&#123;&#125;中&quot;</span>.<span class="built_in">format</span>(<span class="built_in">chr</span>(i+<span class="number">65</span>),boxes))</span><br></pre></td></tr></table></figure>

<p>输入条件在代码的 <code>inspect_box</code>, <code>inspect_item</code>, <code>tips_table</code> 三个变量中定义（见上述代码“此处根据看到的具体情况进行赋值”的提示语句）。</p>
<ul>
<li><code>inspect_box</code> ： 在一次透视机会中，查看的盒子的下标。盒子的下标等于盒子编号减1。</li>
<li><code>inspect_item</code> ：在一次透视机会中，看到的物品的下标。物品编号A-L分别对应物品下标0-11。</li>
<li><code>tips_table</code> ：通过每个盒子的3次提示机会，和6次随机盒子的提示机会，得到的所有信息。这些信息按二维数组进行组织（见代码），其中外层数组的下标对应盒子下标，内层数组的元素代表不会出现的物品的下标。内层数组可以是空数组。</li>
</ul>
<h3 id="（二）概率值的计算"><a href="#（二）概率值的计算" class="headerlink" title="（二）概率值的计算"></a>（二）概率值的计算</h3><p>上面得到的仅仅是一个状态表。我们需要知道每个物品出现在各个盒子中的概率。而这个概率，可以用线性规划的方法解出来。</p>
<p>具体来说，当我们把12x12的状态表变成12x12的概率表以后，表格中的每个格子就变成了对应物品在对应盒子中出现的概率。一共144个格子（144个待求解概率），因此线性规划的变量个数为144个。</p>
<p>除此之外，我们需要明确两点事实：</p>
<ul>
<li>任意一个盒子中，各个物品出现概率的总和为1。（也就是说对于一个特定的盒子，从物品A到物品L，不论每个物品各自出现的概率有多大，这些物品出现概率的总和一定是1）</li>
<li>任意一个物品，出现在每个盒子中的概率的总和为1。（也就是说对于一个特定物品，它在盒子1到盒子12中出现的概率值加在一起也是1）</li>
</ul>
<p>放到12x12的概率表上，就是这个概率表的每一行的元素总和全为1，每一列的元素总和也全为1。由此可以得到12×12=24个约束条件函数。</p>
<p>此外，每个变量也有自己的边界条件。概率的取值范围为 $\in[0,1]$ ，然而对于不可能出现的物品来说，概率值一定为0。这是另外144个条件。</p>
<p>我们的目标函数是概率总和最大；然而对于这个问题来说，目标函数是什么其实无所谓，因为上面的这些约束条件足以求出我们所要的结果。</p>
<p>求解线性规划问题的方法有很多，此处我们使用scipy进行求解</p>
<blockquote>
<p>参考： <a href="https://wz.anoms.top/2022/09/29/%E4%BD%BF%E7%94%A8python%E5%92%8Cscipy%E8%A7%A3%E5%86%B3%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/">使用Python和SciPy解决线性规划问题</a></p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这段代码需要接在上面那段代码的后面</span></span><br><span class="line"><span class="comment"># 因为需要用到status_table这个变量，以确定概率值的边界条件</span></span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linprog</span><br><span class="line">c = -np.ones(<span class="number">144</span>) <span class="comment"># 目标函数的系数向量。总共144个变量（12x12），因此向量长度为144.</span></span><br><span class="line">A_eq = [] <span class="comment"># 等式约束条件的系数矩阵。下面对这个系数矩阵进行赋值</span></span><br><span class="line"><span class="comment"># 矩阵每行的概率总和均为1，总共12个方程</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    a_eq = np.zeros(<span class="number">144</span>)</span><br><span class="line">    a_eq[i*<span class="number">12</span>:(i+<span class="number">1</span>)*<span class="number">12</span>]=<span class="number">1</span></span><br><span class="line">    A_eq.append(a_eq)</span><br><span class="line"><span class="comment"># 矩阵每列的概率总和均为1，总共12个方程</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    a_eq = np.zeros(<span class="number">144</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>): a_eq[i*<span class="number">12</span>+j]=<span class="number">1</span></span><br><span class="line">    A_eq.append(a_eq)</span><br><span class="line">B_eq = np.ones(<span class="number">24</span>) <span class="comment"># 等式约束条件的常数项。总共24个方程，因此向量长度为24</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 变量的边界条件</span></span><br><span class="line"><span class="comment"># 其中，状态表的状态值=0的位置，对应边界条件为p=0</span></span><br><span class="line"><span class="comment"># 除此之外的位置，边界条件为 p ∈ (0,1]</span></span><br><span class="line">p0 = (<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">p1 = (<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">bounds = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">        <span class="keyword">if</span>(status_table[i][j]==<span class="number">0</span>):</span><br><span class="line">            bounds.append(p0)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            bounds.append(p1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算线性规划的结果</span></span><br><span class="line">result = linprog(c,A_eq=A_eq,b_eq=B_eq,bounds=bounds)</span><br><span class="line">x = np.array(result.x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Prob table=&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\t&quot;</span>.join([<span class="string">&quot;Item&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;10&quot;</span>,<span class="string">&quot;11&quot;</span>,<span class="string">&quot;12&quot;</span>]))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">65</span>+i),end=<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%.4f&quot;</span>%x[i*<span class="number">12</span>+j],end=<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>

<h2 id="三、代码输出："><a href="#三、代码输出：" class="headerlink" title="三、代码输出："></a>三、代码输出：</h2><p>全部的代码输出如下，其中程序首先输出了12×12状态表，并打印出各个物品可能出现在哪些盒子中，最后输出了12×12的概率表，从概率表中我们可以选择每个物品出现概率最大的盒子，以确定要开哪一个盲盒。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">状态表=</span><br><span class="line">[[0. 0. 0. 1. 1. 1. 1. 1. 1. 1. 1. 1.]</span><br><span class="line"> [0. 1. 0. 1. 1. 1. 1. 1. 1. 1. 1. 1.]</span><br><span class="line"> [0. 0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0.]</span><br><span class="line"> [1. 0. 0. 1. 1. 1. 1. 1. 1. 1. 1. 1.]</span><br><span class="line"> [1. 0. 0. 1. 1. 1. 1. 1. 1. 1. 1. 1.]</span><br><span class="line"> [1. 1. 0. 1. 1. 1. 1. 1. 1. 1. 1. 1.]</span><br><span class="line"> [1. 1. 0. 1. 1. 1. 1. 1. 1. 1. 1. 1.]</span><br><span class="line"> [1. 1. 0. 1. 1. 1. 1. 1. 1. 1. 1. 1.]</span><br><span class="line"> [1. 1. 0. 1. 1. 1. 1. 1. 1. 1. 1. 1.]</span><br><span class="line"> [1. 1. 0. 1. 1. 1. 1. 1. 1. 1. 1. 1.]</span><br><span class="line"> [0. 1. 0. 1. 1. 1. 1. 1. 1. 1. 1. 1.]</span><br><span class="line"> [1. 0. 0. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]</span><br><span class="line">物品A可能出现在盒子[4, 5, 6, 7, 8, 9, 10, 11, 12]中</span><br><span class="line">物品B可能出现在盒子[2, 4, 5, 6, 7, 8, 9, 10, 11, 12]中</span><br><span class="line">物品C可能出现在盒子[3]中</span><br><span class="line">物品D可能出现在盒子[1, 4, 5, 6, 7, 8, 9, 10, 11, 12]中</span><br><span class="line">物品E可能出现在盒子[1, 4, 5, 6, 7, 8, 9, 10, 11, 12]中</span><br><span class="line">物品F可能出现在盒子[1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12]中</span><br><span class="line">物品G可能出现在盒子[1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12]中</span><br><span class="line">物品H可能出现在盒子[1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12]中</span><br><span class="line">物品I可能出现在盒子[1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12]中</span><br><span class="line">物品J可能出现在盒子[1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12]中</span><br><span class="line">物品K可能出现在盒子[2, 4, 5, 6, 7, 8, 9, 10, 11, 12]中</span><br><span class="line">物品L可能出现在盒子[1, 4, 5, 6, 7, 8, 9, 10, 11, 12]中</span><br><span class="line">D:\linux\py\开盲盒问题.py:128: OptimizeWarning: A_eq does not appear to be of full row rank. To improve performance, check the problem formulation for redundant equality constraints.</span><br><span class="line">  result = linprog(c,A_eq=A_eq,b_eq=B_eq,bounds=bounds)</span><br><span class="line">Prob table=</span><br><span class="line">Item    1       2       3       4       5       6       7       8       9       10      11      12</span><br><span class="line">A       0.0000  0.0000  0.0000  0.1111  0.1111  0.1111  0.1111  0.1111  0.1111  0.1111  0.1111  0.1111</span><br><span class="line">B       0.0000  0.1563  0.0000  0.0937  0.0937  0.0937  0.0937  0.0937  0.0937  0.0937  0.0937  0.0937</span><br><span class="line">C       0.0000  0.0000  1.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000</span><br><span class="line">D       0.1371  0.0000  0.0000  0.0959  0.0959  0.0959  0.0959  0.0959  0.0959  0.0959  0.0959  0.0959</span><br><span class="line">E       0.1371  0.0000  0.0000  0.0959  0.0959  0.0959  0.0959  0.0959  0.0959  0.0959  0.0959  0.0959</span><br><span class="line">F       0.1177  0.1375  0.0000  0.0828  0.0828  0.0828  0.0828  0.0828  0.0828  0.0828  0.0828  0.0828</span><br><span class="line">G       0.1177  0.1375  0.0000  0.0828  0.0828  0.0828  0.0828  0.0828  0.0828  0.0828  0.0828  0.0828</span><br><span class="line">H       0.1177  0.1375  0.0000  0.0828  0.0828  0.0828  0.0828  0.0828  0.0828  0.0828  0.0828  0.0828</span><br><span class="line">I       0.1177  0.1375  0.0000  0.0828  0.0828  0.0828  0.0828  0.0828  0.0828  0.0828  0.0828  0.0828</span><br><span class="line">J       0.1177  0.1375  0.0000  0.0828  0.0828  0.0828  0.0828  0.0828  0.0828  0.0828  0.0828  0.0828</span><br><span class="line">K       0.0000  0.1563  0.0000  0.0937  0.0937  0.0937  0.0937  0.0937  0.0937  0.0937  0.0937  0.0937</span><br><span class="line">L       0.1371  0.0000  0.0000  0.0959  0.0959  0.0959  0.0959  0.0959  0.0959  0.0959  0.0959  0.0959</span><br></pre></td></tr></table></figure>

<p>由于已知条件的限制，我们得到的概率表中不同盒子之间的概率差异还是有点小，不足以判断一个物品最有可能出现在哪个盒子中。当已知条件足够多（例如使用完全部36次提示机会和6次额外机会），则得到的概率值会更加精确。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>python</tag>
        <tag>线性规划</tag>
        <tag>生活小妙招</tag>
      </tags>
  </entry>
  <entry>
    <title>再谈爱情（七夕节限定版）</title>
    <url>/2023/08/22/qixi-diary/</url>
    <content><![CDATA[<p>七夕。</p>
<p>下午下起了雨，从哗啦哗啦到淅淅沥沥，这会儿雨停了，外面依然有点阴，看不到月亮和星光。</p>
<span id="more"></span>

<p>今天晚上不知怎的，晚饭后大家就不约而同的消失不见了，只留下我一个人在办公室，查资料，刷网页，发呆，实在是有些孤独寂寥。此刻不比IBP，那时的课题组很热闹，即使周末还可以和邹承鲁班的许多同学在一起。离开中学时代后，鲜少有机会能在集体中收获温暖和爱，一如在IBP所经历过的那些一样。</p>
<p>刚刚过去的一周没有太多事值得记录。周间写了点代码，准备了组会PPT却没能得到机会展示。周六骑车出了趟远门，去了杨浦公园和共青国家森林公园，拍了不少照片。周日看完《乡土中国》，对费孝通那个时代的中国基层社会的理解加深了一层——然而今日可能不同于往日，传统家族结构在现代化社会的冲击下分崩离析，也许书中的一些内容并不适用于现代社会了吧。</p>
<p>最近对恋爱的态度似乎又出现了摇摆。今天朋友圈秀恩爱的同学有不少，路上的情侣似乎也变多了。而我，依然如同很多年前那样，简单而平等地羡慕他们中的每一对人。这几天的微信推送似乎也开启了粉红泡泡模式，采访完年轻人的爱情又去采访父母辈的爱情，更有一些文章手把手教你如何谈恋爱。</p>
<p>朋友圈里，某位同学转发了环球科学公众号的一篇文章，以参与植物光合作用的两种蛋白OCP1和FRP的角度出发，诠释什么是爱情。这篇文章虽然说得不是人与人之间的爱情，却更令人上头，读完之后只感觉嗑到了，突然又开始想谈恋爱。</p>
<blockquote>
<p><strong>Meeting you was like the ‘orange carotenoid protein 1’ (OCP1) meeting the ‘fluorescence recovery protein’ (FRP). 我遇见你，就像“橙色类胡萝卜素蛋白1”遇见“荧光恢复蛋白”。</strong></p>
<p>……</p>
<p>遇见你之前，我只是独自地活在这世上，在我该在的地方做着我该做的事。遇见你之后，我仍然在我该在的地方做着我该做的事，但世界却变了，因为你出现了</p>
<p>奇怪的是，即便之前我们从未相遇，我却总感觉有你在的世界，才是这个世界本来的样子，就好像世界本身缺了一块，而缺的那块刚好是你的形状。这个形状可能已经存在了几亿年甚至几十亿年，一直保持不变，因此遇见你的那一刻，我立即就知道这个世界终于完整了</p>
<p>—— <a href="https://mp.weixin.qq.com/s/RV5-OB3dQSk0LL06LTSodA">《赶在七夕到来前，教你一句最浪漫的情话》</a> by <em>环球科学</em></p>
</blockquote>
<p>什么是爱情呢？这个问题的回答在不同阶段可能有不同理解。然而早在上高中时，早在意识到自己似乎有喜欢的人时，可能我就有自己的答案了——</p>
<p>你知道对方，知道对方心里想着你，此时你也在心里想着对方。你们可能过去的经历不同，彼此性格迥异，但是一见面，倾盖如故，你们两个人的性格互补的恰到好处。你们知道对方在想什么，知道对方下一步要做什么，你们日常的互动都洋溢着喜欢和爱，再平凡的生活都能过得有趣而充满爱意……</p>
<p>——至少那时我以为，真正的爱情应该这样，也必然能够达到这样。也许青春萌动的孩子心中，对爱情的理解就是这么单纯而无瑕的吧。后面经历的多了，在网上看到的事情也多了，渐渐怀疑这个世界上是否真的有爱情。但是一直会有喜欢的人，ta们身上有些闪闪发光的点真的会让涉世未深的小男孩的心触动一下，再触动一下……最后产生一种不知道是崇拜景仰还是喜欢的复杂感情。但是真的，在一些事情之后，真的就不再相信爱情了。</p>
<p>可是，爱情的存在与否，完全不以人的意志为转移。就算从概率角度分析，古往今来上千年的历史中，涌现出的爱情故事也是个巨大无比的数字。或许真正的爱情是存在的，只是ta的概率很低，只有足够努力足够幸运，才能碰到那样的爱情。</p>
<p><strong>真正</strong> 的爱情会是什么样子呢？没 <strong>真正</strong> 经历过的人只能自己想象。但应该不太可能是上面那种高中时期做白日梦时期待的爱情模样。成年人的世界里没有太多浪漫，生活的压力和世道的艰难会为人的生活带来许多挑战，而爱情，更应该是能够联合两个人的力量，去对抗风险，去携手提高生活质量的港湾。这听起来不如白日梦中的爱情浪漫，可是携手对抗生活的风险、共同迈向更好的生活，这难道不是另一种浪漫吗？</p>
<p>高中时看的课外书少，很多文学素材是从考试卷上获得的。那时候特别喜欢2016年山东高考卷的阅读题文章——文章开头是这样的：“天气晴朗，蓝天白云的，一眼望去很惬意。你眼中的世界实际是你心理的投射。吴秋明如果在旁边肯定会这样说的。马骁驭不禁莞尔一笑”。当时经常把这篇文章拿在手边反复读，故事中的男主和女主是理想爱情中的模样。大学后买来了《琴声何来》纸质书，看完了整篇故事，才明白主人公所经历的，不过是无数场爱情悲剧中的一场，而高考试卷节选的一段是小说中为数不多的温情时段。多希望结局是两个人最终走到了一起。可是悲剧也有悲剧的美，不是吗？</p>
<p>临睡前又刷了一遍朋友圈，发现和大学时相比，自己的圈子里脱单的人似乎更多了。一边是祝福，一边是羡慕和柠檬，单身狗在这一天的心情实在是矛盾重重。虽然，现在更担心的是，我是否还有爱别人的能力？希望爱情之神还能眷顾依然单身的我，希望我还有能力接受爱和爱别人，希望我所爱的人和爱我的人都平安幸福。</p>
]]></content>
      <categories>
        <category>杂思</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
        <tag>爱情</tag>
        <tag>七夕节</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu-port 22.0.4 安装rstudio-server的一些探索</title>
    <url>/2023/03/15/ubuntu-port-22-0-4-%E5%AE%89%E8%A3%85rstudio-server%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A2%E7%B4%A2/</url>
    <content><![CDATA[<p>背景：想在平板电脑上原生运行<a href="https://cran.r-project.org/">R</a>和<a href="https://posit.co/">Rstudio</a>。前者是一个用于统计分析和作图的编程语言，后者是一个强大的代码编辑器和编程环境（IDE）。</p>
<span id="more"></span>

<p>博主的平板电脑是安卓系统的，有<a href="https://termux.dev/en/">Termux</a>这一软件可以实现对Linux终端的模拟（下载地址：<a href="https://f-droid.org/en/packages/com.termux/">https://f-droid.org/en/packages/com.termux/</a> ）。由于这个模拟器并不是真正的Linux环境，因此许多软件并不能正常运行。幸运的是，在这一终端模拟器上，还有软件包<a href="https://github.com/termux/proot-distro">proot-distro</a> 可以安装Linux子系统（如ubuntu-port），因此我们借助<a href="https://github.com/termux/proot-distro">proot-distro</a>在安卓平板上安装了ubuntu-port 22.0.4的系统，并成功安装<a href="https://anaconda.org/">miniconda</a>。</p>
<p>有了ubuntu-port 22.0.4的系统和miniconda，安装R和Rstudio变得简单了一些。首先，我们安装了R，过程大致参考了许多网上教程，如 <a href="https://www.plob.org/article/24073.html">《如何使用conda安装R和R包》</a>、<a href="https://www.jianshu.com/p/2e1986296e15">《conda 安装R语言及其R包》</a> 等_（现已成功安装，可以通过命令行界面访问R）_。这之后，需要安装Rstudio。本文主要讲的是安装Rstudio时的一些探索。</p>
<p>注意到，Linux终端只有命令行界面，因此安装本地版Rstudio不太可能。我们要做的是安装Rstudio-server，然后通过平板上安装的浏览器对其进行访问。</p>
<h2 id="1、安装包下载地址："><a href="#1、安装包下载地址：" class="headerlink" title="1、安装包下载地址："></a>1、安装包下载地址：</h2><p>参考下列文档。Rstudio-server目前的官方版本只有x86和amd64的包，但是其beta版中有针对arm64编译的版本。</p>
<p><a href="https://dailies.rstudio.com/rstudio/elsbeth-geranium/server/bionic-arm64/">https://dailies.rstudio.com/rstudio/elsbeth-geranium/server/bionic-arm64/</a></p>
<p>我们采用文章中给出的链接进行安装包下载，指令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -c https://s3.amazonaws.com/rstudio-ide-build/server/bionic/arm64/rstudio-server-2022.12.1-366-arm64.deb</span><br></pre></td></tr></table></figure>

<h2 id="2、安装gdebi"><a href="#2、安装gdebi" class="headerlink" title="2、安装gdebi"></a>2、安装gdebi</h2><p>参考<a href="https://posit.co/download/rstudio-server/">官方教程</a>，我们运行下列指令安装gdebi，这是一个安装器，后面将用于rstudio-server的安装。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gdebi-core</span><br></pre></td></tr></table></figure>

<h2 id="3、安装rstudio-server"><a href="#3、安装rstudio-server" class="headerlink" title="3、安装rstudio-server"></a>3、安装rstudio-server</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gdebi rstudio-server-2022.12.1-366-arm64.deb</span><br></pre></td></tr></table></figure>

<p>在ubuntu-port 22.0.4 系统上，安装rstudio-server时可能会出现找不到libssl1.0的问题（ <code>dependency is not satisfiable: libssl 1.0.0libssl1.0.2libssl 1.1</code> ）。对于这种情况，可以手动安装对应软件包 （见第4小节）</p>
<h2 id="4、（对于“找不到libssl1-0”问题的改进）手动安装libssl1-0"><a href="#4、（对于“找不到libssl1-0”问题的改进）手动安装libssl1-0" class="headerlink" title="4、（对于“找不到libssl1.0”问题的改进）手动安装libssl1.0"></a>4、（对于“找不到libssl1.0”问题的改进）手动安装libssl1.0</h2><p>如果安装过程中<strong>没有</strong>出现“找不到libssl1.0”的问题，则可以跳过这一部分，直接进入第5小节。</p>
<h3 id="4-1、下载"><a href="#4-1、下载" class="headerlink" title="4.1、下载"></a>4.1、下载</h3><p>libssl1.1自ubuntu18.04之后就从仓库中移除了。因此只能进行手动安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -c https://mirrors.aliyun.com/ubuntu-ports/pool/main/o/openssl/libssl1.1_1.1.1-1ubuntu2.1~18.04.21_arm64.deb</span><br></pre></td></tr></table></figure>

<p>上述链接中的版本号截止到2023年3月，在此之后openssl1.1可能还会有更新，因此下载对应版本号的软件包即可。</p>
<h3 id="4-2、安装"><a href="#4-2、安装" class="headerlink" title="4.2、安装"></a>4.2、安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gdebi install libssl1.1_1.1.1-1ubuntu2.1~18.04.21_arm64.deb</span><br></pre></td></tr></table></figure>

<h3 id="4-3、rstudio-server安装"><a href="#4-3、rstudio-server安装" class="headerlink" title="4.3、rstudio-server安装"></a>4.3、rstudio-server安装</h3><p>参见第3小节。</p>
<h2 id="5、rstudio-server配置"><a href="#5、rstudio-server配置" class="headerlink" title="5、rstudio-server配置"></a>5、rstudio-server配置</h2><p>Rstudio-server的配置文件保存在 <code>/etc/rstudio/</code> 下面。我们需要修改几个文件以便于服务器运行。</p>
<ol>
<li> <code>env-vars</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># set virtual environment for Rstudio server.</span><br><span class="line">PATH=/home/cyclin/wsl/anaconda3/envs/R/bin:/home/cyclin/wsl/anaconda3/condabin:$PATH</span><br></pre></td></tr></table></figure>

<p>上面列出的是我自己的配置，实际安装过程中需要将R及Rscript对应的安装路径加入到<code>PATH</code>变量中。</p>
<ol start="2">
<li> <code>rserver.conf</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Server Configuration File# 更改RStudio-server使用的R版本</span><br><span class="line">rsession-which-r=/home/cyclin/wsl/anaconda3/envs/R/bin/R</span><br></pre></td></tr></table></figure>

<p>上面列出的是我自己的配置，实际安装过程中需要将R及Rscript对应的安装路径加入到<code>rsession-which-r</code>变量中。</p>
<ol start="3">
<li> <code>rsession.conf</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 超时设定(单位：分钟)</span><br><span class="line">session-timeout-minutes=30</span><br><span class="line"></span><br><span class="line"># 更改R包安装地址</span><br><span class="line">r-libs-user=/home/cyclin/wsl/anaconda3/envs/R/lib/R/library</span><br></pre></td></tr></table></figure>

<p>上面列出的是我自己的配置，实际安装过程中需要将R的library对应的存储路径加入到<code>r-libs-user</code>变量中。</p>
<h2 id="6、启动与停止"><a href="#6、启动与停止" class="headerlink" title="6、启动与停止"></a>6、启动与停止</h2><ol>
<li> 启动</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo rstudio-server start</span><br><span class="line"># 或者</span><br><span class="line">sudo service rstudio-server start</span><br></pre></td></tr></table></figure>

<p>启动以后，在浏览器中访问 <code>http://localhost:8787</code> 即可使用Rstudio-server。【但是我没有走到这里，安装过程中的一些错误把我卡住了。】</p>
<ol start="2">
<li> 停止</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo rstudio-server stop</span><br><span class="line"># 或者</span><br><span class="line">sudo service rstudio-server stop</span><br></pre></td></tr></table></figure>

<h2 id="7-仍然没有解决的问题"><a href="#7-仍然没有解决的问题" class="headerlink" title="7. 仍然没有解决的问题"></a>7. 仍然没有解决的问题</h2><p>上述安装流程在PC端是没有问题的（系统是ubuntu 22LTS，以WSL1的形式运行于win11上）。但是在matepad上存在下列问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2023-03-15T13:06:50.037293Z [rserver] ERROR system error 1 (Operation not permitted); OCCURRED AT rstudio::core::Error rstudio::core::system::setResourceLimit(rstudio::core::system::ResourceLimit, RLimitType, RLimitType) src/cpp/core/system/PosixSystem.cpp:1568; LOGGED FROM: int main(int, char* const*) src/cpp/server/ServerMain.cpp:647</span><br></pre></td></tr></table></figure>

<p>暂时没有找到这一问题的解决方法。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>Rstudio</tag>
        <tag>瞎折腾</tag>
      </tags>
  </entry>
  <entry>
    <title>在博客系统中配置giscus评论系统</title>
    <url>/2023/05/10/use-giscus-as-comment-system/</url>
    <content><![CDATA[<p><a href="https://giscus.app/">giscus</a> 是一款基于Github discussion的博客评论系统</p>
<span id="more"></span>

<p>本文简要介绍如何安装。</p>
<h2 id="1-创建存储库"><a href="#1-创建存储库" class="headerlink" title="1. 创建存储库"></a>1. 创建存储库</h2><p>giscus基于GitHub discussion进行评论的整合与管理，因此一个开启了GitHub discussion功能的公共存储库必不可少。</p>
<p>我们可以新建一个存储库，也可以使用现有的存储库，然后转到设置（setting），在 <code>Features</code> 栏中勾选 <code>Discussions</code> 。</p>
<h2 id="2-安装giscus-app"><a href="#2-安装giscus-app" class="headerlink" title="2. 安装giscus app"></a>2. 安装giscus app</h2><p>第二步，将 <a href="https://github.com/apps/giscus">giscus app</a> 安装到上面配置好的存储库中。这一步至关重要，因为要想使用giscus管理存储库中的评论，必须要有giscus app的存在。安装过程参考 <a href="https://giscus.app/zh-CN">官方文档</a> 和  <a href="https://github.com/apps/giscus">giscus app</a> 即可</p>
<h2 id="3-获得giscus控制代码。"><a href="#3-获得giscus控制代码。" class="headerlink" title="3. 获得giscus控制代码。"></a>3. 获得giscus控制代码。</h2><p>这一步同样在  <a href="https://giscus.app/zh-CN">官方文档</a> 页面完成，将上述配置好的仓库填入页面中的 “仓库：” 栏，然后选择 “页面 ↔️ discussion 映射关系” <em>（也可以不选，用默认选项）</em> ，选择“Discussion 分类”  <em>（也可以不选，用默认选项）</em> ，选择“特性” <em>（推荐把“将评论框放在评论上方”和“懒加载评论”选上）</em> ，选择“主题” <em>（也可以不选，用默认选项）</em> ，最后把“启用 giscus”里面的代码复制下来，备用。</p>
<h2 id="4-在hexo中开启giscus功能。"><a href="#4-在hexo中开启giscus功能。" class="headerlink" title="4. 在hexo中开启giscus功能。"></a>4. 在hexo中开启giscus功能。</h2><p>这一步略有点复杂，因为在我的NexT主题中原生不支持giscus。接下来我要分几步说明如何在NexT主题中开启giscus：</p>
<ol>
<li>安装 <a href="https://github.com/next-theme/hexo-next-giscus">hexo-next-giscus</a>。这是个NexT主题插件，用于提供giscus支持。安装方式如下：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-next-giscus --save</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在NexT主题配置文件中添加giscus配置</li>
</ol>
<p>参考  <a href="https://github.com/next-theme/hexo-next-giscus">hexo-next-giscus</a> 的说明。要修改的文件 <code>_config.yml</code> 一般位于 <code>[根目录]/node_modules/hexo-theme-next/_config.yml</code> 或者 <code>[根目录]/themes/next/_config.yml</code> ，我们使用代码编辑器打开，并向其中添加如下内容：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">giscus:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="comment"># Github repository name</span></span><br><span class="line">  <span class="attr">repo_id:</span> <span class="comment"># Github repository id</span></span><br><span class="line">  <span class="attr">category:</span> <span class="comment"># Github discussion category</span></span><br><span class="line">  <span class="attr">category_id:</span> <span class="comment"># Github discussion category id</span></span><br><span class="line">  <span class="comment"># Available values: pathname | url | title | og:title</span></span><br><span class="line">  <span class="attr">mapping:</span> <span class="string">pathname</span></span><br><span class="line">  <span class="comment"># Available values: 0 | 1</span></span><br><span class="line">  <span class="attr">reactions_enabled:</span> <span class="number">1</span></span><br><span class="line">   <span class="comment"># Available values: 0 | 1</span></span><br><span class="line">  <span class="attr">emit_metadata:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Available values: light | dark | dark_high_contrast | transparent_dark | preferred-color-scheme</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">light</span></span><br><span class="line">  <span class="comment"># Available values: en | zh-CN</span></span><br><span class="line">  <span class="attr">lang:</span> <span class="string">en</span></span><br><span class="line">  <span class="comment"># Place the comment box above the comments</span></span><br><span class="line">  <span class="attr">input_position:</span> <span class="string">bottom</span></span><br><span class="line">  <span class="comment"># Load the comments lazily</span></span><br><span class="line">  <span class="attr">loading:</span> <span class="string">lazy</span></span><br></pre></td></tr></table></figure>

<p>其中，<code># Github repository name</code> 等多个字符串需要参照前面第三步保存下来的giscus控制代码进行填写。这些字段的命名具有一致性，因此照着控制代码填写即可。</p>
<ol start="3">
<li>更新页面，测试效果</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g;hexo s</span><br></pre></td></tr></table></figure>

<p>以上。</p>
<p>PS： 之前博客系统的评论还在恢复中，不过快好了。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>VS Code配置远程服务器插件</title>
    <url>/2023/12/10/vscode%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>本文介绍了vscode代码编辑器配置远程服务器插件的方法。</p>
<span id="more"></span>


<h2 id="零、背景"><a href="#零、背景" class="headerlink" title="零、背景"></a>零、背景</h2><p>Visual Studio Code（简称vscode）是微软开发的一款极其强大的代码编辑器，其前身是微软团队为Azure云服务设计的web端代码编辑器 <a href="https://microsoft.github.io/monaco-editor/">monaco editor</a>  。vscode底层采用typescript语言编写，使用electron框架进行用户界面渲染。其速度快，跨平台能力强大，最重要的是由于其底层开发语言是web开发中常用的typescript，vscode对web开发和远程开发都有很好的支持。vscode支持windows、macOS、Linux三大主流桌面端操作系统。</p>
<p>在实验室的科研环境中，常见的一种场景是在远程服务器上运行代码。一种方法是在本地编写好代码后上传到服务器并运行，但这样相当麻烦。另一种方法则是使用代码编辑器的远程开发能力。</p>
<p>常见的代码编辑器如pycharm、visual studio、eclipse等都支持在远程设备上进行开发。然而这些编辑器要么需要付费订阅，要么并不是“通用”编辑器，例如专职开发.NET/C++的visual studio和专职开发java的eclipse对于实验室的日常科研任务（aka. 写python、R、matlab、shell等轻量化脚本语言）来说显得过于笨重。因此，轻巧且开源免费又支持远程开发的vscode就这样进入了我们的视野。</p>
<h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><p>1、vscode的安装：从<a href="https://code.visualstudio.com/Download">vscode官网</a> 下载适合自己系统的安装包，然后点击安装既可。<br>2、所需插件安装：打开vscode后，点击左侧插件市场，搜索插件名称并安装既可（如下图）。建议安装的插件有三个：</p>
<ul>
<li>Remote - SSH</li>
<li>Remote - SSH: Editing Configuration Files</li>
<li>Remote Explorer</li>
</ul>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231210213115.png" alt="image.png"></p>
<p>一般来说，安装完第一个插件（Remote - SSH）以后，另外两个插件也会自动安装。安装成功后，在本地已安装扩展列表中可以看到这几个插件，如下所示。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/5dd6bf333ff4682df5cac411a532dac.png" alt="5dd6bf333ff4682df5cac411a532dac.png"></p>
<h2 id="二、远程服务器配置与登录"><a href="#二、远程服务器配置与登录" class="headerlink" title="二、远程服务器配置与登录"></a>二、远程服务器配置与登录</h2><h3 id="（一）ssh登录配置"><a href="#（一）ssh登录配置" class="headerlink" title="（一）ssh登录配置"></a>（一）ssh登录配置</h3><p>如果之前已经配置过与服务器间的ssh登录，则可跳过这一小节。</p>
<p>这一步需要满足两个要求：</p>
<ol>
<li>远程服务器上安装了<code>sshd</code> 服务。（一般的实验室服务器都会装，所以基本上不用管）</li>
<li>本地电脑上安装了<code>ssh</code>服务。（一般来说，Windows10/11系统都自带了<code>ssh</code>服务；macOS和Linux基本都自带了<code>ssh</code>）</li>
</ol>
<ul>
<li>如果不确定的话可以打开命令行软件（windows prompt/powerShell/terminal/…），输入 <code>ssh</code> 这个指令，如果能输出类似于下图的usage信息，则说明<code>ssh</code>已安装。</li>
<li>如果windows系统的电脑上没有<code>ssh</code> ，可以参考以下教程安装<code>ssh</code>:<ul>
<li><a href="https://zhuanlan.zhihu.com/p/549810556">Windows7安装OpenSSH服务的步骤详解（亲测有效） - 华赛云的文章 - 知乎</a></li>
<li><a href="https://learn.microsoft.com/zh-cn/windows-server/administration/openssh/openssh_install_firstuse?tabs=gui">适用于windows的OpenSSH入门 - 微软官方文档</a></li>
</ul>
</li>
</ul>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231210215758.png" alt="image.png"></p>
<p>若要从当前电脑登录远程服务器，需要打开“终端”（或另一个 SSH 应用），然后键入：</p>
<p><code>ssh username@IP address</code></p>
<p>例如，如果用户名称为 steve，远程服务器的 IP 地址为 10.1.2.3，可以在另一台电脑上打开“终端”并键入：</p>
<p><code>ssh steve@10.1.2.3</code></p>
<p>一般来说，这时程序会提示输入登陆密码。输入的登陆密码是不可见的（也就是说，屏幕上不会有任何密码字符显示，即使密码已经输入）。当输入的密码是正确时，按下回车键，就可以看到成功登录远程服务器的提示了，如下图所示。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231210221411.png" alt="image.png"></p>
<p>除此之外，还可以在服务器上配置免密登录，省去每次登录都要输入密码的麻烦。免密登录的方法可以参考这篇文章： <a href="https://wz.anoms.top/2023/02/13/linux%E5%AE%A2%E6%88%B7%E6%9C%BA%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E9%85%8D%E7%BD%AE%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%EF%BC%88ssh%EF%BC%89/">《Linux客户机和服务器之间配置免密登录》</a> 。</p>
<h3 id="（二）vscode远程登陆插件配置"><a href="#（二）vscode远程登陆插件配置" class="headerlink" title="（二）vscode远程登陆插件配置"></a>（二）vscode远程登陆插件配置</h3><p>接下来，我们配置vscode上的远程登陆插件。</p>
<p>如下图，在安装完”Remote - SSH”插件以后，vscode左侧栏会出现一个远程资源浏览器的图标，这个图标将用于连接远程服务器。现在，我们点击这个图标，在 REMOTE EXPLORER 里面选择“Remotes (Tunnels/SSH)” 选项，从而切换到SSH登录模式。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231210214258.png" alt="image.png"></p>
<p>切换完的界面如下。由于此时我们没有添加任何远程服务器，左侧面板中远程服务器的列表是空的。现在点击左侧面板 <code>&gt; REMOTES (TUNNELS/SSH) &gt; SSH</code>  右边的加号“+”，会弹出一个对话框，要求输入登录远程服务器的ssh指令</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231210214619.png" alt="image.png"></p>
<p>在这里输入登录服务器的指令，包括用户名和服务器IP地址，如下。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231210214942.png" alt="image.png"></p>
<p>随后，vscode会要求用户作出选择，选择更新哪一个ssh配置文件。我们选第一个就好。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231210215030.png" alt="image.png"></p>
<p>这样就完成了配置。此时再看左侧的远程服务器资源管理面板，可以看到我们刚刚添加的服务器。如下图所示，此时如果我们想要连接到这台服务器上进行工作，直接点击服务器名称右侧的箭头符号“→”既可。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231210215055.png" alt="image.png"></p>
<p>第一次登录需要的时间可能会有点长，因为vscode会在服务器端安装一些资源，用来支持与本地客户端的通信（所有资源加在一起大约175M左右）。之后，vscode会弹出一个界面，要求选择一个文件夹作为工作目录，如下图所示。这里按照实际工作中的需求选择就行。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231210215144.png" alt="image.png"></p>
<p>有可能还会弹出下图这种提示，询问是否信任文件作者。服务器上能被我们访问到的基本都是我们自己的文件，这里选择信任（“Yes, I trust the authors”）既可。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231210215201.png" alt="image.png"></p>
<p>在这以后，我们就可以愉快的码字了。如下图，这里打开的是一个服务器端的文件，但是实际编辑体验就像本地文件一样。在vscode左侧还可以清晰的看到文件列表，从而高效的管理文件。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231210215257.png" alt="image.png"></p>
<p>值得一提的是，在左边的文件列表上点击右键，可以像在本地一样进行文件管理；此外还可以选择多个文件然后批量下载。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231210225424.png" alt="image.png"></p>
<h2 id="三、远程服务器上的插件推荐"><a href="#三、远程服务器上的插件推荐" class="headerlink" title="三、远程服务器上的插件推荐"></a>三、远程服务器上的插件推荐</h2><p>vscode不仅支持在本地安装插件，还支持在远程服务器上安装插件。这里介绍一些比较推荐的插件组合。</p>
<p>如下图，因为题主日常工作以Python语言和R语言为主，因此在远程服务器上安装的开发与调试插件有下面这几个：Pylance、Python、R、R Debugger。除此之外，日常工作中会产生一些svg格式的图片，因此安装了SVG插件，以方便直接浏览图片。（对于pdf格式的图片，vscode也提供了<code>vscode-pdf</code>插件用于文件预览，不过和SVG插件不同，<code>vscode-pdf</code>插件需要安装在本地客户端）</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231210225216.png" alt="image.png"></p>
<p>下面展示一下使用python插件运行代码的效果（代码窗口右侧有个小箭头“▷”，点击这个小箭头按钮就能一键运行代码）</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231210224533.png" alt="image.png"></p>
<p>vscode支持的编程语言还有很多，例如matlab、fortran等。这些编程语言都有对应的插件（如下图），这为我们在远程服务器上编写软件会带来很大的方便。</p>
<p>最重要的是，这些都是免费且开源的！</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231210225845.png" alt="image.png"></p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231210230108.png" alt="image.png"></p>
<p>以上。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>ssh</tag>
        <tag>nodejs</tag>
        <tag>vscode</tag>
        <tag>远程服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>windows下安装FLTK</title>
    <url>/2022/04/27/windows-install-fltk/</url>
    <content><![CDATA[<p>FLTK是一个C++ GUI组件库。通过这个组件库可以实现C++编写可视化应用。本文介绍如何将其安装到window上</p>
<span id="more"></span>

<p>FLTK是跨平台的。只不过相比于Linux和macOS平台，在Windows下安装很麻烦。</p>
<p>首先，需要有一个git bash，这个软件用于模拟Linux界面。</p>
<p>然后，需要有一个C++编译器。大一时我们都学习了visual studio C++，但是那个太臃肿了。我现在用的是MinGW-w64，这是一个GCC编译器在Windows下面的移植版。<a href="https://gcc.gnu.org/">点击此链接了解GCC编译器</a></p>
<p>编译：在GitBash中cd到FLTK的源代码目录（里面有个configure文件，我们需要用这个文件进行操作），然后使用下列指令编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./configure --prefix=&quot;/d/linux/gcc/fltk&quot; --build=x86_64-pc-mingw64 </span><br><span class="line">//--prefix参数指定安装位置，我这里指定的目录是D:\linux\gcc\fltk文件夹</span><br><span class="line">mingw32-make //使用这个指令进行安装。如果提示找不到指令，先检查有没有把MinGW的安装目录加入环境变量</span><br></pre></td></tr></table></figure>

<p>编译完成后，会在相同目录下生成若干文件和文件夹，其中test文件夹下面有官方提供的demo和源代码。</p>
<p>使用FLTK编译代码：<strong>fltk-config –compile file.cxx</strong></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>Windows系统使用技巧</tag>
        <tag>FLTK</tag>
      </tags>
  </entry>
  <entry>
    <title>win10开启sshd服务与配置nps内网穿透</title>
    <url>/2023/08/01/win10-sshd/</url>
    <content><![CDATA[<p>本文讲述了开启win10 sshd服务并配置内网穿透的方法。</p>
<span id="more"></span>

<h2 id="零、背景"><a href="#零、背景" class="headerlink" title="零、背景"></a>零、背景</h2><p>有一台内网环境下的win10主机上存储着一些重要数据和程序，要在外部网络环境下访问这些数据，除远程桌面外希望有其他方法。</p>
<h2 id="一、win10-sshd功能"><a href="#一、win10-sshd功能" class="headerlink" title="一、win10 sshd功能"></a>一、win10 sshd功能</h2><blockquote>
<p>参考：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/452890363">Windows系统开启Sshd Server服务 - zhihu</a></li>
<li><a href="https://learn.microsoft.com/zh-cn/windows-server/administration/openssh/openssh_server_configuration">适用于 Windows 10 1809 和 Windows Server 2019 的 OpenSSH 服务器配置</a></li>
<li><a href="https://github.com/PowerShell/Win32-OpenSSH/wiki/sshd_config">Win32-OpenSSH sshd_config - github wiki</a></li>
</ul>
</blockquote>
<p>首先区分一下ssh和sshd。ssh（Secure Shell Protocol）是一种用于远程登陆的加密网络传输协议，同时也是使用这一套协议进行远程登陆的客户端程序名。sshd（多一个字母d）则是远程登陆的服务端，其中字母d是单词daemon（守护进程）的缩写。</p>
<h3 id="1-开启功能"><a href="#1-开启功能" class="headerlink" title="1. 开启功能"></a>1. 开启功能</h3><p>开启win10系统sshd功能的方法很简单：打开设置 → 应用 → 可选功能 → 添加可选功能 → 查看功能，在列表中找到OpenSSH服务端，点击安装既可，整个过程大约需要几分钟的时间。之后，在命令行提示程序（Windows Prompt/Powershell）中输入指令sshd，如果出现的反应是没有输出任何信息，或者出现一行报错： <code>sshd re-exec requires execution with an absolute path</code> ，则说明安装成功。</p>
<p>特别提示一下，对于<code>sshd re-exec requires execution with an absolute path</code>报错，解决方法是从绝对文件路径启动sshd程序，换句话说就是用<code>C:/Windows/System32/OpenSSH/sshd.exe</code>代替<code>sshd</code>指令本身。</p>
<h3 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2. 配置文件"></a>2. 配置文件</h3><p>做完前面的步骤之后，sshd依然不能算作已经开启，因为此时还差一个配置文件没有生成。根据网上的教程，第一次启动sshd会自动生成一个配置文件，但是经过实际测试并非如此。但是，也有文章提到sshd自带了一个配置文件模板在 <code>C:\Windows\System32\OpenSSH\sshd_config_default</code> 。将这份文件拷贝到sshd运行数据目录<code>C:\ProgramData\ssh</code>下，并修改部分配置（大部分不需要动），再运行sshd就可以了。</p>
<h3 id="3-免密登录"><a href="#3-免密登录" class="headerlink" title="3. 免密登录"></a>3. 免密登录</h3><p>在客户端（本地电脑）上运行ssh-keygen，一路回车之后会生成两个文件，分别是<code>id_rsa</code>和<code>id_rsa.pub</code>。将第二个文件的内容追加到 <code>C:\ProgramData\ssh\administrators_authorized_keys</code> 文件末尾既可。</p>
<h2 id="二、基于nps的内网穿透"><a href="#二、基于nps的内网穿透" class="headerlink" title="二、基于nps的内网穿透"></a>二、基于nps的内网穿透</h2><blockquote>
<p>参考：</p>
<ul>
<li><a href="https://ehang-io.github.io/nps/#/">nps使用文档</a></li>
<li><a href="https://github.com/ehang-io/nps/">nps程序代码</a></li>
</ul>
</blockquote>
<p>基于nps的内网穿透需要一台云服务器，如果没有则可以考虑使用花生壳等即开即用平台。</p>
<p>下面是针对已有云服务器的情况进行的说明：</p>
<p>假设我们已经有了一台Linux系统的云服务器，并且在云安全组中开放了需要的端口（nps需要8080、8024等端口）。我们现在需要从<a href="https://github.com/ehang-io/nps/releases">github的release界面</a>中下载nps的客户端和服务端，前者下载windows版，并在前述内网主机上运行；后者则下载Linux版，在云服务器端运行。</p>
<p>启动nps服务端，在任意浏览器上通过8080端口访问云服务器，将会进入nps的控制面板。在这里，新建一个客户端实例，并添加tcp隧道，填写内网ip地址和端口号（sshd服务走22端口）。随后，在客户端列表中能够看到相应的客户端以及启动指令，例如<code>./npc -server=[url]:[port] -vkey=[vkey] -type=tcp</code> 这样。</p>
<p>接下来，在内网主机中，用命令提示符程序打开nps客户端的安装目录，使用上述命令启动npc（命令中的<code>./npc</code>改为<code>.\npc.exe</code>）。当输出的INFO中提示连接成功时，既可使用云服务器访问前述内网主机了。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>sshd</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>obsidian探索小记（一）——zotero和obsidian联动的一些探索</title>
    <url>/2023/11/24/zotero-obsidian-interaction/</url>
    <content><![CDATA[<p>zotero是一款著名的文献管理软件，而obsidian是一个界面很好看的markdown笔记软件。这两款软件都有着丰富的插件生态，并且二者可以联动，完成许多意想不到的事情。这里记录的就是我在两款软件联动上的一点点探索。</p>
<span id="more"></span>


<h2 id="一、必备插件安装："><a href="#一、必备插件安装：" class="headerlink" title="一、必备插件安装："></a>一、必备插件安装：</h2><h3 id="（一）zotero插件的安装："><a href="#（一）zotero插件的安装：" class="headerlink" title="（一）zotero插件的安装："></a>（一）zotero插件的安装：</h3><p>为了实现两款软件的联动，我们首先需要在zotero上安装一些必要的插件。这些插件的名称和官网地址如下：</p>
<ol>
<li>Better BibTeX for Zotero  <a href="https://retorque.re/zotero-better-bibtex/">https://retorque.re/zotero-better-bibtex/</a></li>
<li>zotefile <a href="http://zotfile.com/">http://zotfile.com/</a></li>
<li>zotero-mdnotes <a href="https://github.com/argenos/zotero-mdnotes">https://github.com/argenos/zotero-mdnotes</a></li>
</ol>
<p>访问上述链接，获取插件的<code>.xpi</code>文件并下载。</p>
<p>之后打开zotero，点击“工具”-“附加组件”打开附加组件管理器，将.xpi文件拖入这个管理器面板即可。zotero会提示重启软件以使插件生效。</p>
<p><img src="https://pic.imgdb.cn/item/65620038c458853aefa4f6ea.jpg" alt="附加组件管理器的按钮"></p>
<p><em>图1. 附加组件管理器的按钮</em></p>
<p><img src="https://pic.imgdb.cn/item/65620085c458853aefa68911.jpg" alt="附加组件管理器面板"></p>
<p><em>图2. 附加组件管理器面板。将<code>.xpi</code>文件拖入面板即可完成安装</em></p>
<h3 id="（二）obsidian插件的安装："><a href="#（二）obsidian插件的安装：" class="headerlink" title="（二）obsidian插件的安装："></a>（二）obsidian插件的安装：</h3><p>在我目前完成的探索中，obsidian插件只需要安装一款： <code>zotero integration</code></p>
<ul>
<li>zotero integration: <a href="https://github.com/mgmeyers/obsidian-zotero-integration">https://github.com/mgmeyers/obsidian-zotero-integration</a></li>
</ul>
<p>和zotero不同，obsidian内置了插件商城，因此我们借助插件商城完成安装即可。下面是安装步骤：</p>
<p>首先，点击设置按钮（主界面左下角小齿轮图标）进入设置面板，点击“community plugins”，然后点击“turn on community plugins”开启安装插件的功能</p>
<p><img src="https://pic.imgdb.cn/item/6562015cc458853aefaa67b7.jpg" alt="开启插件商城"></p>
<p><em>图3. 开启插件商城</em></p>
<p>在随后出现的界面中，点击“community plugins”项目右边的“Browse”紫色按钮，进入插件商城，在此次搜索对应插件的名字。</p>
<p><img src="https://pic.imgdb.cn/item/656201a1c458853aefab9bef.jpg" alt="设置面板"></p>
<p><em>图4. 浏览插件商城</em></p>
<p>搜索结果如下图。点击对应的插件名称，然后点“install”按钮完成安装即可。</p>
<p><img src="https://pic.imgdb.cn/item/656201e5c458853aefacc081.jpg" alt="安装zotero integration"></p>
<p><em>图5. 安装zotero integration</em></p>
<p>由于obsidian的底层架构是electron，其技术源于谷歌chrome浏览器，因此obsidian的诸多插件也是基于web技术开发的，编程语言以 TypeScript / JavaScript 为主，故插件体积很小，安装速度也很快。在完成安装以后，记得在设置面板的“community plugins”标签页中启用对应插件。</p>
<h3 id="（三）小插曲"><a href="#（三）小插曲" class="headerlink" title="（三）小插曲"></a>（三）小插曲</h3><p>在我的探索过程中，zotero integration插件的安装出现了问题。如果直接采用上述方法安装，则在安装完成后无法启用这一扩展，obsidian报错 <span style="color:#ff0000">“Failed to load plugin obsidian-zotero-desktop-connector”</span> 。</p>
<p>在网上查询相关问题后得知，这种报错可能是本地文件不完整所致。于是我也探索了一下如何解决这个问题。</p>
<p>点击设置界面的文件夹图标“open plugins folder”打开插件安装目录，可以发现zotero integration插件只安装了manifest.json文件，而完整的obsidian插件还需要main.js和styles.css两个文件。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(base) cyclin@DESKTOP-23BCT60:/mnt/e/000_desktop/private/document/obsidian/.obsidian/plugins$ tree</span><br><span class="line">.</span><br><span class="line">└── obsidian-zotero-desktop-connector</span><br><span class="line">    └── manifest.json</span><br></pre></td></tr></table></figure>

<p>那么缺少的这两个文件去哪里安装呢？zotero integration插件是开源的，所以我们去github上看看有没有对应的文件。</p>
<p>访问zotero integration插件的github release页面（ <a href="https://github.com/mgmeyers/obsidian-zotero-integration/releases">https://github.com/mgmeyers/obsidian-zotero-integration/releases</a> ），这一页上列出的都是插件的发行版。可以看到，<code>main.js</code>, <code>manifest.json</code>, <code>styles.css</code>三个文件是全的。</p>
<p>在这里下载缺少的两个文件，并放入上述安装目录文件夹中，然后重启软件，这一次，zotero integration插件就可以成功启用了。</p>
<p><img src="https://pic.imgdb.cn/item/65620542c458853aefbc6673.jpg" alt="成功启用插件"></p>
<p><em>图6. 成功启用插件</em></p>
<h2 id="二、配置zotero-integration插件"><a href="#二、配置zotero-integration插件" class="headerlink" title="二、配置zotero integration插件"></a>二、配置zotero integration插件</h2><blockquote>
<p>这一部分的内容参考网络教程 <a href="https://zhuanlan.zhihu.com/p/553864286">《Obsidian插件-Obsidian-Zotero-Integration》</a></p>
</blockquote>
<p>通用配置：</p>
<ul>
<li>配置PDF utility，配置好后会显示如图的绿色勾号；<ul>
<li>根据教程，此处直接点击下载PDF utility，等待插件配置完成即可。</li>
<li>但是我在这一步的配置总是失败，于是采取了自行安装PDF utility的方法。从PDF utility官网下载了可执行文件（ <a href="https://github.com/mgmeyers/pdfannots2json/releases">https://github.com/mgmeyers/pdfannots2json/releases</a> ），然后将PDF utility可执行文件的路径粘贴到设置当中。如此配置完成后，也会显示绿色勾号；</li>
</ul>
</li>
<li>配置插件数据库，这里选择Zotero；</li>
<li>选择笔记模板的导入地址（笔记模板的编写稍后介绍）；</li>
<li>启用cite key的自动补全（可选择开启）；</li>
</ul>
<p>配置Cication Formats</p>
<ul>
<li>点击Add Citation Format按钮添加格式</li>
<li>导出格式选择American Psychological Association 7th edition的格式（在zotero中导出格式需要与之相同，见下文）</li>
</ul>
<p>配置Import Format</p>
<ul>
<li>点击Add Import Format按钮添加格式<ul>
<li><code>Output path</code>：这里配置的地址为从Zotero导入信息后经过模板处理，笔记存储的路径；</li>
<li><code>Image Output path</code>：笔记图片存储的路径；</li>
<li><code>Template File</code>：笔记模板的路径；</li>
<li><code>Bibliography Style</code>：与Zotero配置的值相同。</li>
</ul>
</li>
<li>注意，上面设置中的路径全部需要使用相对路径<ul>
<li>所谓相对路径，是相对于obsidian的仓库根目录而言的（例如在我的电脑上，仓库根目录是 <code>E:\000_desktop\private\document\obsidian</code> ，那么配置中填写的目录就是相对于这个根目录的位置，例如导出路径为 <code>paper/&#123;&#123;citekey&#125;&#125;.md</code> ，其绝对路径就是<code>E:\000_desktop\private\document\obsidian\paper\&#123;&#123;citekey&#125;&#125;.md</code>）</li>
</ul>
</li>
<li>为了方便，可以直接参考下面这一配置：<ul>
<li>导出路径为 <code>paper/&#123;&#123;citekey&#125;&#125;.md</code></li>
<li>图片导出路径为 <code>paper/asset/&#123;&#123;citekey&#125;&#125;/</code></li>
</ul>
</li>
</ul>
<p>笔记模板设置</p>
<ul>
<li>这部分完全参考上述教程。模板文件的存储路径和文件名为： <code>&lt;vault&gt;/template/template.md</code> ，其中 <code>&lt;vault&gt;</code> 是仓库根目录。 <code>template.md</code>文件内容如下：</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="section">tags: [Papers, Readed, Tempalte]</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"><span class="section"># &#123;&#123;title&#125;&#125;</span></span><br><span class="line">[toc]</span><br><span class="line"><span class="section">## 1.Abstract&amp;Info</span></span><br><span class="line"><span class="section">### 1.1 Abstract</span></span><br><span class="line">&#123;&#123;abstractNote&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">### 1.2 Info</span></span><br><span class="line">Authors: &#123;&#123;authors&#125;&#125;</span><br><span class="line">DOI: &#123;&#123;DOI&#125;&#125;</span><br><span class="line">Publication: &#123;&#123;publicationTitle&#125;&#125;</span><br><span class="line">PDF: &#123;&#123;pdfLink&#125;&#125;</span><br><span class="line">Zotero: &#123;&#123;pdfZoteroLink&#125;&#125;</span><br><span class="line">Data: &#123;&#123;date|format(&quot;YYYY-MM-DD&quot;)&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">## 2. Annotation</span></span><br><span class="line">&#123;% persist &quot;annotations&quot; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% set newAnnotations = annotations | filterby(&quot;date&quot;, &quot;dateafter&quot;, lastImportDate) %&#125;</span><br><span class="line">&#123;% if newAnnotations.length &gt; 0 %&#125;</span><br><span class="line"><span class="section">### Imported: &#123;&#123;importDate | format(&quot;YYYY-MM-DD h:mm a&quot;)&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">&#123;% for each in newAnnotations %&#125;</span><br><span class="line">&#123;% if each.colorCategory == &#x27;Blue&#x27; %&#125;</span><br><span class="line">原文：[<span class="string">&#123;&#123;each.annotatedText&#125;&#125;</span>](<span class="link">zotero://open-pdf/library/items/&#123;&#123;each.attachment.itemKey&#125;&#125;?page=&#123;&#123;each.page&#125;&#125;&amp;annotation=&#123;&#123;each.id&#125;&#125;</span>)</span><br><span class="line">标注：&#123;&#123;each.comment&#125;&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% endfor%&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% endpersist %&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将上述内容复制到模板文件中，然后在obsidian的上述设置界面中添加模板文件（输入template这几个字母，obsidian会自动补全路径）。到此为止，要在obsidian上进行的配置就完成了。</li>
</ul>
<p>全部配置如下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/6562092dc458853aefcf37d6.jpg" alt="全部配置"></p>
<p><em>图7. 全部配置</em></p>
<p>我们还需要在zotero上进行配置，将快速复制的条目格式同样改为和之前一样的American Psychological Association 7th edition的格式。到此为止，配置工作完成。</p>
<p><img src="https://pic.imgdb.cn/item/65620976c458853aefd091a4.jpg" alt="zotero上的配置"></p>
<p><em>图8. zotero上的文献条目格式配置</em></p>
<h2 id="三、如何使用这一联动功能"><a href="#三、如何使用这一联动功能" class="headerlink" title="三、如何使用这一联动功能"></a>三、如何使用这一联动功能</h2><h3 id="（一）导出zotero的笔记到markdown文件"><a href="#（一）导出zotero的笔记到markdown文件" class="headerlink" title="（一）导出zotero的笔记到markdown文件"></a>（一）导出zotero的笔记到markdown文件</h3><p>在obsidian编辑器中打开命令窗口（快捷键ctrl/Command+P，或者按下主界面最左侧的 <code>&gt;_</code> 按钮），并找到指令 zotero integration: import zotero note。</p>
<p><img src="https://pic.imgdb.cn/item/65620a42c458853aefd45d83.jpg" alt="指令窗口"></p>
<p><em>图9. 指令窗口</em></p>
<p>执行这一指令，会打开zotero的快速格式化引文工具栏（如下图）。在此栏输入要导出笔记的文章标题，则obsidian会自动从zotero中抓取文章元数据并创建对应markdown文件。</p>
<p><img src="https://pic.imgdb.cn/item/65620a66c458853aefd50a79.jpg" alt="快速格式化引文工具栏"></p>
<p><em>图10. 快速格式化引文工具栏</em></p>
<p>以一篇文章  Deep learning for computational biology ( doi:10.15252/msb.20156651 ) 为例。在经过上述步骤导出笔记后，其生成的markdown文件如下。在markdown文件中还包含了跳转到原PDF的链接，方便随时查看PDF内容。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="section">tags: [Papers, Readed, Tempalte]</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"><span class="section"># Deep learning for computational biology</span></span><br><span class="line">[toc]</span><br><span class="line"><span class="section">## 1.Abstract&amp;Info</span></span><br><span class="line"><span class="section">### 1.1 Abstract</span></span><br><span class="line">Technological advances in genomics and imaging have led to an explosion of molecular and cellular profiling data from large numbers of samples. </span><br><span class="line">This rapid increase in biological data dimension and acquisition rate is challenging conventional analysis strategies.</span><br><span class="line">Modern machine learning methods, such as deep learning, promise to leverage very large data sets for finding hidden structure within them, and for making accurate predictions.</span><br><span class="line">In this review, we discuss applications of this new breed of analysis approaches in regulatory genomics and cellular imaging.</span><br><span class="line">We provide background of what deep learning is, and the settings in which it can be successfully applied to derive biological insights.</span><br><span class="line">In addition to presenting specific applications and providing tips for practical use, we also highlight possible pitfalls and limitations to guide computational biologists when and how to make the most use of this new technology.</span><br><span class="line"></span><br><span class="line"><span class="section">### 1.2 Info</span></span><br><span class="line">Authors: Christof Angermueller, Tanel Pärnamaa, Leopold Parts, Oliver Stegle</span><br><span class="line">DOI: 10.15252/msb.20156651</span><br><span class="line">Publication: Molecular Systems Biology</span><br><span class="line">PDF: [<span class="string">Angermueller 等 - 2016 - Deep learning for computational biology.pdf</span>](<span class="link">file://E:\000_desktop\private\document\Zotero\storage\C7VZ43KL\Angermueller%20等%20-%202016%20-%20Deep%20learning%20for%20computational%20biology.pdf</span>)</span><br><span class="line">Zotero: [<span class="string">Angermueller 等 - 2016 - Deep learning for computational biology.pdf</span>](<span class="link">zotero://select/library/items/C7VZ43KL</span>)</span><br><span class="line">Data: 2016-07-01</span><br><span class="line"></span><br><span class="line"><span class="section">## 2. Annotation</span></span><br><span class="line">%% begin annotations %%</span><br><span class="line"></span><br><span class="line">[[angermuellerDeepLearningComputational2016]]</span><br><span class="line"></span><br><span class="line">%% end annotations %%</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%% Import Date: 2023-11-20T21:35:11.989+08:00 %%</span><br></pre></td></tr></table></figure>

<p>然而，现在依然有两个问题没解决：</p>
<ul>
<li>（1）目前只能一篇文章一篇文章的导入，没有批量导入的方法。</li>
<li>（2）似乎抓取不了笔记数据，无论是直接标注在PDF上的笔记，还是记录在zotero备注框里的笔记。</li>
</ul>
<h3 id="（二）在obsidian中构建知识图谱的方法"><a href="#（二）在obsidian中构建知识图谱的方法" class="headerlink" title="（二）在obsidian中构建知识图谱的方法"></a>（二）在obsidian中构建知识图谱的方法</h3><p>这一块进行的探索不多，仅记录已有结果。</p>
<blockquote>
<p> 参考： <a href="https://zhuanlan.zhihu.com/p/398625612">《Obsidian知识体系搭建：小白入门篇》</a></p>
</blockquote>
<p>Obsidian 支持多种「超链接」形式，例如：</p>
<ul>
<li> 双向链接：<code>[[笔记名]]</code></li>
<li> 笔记标题引用： <code>[[笔记名#标题]]</code></li>
<li> 块引用： <code>[[笔记名 ^]]</code></li>
</ul>
<p>obsidian支持使用上述方法在不同的markdown文件之间建立关联。因此，我们可以在不同笔记之间使用双向链接：<code>[[笔记名]]</code> 构建笔记与笔记之间的关系网络图。</p>
<p>下面是关系图的一个示例：</p>
<p><img src="https://pic.imgdb.cn/item/65620b63c458853aefd99103.jpg" alt="关系图示例"></p>
<p><em>图11. obsidian关系图示例</em></p>
<p>以上。</p>
<p>关于 obsidian软件的使用，未来还会继续探索。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>obsidian探索小记</tag>
        <tag>zotero</tag>
        <tag>文献管理</tag>
      </tags>
  </entry>
  <entry>
    <title>一些思绪：写于北京临近年关的一场雪后</title>
    <url>/2022/01/22/%E4%B8%80%E4%BA%9B%E6%80%9D%E7%BB%AA%EF%BC%9A%E5%86%99%E4%BA%8E%E5%8C%97%E4%BA%AC%E4%B8%B4%E8%BF%91%E5%B9%B4%E5%85%B3%E7%9A%84%E4%B8%80%E5%9C%BA%E9%9B%AA%E5%90%8E/</url>
    <content><![CDATA[<p>北京连着下了三天的雪，今天晚上终于停了。</p>
<span id="more"></span>

<p>我曾经公开表示过自己对下雪天气的喜爱，首当其中的就是雪后的晴天，当然雪后的其他天气也是美丽的。我喜欢雪后一尘不染的、寂静而纯白色的世界，而孤身一人走进那样的世界，会给我带来一种别样的安全感。</p>
<p>今晚一个人出门溜达，去了清华园上跨地铁13号线人行天桥，又去了五道口购物中心。如果说去上跨地铁线人行天桥只是为了散步和满足自己看火车的欲望，那么独自一个人逛五道口购物中心或许是一种精神自虐吧。五道口我独自去过不少次，但我为数不多的几次去逛五道口购物中心的经历，都不是我一个人在逛。</p>
<p>再也不会有那么美好的经历了吧——那个充实而难忘的暑假，那些地方，还有那些（个）人。可是事情已经过去快一个月了，我好像还没有得到成长，人际交往能力没有任何提升，也没想明白如果重头再来一次，我是否有机会改变结局以及怎么改变结局。</p>
<hr>
<p>从2021年二月底离开家，到2022年1月底将要回家过年，这一年多的时间，一大半在北京，一小半在天津，另外还有几天的国庆假期回了家。</p>
<p>这一年来发生了不少事情，而我在这一年的时间里其实也收获了很多东西。从去年年初自己参与做的几轮分子生物学实验，到生信方面的基础知识的学习，到科研训练3-2汇报，到系统学习数据分析方法，再到三个月时间备战考研。回到北京后，又参与了一段时间的课题，并在居家隔离期间整了个<a href="http://anoms.top/weather_get_v4.0/">天气数据展示的网站</a>（好活，就是有点烂）。科研能力有没有提高这我不敢问，但见识、计算机知识肯定是有提高的。</p>
<p>有没有发现，上面提到的都是我自己在学习和科研方面的经历和收获，对于人际丝毫没有提？其实这一年在人际方面我也有一些进步，例如第一次主动约女生出来玩，第一次谈恋爱。可惜作为一个从高中开始就能把一手好牌玩砸的人，2021年的这些尝试均以失败告终。2022年了，我希望自己在人际方面能有所进步，希望遇到更好的朋友，希望变成更好的自己。</p>
<p>学习和事业方面的成就一定与人际方面的幸福体验挂钩吗？不一定，甚至二者可能关系不显著。身边太多例子：学习成绩并不足够拔尖的男生，和自己的女友关系很好、如胶似漆；学习拔尖或者有获奖项目/竞赛的男生，母胎solo二十载，谈个对象几天就分手。不同的人对于分手和离婚这种事情有着不同的看法，甚至会有些人认为分手/离婚是一种自由，新鲜感过了就换下一位是种幸福，两个早已失去新鲜感的人凑合一辈子反而是种包袱。可惜，我并不认同这样的想法，我觉得既然选择进入一段亲密关系，就应该负责到底，虽然恋爱前期可以靠新鲜感和相互吸引维持，但要想走得长远一点还得靠责任感；并且作为一个感情上慢热的人，能喜欢上一个人是件很珍贵而稀缺的事情，我不接受随随便便谈恋爱、谈完一个换一个的生活。</p>
<p>上面两段话内容有点压抑，以后我可能不会在日记里写这些了。临近回家的日子，回想点开心事情乐呵乐呵多好，别整天emo。凡事都要向前看，不是吗？</p>
<p>快过年了，可以回家与父母团聚了。但，今天晚上出去溜达了一圈，溜达时我想，我真的能体会到世人对父母家人那种深厚的感情吗？我真的有能力爱别人吗？我发现，今年这个寒假，如果我不回家与父母团聚，我好像也不太感到惋惜；平时与父母家人通话时，我好像也只是抱有一种完成任务的心态，每周打个电话确认一下状态就行了，没有太多感情上的交流。我觉得这不对。把做任何事情都当作处理任务来对待，确实可以偷很多懒，但这样对于你的人际关系发展并不利。</p>
<p>有些累了，今晚上就写到这吧。明天做核酸、置办年货，后天就要回家了。在这里提前祝我的所有家人、老师、同学、朋友及前朋友以上关系的人平安喜乐、万事顺遂。</p>
<p>戊寅虎年快乐！</p>
<p>pm 23:47</p>
<hr>
<p><img src="https://pic.imgdb.cn/item/6540f4c4c458853aef08c559.jpg" alt="night snow"></p>
<p>临近年关的一场雪。摄于北京奥林匹克森林公园</p>
<p><img src="https://pic.imgdb.cn/item/6540f4d8c458853aef08fe4a.jpg" alt="train in dark night"></p>
<p>驶向黑夜的列车。摄于清华大学东门附近，某处上跨地铁13号线的人行天桥。</p>
]]></content>
      <categories>
        <category>杂思</category>
      </categories>
      <tags>
        <tag>爱情</tag>
        <tag>日记</tag>
        <tag>思绪整理</tag>
      </tags>
  </entry>
  <entry>
    <title>一些思绪：写于邹班开课第一周</title>
    <url>/2021/03/30/%E4%B8%80%E4%BA%9B%E6%80%9D%E7%BB%AA%EF%BC%9A%E5%86%99%E4%BA%8E%E9%82%B9%E6%89%BF%E9%B2%81%E7%8F%AD%E5%BC%80%E8%AF%BE%E7%AC%AC%E4%B8%80%E5%91%A8/</url>
    <content><![CDATA[<p>上周五（3月26日）上午的免疫学前沿，高老师给我们讲课，不知为何，听完以后心情澎湃，久久不能平静。</p>
<span id="more"></span>

<p>高老师的研究方向主要是免疫系统中cGAS蛋白相关的结构解析。关于这个研究方向的选择，高老师说起了他当年在美国做博士后的经历。那段日子，工作压力、生活压力长期困扰着我们的老师，而最开始的研究方向论文被抢发，给了他最大的一个打击。痛定思痛，总结教训，高老师最终选择了当时最新的cGAS蛋白作为研究方向，并不断耕耘，最终获得了许多。</p>
<p>高老师最后还送给我们几句话，但那已经不重要了。老师的经历最能够给教给我的，是在科研道路上背水一战的勇气，在困境面前，逼自己一把，用时间和（几乎是）自己的生命去赌一把，才能让未来的自己不后悔。</p>
<p>不知为什么，当老师谈起那段经历时，我脑海中浮现出了高一高二搞竞赛的那些日子里的情景。直到现在，依然很怀念那些抱着竞赛书看的下午和晚自习，怀念那种离群索居的孤独，以及内心的纯净和坚定。不论最终取得的成果有没有达到自己的预期，生物竞赛的经历都必然是我生命前20年里最浓墨重彩的一笔。</p>
<p>但不知为何，上大学以来，那种内心的纯净和坚定消失了。我选择了生物专业，顺应了自己的兴趣，但是却很少再体会到高中时代的那种快乐。我开始学着上网，看到各种不同的人各种不同的言论。有人说生物是未来，有人说生化环材毁我青春，有人痛批大学生内卷，有人拿着自己高于其他人的知识储备秀优越感。有人在网上阴阳怪气，有人放长线钓大鱼，还有玩梗小鬼把身边的一切泛娱乐化。还有人说学习没有前途，要入关，要通过暴力手段解决目前的不平等问题。我也渐渐沉浸在这场狂欢中，不可自拔，渐渐忘记了自己追求的是什么，能真正带给我快乐的又是什么，每天沉浸在知乎、b站的万人狂欢之中，堕向暗无边际的深渊。</p>
<p>我不知道自己到底有没有从那样一段状态中走出来。但是，在现在这个地方，我能感觉到一种热情渐渐回归。至少这里的环境让我放弃了将大量的时间投入到那些无意义的娱乐项目中。但我还做不到像高中时那样心无旁骛地学习，高效利用时间。当身边的同学说完成了什么实验，看了什么论文，有什么研究成果发表时，内心依然会感到焦虑，但是焦虑过后，该吃吃，该玩玩，并不能将焦虑顺利地转化为学习的动力。</p>
<p>现在我还处在第一轮轮转阶段。目睹实验室师兄师姐每天的工作主要是看论文开会写代码，自己什么都干不了，时常对自己感到怀疑。同时，在非常浅显的读完一些文献之后，我意识到自己在数理知识方面还有很多欠缺。而今天（3月30日）上完课之后，更加意识到自己在免疫学领域所学知识的欠缺，因此还需要努力，补充自己知识面上的短板。</p>
<p>未来的路还有很长，需要开拓的领域很多。趁着年轻，抓紧时间，不要荒废了自己的大好青春。共勉。</p>
<hr>
<p>（说一点之后的事情：当时我也不知道受了什么刺激，写下了这么一篇打鸡血的文章。可是没过两天，又开始摆烂，于是实际上上面提到的这些东西我最终都没有完成，这可真令人遗憾（手动滑稽））</p>
]]></content>
      <categories>
        <category>杂思</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载+修改】一个PC端的离线翻译程序</title>
    <url>/2023/11/03/%E3%80%90%E8%BD%AC%E8%BD%BD-%E4%BF%AE%E6%94%B9%E3%80%91%E4%B8%80%E4%B8%AAPC%E7%AB%AF%E7%9A%84%E7%A6%BB%E7%BA%BF%E7%BF%BB%E8%AF%91%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>一个基于pytorch、transformers等基础库的离线翻译程序</p>
<span id="more"></span>

<blockquote>
<p>参考:</p>
<p><a href="https://www.cnblogs.com/weskynet/p/16740041.html">https://www.cnblogs.com/weskynet/p/16740041.html</a></p>
<p><a href="https://huggingface.co/Helsinki-NLP">https://huggingface.co/Helsinki-NLP</a></p>
</blockquote>
<h2 id="0-引言"><a href="#0-引言" class="headerlink" title="0. 引言"></a>0. 引言</h2><p>文本翻译是我们在科研生活中常常要碰到的事情。<br>诸如Google translate、百度翻译、chatGPT等在内的在线翻译工具（包括大语言模型）都能够很好的完成翻译工作。<br>然而，当网络环境不佳时，选用离线翻译程序就成了一个自然的需求。</p>
<p>虽然包括有道翻译在内的许多翻译软件都提供了离线翻译插件的功能，但本着“自己动手，丰衣足食”的原则，我们打算从开源模型出发搭建一个翻译程序。</p>
<p>HuggingFace上托管了赫尔辛基大学开发的一系列自然语言翻译模型（ <a href="https://huggingface.co/Helsinki-NLP">Helsinki-NLP</a> ），涵盖1440对语言之间的转换，包括中译英和英译中。我们可以基于此，开发一个离线翻译工具</p>
<h2 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1. 环境配置"></a>1. 环境配置</h2><p>需要提前安装好python3。此外，还应安装好下列python模块：</p>
<ul>
<li>transformers</li>
</ul>
<p>（<code>transformer</code>是谷歌团队提出的一种机器学习算法，利用注意力机制进行序列的编码和解码处理，常被用于自然语言处理。chatGPT和GPT-4所依赖的底层技术也是transformer）</p>
<p>推荐使用conda完成上述模块的安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install -c conda-forge transformers</span><br></pre></td></tr></table></figure>

<h2 id="2-代码与原理"><a href="#2-代码与原理" class="headerlink" title="2. 代码与原理"></a>2. 代码与原理</h2><p>以下代码修改自文章 <a href="https://www.cnblogs.com/weskynet/p/16740041.html">《手把手搭建基于Hugging Face模型的离线翻译系统，并通过C#代码进行访问》</a> 。这篇文章使用Helsinki-NLP模型搭建了一个windows服务器，并嵌入到了.NET应用程序当中。我们并不需要这么麻烦，只需要开发一个控制台版本的程序即可。</p>
<p>原理很简单。Transformer模型很复杂，但是具体的实现细节已经封装在了<code>Transformers</code>模块当中。我们加载预训练好的翻译模型，然后调用对应的函数接口，即可使用相关的功能。</p>
<p>下面是我们的代码，复制粘贴到一个文本文件中，并将文本文件命名为<code>HelsinkiTranslation.py</code>即可。在第三小节中我们将介绍如何使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> pipeline, AutoModelWithLMHead, AutoTokenizer</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;+------------+&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;|  pyNLP-MT  |&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;+------------+&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Offline translation program&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载必要的模型。此处我们选择中译英和英译中两个模型</span></span><br><span class="line"><span class="comment"># 下面的代码将从HuggingFace网站上下载对应的模型，并存储在`$HOME/.cache/huggingface/hub/`文件夹下。</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Loading model: Chinese -&gt; English ...&#x27;</span>)</span><br><span class="line">    model_zh2en = AutoModelWithLMHead.from_pretrained(<span class="string">&#x27;Helsinki-NLP/opus-mt-zh-en&#x27;</span>)</span><br><span class="line">    token_zh2en =       AutoTokenizer.from_pretrained(<span class="string">&#x27;Helsinki-NLP/opus-mt-zh-en&#x27;</span>)</span><br><span class="line">    trans_zh2en = pipeline(<span class="string">&#x27;translation_zh_to_en&#x27;</span>, </span><br><span class="line">                            model     = model_zh2en, </span><br><span class="line">                            tokenizer = token_zh2en)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Loading model: English -&gt; Chinese ...&#x27;</span>)</span><br><span class="line">    model_en2zh = AutoModelWithLMHead.from_pretrained(<span class="string">&#x27;Helsinki-NLP/opus-mt-en-zh&#x27;</span>)</span><br><span class="line">    token_en2zh =       AutoTokenizer.from_pretrained(<span class="string">&#x27;Helsinki-NLP/opus-mt-en-zh&#x27;</span>)</span><br><span class="line">    trans_en2zh = pipeline(<span class="string">&#x27;translation_en_to_zh&#x27;</span>, </span><br><span class="line">                            model     = model_en2zh, </span><br><span class="line">                            tokenizer = token_en2zh)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;A exceptence occurred when loading model...&#x27;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，通过字符串中的ASCII字符比例，判断语句是中文还是英文</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isChinese</span>(<span class="params">text</span>):</span><br><span class="line">    l = <span class="built_in">len</span>(text)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> text:</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">ord</span>(c)&lt;<span class="number">256</span>):n+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">0.5</span>*l): <span class="comment">#ASCII字符占了所有字符的50%以上比例，判定为英文</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个翻译过程的函数，传入要翻译的字符串和翻译模式，返回翻译后的字符串</span></span><br><span class="line"><span class="comment"># 参数`mod`代表翻译模式，默认为自动检测。仅支持中译英和英译中。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">translate</span>(<span class="params">text, mod=<span class="string">&quot;auto&quot;</span></span>): <span class="comment"># 参数mod的可选值：&quot;auto&quot;(default),&quot;zh2en&quot;,&quot;en2zh&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(mod == <span class="string">&#x27;zh2en&#x27;</span>):</span><br><span class="line">        result = trans_zh2en(text, max_length=<span class="number">81920</span>)[<span class="number">0</span>][<span class="string">&#x27;translation_text&#x27;</span>]</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">if</span>(mod == <span class="string">&#x27;en2zh&#x27;</span>):</span><br><span class="line">        result = trans_en2zh(text, max_length=<span class="number">81920</span>)[<span class="number">0</span>][<span class="string">&#x27;translation_text&#x27;</span>]</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">if</span>(mod == <span class="string">&#x27;auto&#x27;</span>):</span><br><span class="line">        <span class="keyword">if</span>(isChinese(text)):</span><br><span class="line">            result = trans_zh2en(text, max_length=<span class="number">81920</span>)[<span class="number">0</span>][<span class="string">&#x27;translation_text&#x27;</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = trans_en2zh(text, max_length=<span class="number">81920</span>)[<span class="number">0</span>][<span class="string">&#x27;translation_text&#x27;</span>]</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置一个函数，用于调整翻译模式</span></span><br><span class="line">Mod = <span class="string">&quot;auto&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setmod</span>(<span class="params">mod</span>):</span><br><span class="line">    <span class="keyword">global</span> Mod</span><br><span class="line">    available_mod = [<span class="string">&quot;auto&quot;</span>,<span class="string">&quot;zh2en&quot;</span>,<span class="string">&quot;en2zh&quot;</span>]</span><br><span class="line">    <span class="keyword">if</span>(mod <span class="keyword">in</span> available_mod):</span><br><span class="line">        Mod = mod</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Unavailable mod: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(mod))</span><br><span class="line"></span><br><span class="line"><span class="comment"># “帮助”函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">help</span>():</span><br><span class="line">    help_text=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">All available commands:</span></span><br><span class="line"><span class="string">    /?      print this information</span></span><br><span class="line"><span class="string">    /help   print this information</span></span><br><span class="line"><span class="string">    /exit   quit program</span></span><br><span class="line"><span class="string">    /quit   quit program</span></span><br><span class="line"><span class="string">    /mod [mode]</span></span><br><span class="line"><span class="string">            set translation mode. </span></span><br><span class="line"><span class="string">            Available value: </span></span><br><span class="line"><span class="string">                &quot;auto&quot;(default): Automatically select translation mode.</span></span><br><span class="line"><span class="string">                &quot;zh2en&quot;: Chinese translate into English.</span></span><br><span class="line"><span class="string">                &quot;en2zh&quot;: English translate into Chinese.</span></span><br><span class="line"><span class="string">    /clear  clean screen</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">If you want to translate any sentence, just type it after prompt.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(help_text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析并执行指令的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">command</span>(<span class="params">cmd</span>):</span><br><span class="line">    <span class="keyword">if</span>  (cmd==<span class="string">&quot;/exit&quot;</span>):     sys.exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">elif</span>(cmd==<span class="string">&quot;/quit&quot;</span>):     sys.exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">elif</span>(cmd==<span class="string">&quot;/help&quot;</span>):     <span class="built_in">help</span>()</span><br><span class="line">    <span class="keyword">elif</span>(cmd==<span class="string">&quot;/?&quot;</span>   ):     <span class="built_in">help</span>()</span><br><span class="line">    <span class="keyword">elif</span>(cmd[<span class="number">0</span>:<span class="number">4</span>]==<span class="string">&quot;/mod&quot;</span>): setmod(cmd[<span class="number">5</span>:])</span><br><span class="line">    <span class="keyword">elif</span>(cmd==<span class="string">&quot;/clear&quot;</span>):</span><br><span class="line">        <span class="keyword">if</span>(sys.platform==<span class="string">&quot;win32&quot;</span>):os.system(<span class="string">&quot;cls&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>: os.system(<span class="string">&quot;clear&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; is not recognized as an command.&quot;</span>.<span class="built_in">format</span>(cmd))</span><br><span class="line">        <span class="built_in">help</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主函数。</span></span><br><span class="line"><span class="comment"># 我们构建的是一个交互式的翻译程序，进入程序后可以连续输入待翻译字符串，直到用户输入`/exit`指令退出。</span></span><br><span class="line"><span class="keyword">if</span>(__name__==<span class="string">&#x27;__main__&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;input `/help` for help&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">        word = <span class="built_in">input</span>(<span class="string">&#x27;(&#123;&#125;) &gt;&gt;&gt; &#x27;</span>.<span class="built_in">format</span>(Mod))</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">len</span>(word)==<span class="number">0</span>):<span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span>(word[<span class="number">0</span>]==<span class="string">&#x27;/&#x27;</span>):</span><br><span class="line">            command(word)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                text = translate(word, mod=Mod)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;\nTranslation:&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(text)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Cannot translate!&quot;</span>)</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;\n\n&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="3-使用方法展示"><a href="#3-使用方法展示" class="headerlink" title="3. 使用方法展示"></a>3. 使用方法展示</h2><h3 id="3-1-激活conda环境"><a href="#3-1-激活conda环境" class="headerlink" title="3.1 激活conda环境"></a>3.1 激活conda环境</h3><p>要注意，激活的环境是装了transformers模块的那个环境。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda activate</span><br></pre></td></tr></table></figure>

<h3 id="3-2-第一次运行代码"><a href="#3-2-第一次运行代码" class="headerlink" title="3.2 第一次运行代码"></a>3.2 第一次运行代码</h3><p>在终端或命令提示符程序中运行如下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python HelsinkiTranslation.py</span><br></pre></td></tr></table></figure>

<p>第一次运行代码时需要联网（必要时需要连上代理服务器），程序会从huggingface上下载对应的翻译模型，这些模型会保存在本地，未来再运行时可以直接调用。</p>
<p>程序输出如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">+------------+</span><br><span class="line">|  pyNLP-MT  |</span><br><span class="line">+------------+</span><br><span class="line">Offline translation program</span><br><span class="line"></span><br><span class="line">Loading model: Chinese -&gt; English ...</span><br><span class="line">Downloading (…)lve/main/config.json: 100%|████████████████████████████████████████████████████████████████████████████████████████████████████████| 1.39k/1.39k [00:00&lt;00:00, 562kB/s]</span><br><span class="line">Downloading pytorch_model.bin: 100%|███████████████████████████████████████████████████████████████████████████████████████████████████████████████| 312M/312M [00:14&lt;00:00, 22.2MB/s]</span><br><span class="line">Downloading (…)neration_config.json: 100%|████████████████████████████████████████████████████████████████████████████████████████████████████████████| 293/293 [00:00&lt;00:00, 192kB/s]</span><br><span class="line">Downloading (…)okenizer_config.json: 100%|█████████████████████████████████████████████████████████████████████████████████████████████████████████| 44.0/44.0 [00:00&lt;00:00, 38.5kB/s]</span><br><span class="line">Downloading (…)olve/main/source.spm: 100%|█████████████████████████████████████████████████████████████████████████████████████████████████████████| 805k/805k [00:00&lt;00:00, 2.70MB/s]</span><br><span class="line">Downloading (…)olve/main/target.spm: 100%|█████████████████████████████████████████████████████████████████████████████████████████████████████████| 807k/807k [00:00&lt;00:00, 3.11MB/s]</span><br><span class="line">Downloading (…)olve/main/vocab.json: 100%|███████████████████████████████████████████████████████████████████████████████████████████████████████| 1.62M/1.62M [00:00&lt;00:00, 5.01MB/s]</span><br><span class="line">Loading model: English -&gt; Chinese ...</span><br><span class="line">Downloading (…)lve/main/config.json: 100%|████████████████████████████████████████████████████████████████████████████████████████████████████████| 1.40k/1.40k [00:00&lt;00:00, 898kB/s]</span><br><span class="line">Downloading pytorch_model.bin: 100%|███████████████████████████████████████████████████████████████████████████████████████████████████████████████| 312M/312M [00:14&lt;00:00, 22.2MB/s]</span><br><span class="line">Downloading (…)neration_config.json: 100%|████████████████████████████████████████████████████████████████████████████████████████████████████████████| 293/293 [00:00&lt;00:00, 254kB/s]</span><br><span class="line">Downloading (…)okenizer_config.json: 100%|█████████████████████████████████████████████████████████████████████████████████████████████████████████| 44.0/44.0 [00:00&lt;00:00, 28.2kB/s]</span><br><span class="line">Downloading (…)olve/main/source.spm: 100%|█████████████████████████████████████████████████████████████████████████████████████████████████████████| 806k/806k [00:00&lt;00:00, 3.15MB/s]</span><br><span class="line">Downloading (…)olve/main/target.spm: 100%|█████████████████████████████████████████████████████████████████████████████████████████████████████████| 805k/805k [00:00&lt;00:00, 2.71MB/s]</span><br><span class="line">Downloading (…)olve/main/vocab.json: 100%|███████████████████████████████████████████████████████████████████████████████████████████████████████| 1.62M/1.62M [00:00&lt;00:00, 4.99MB/s]</span><br><span class="line">input `/help` for help</span><br><span class="line">(auto) &gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>当看到所有模型全部下载成功，并且加载出交互式程序提示符<code>(auto) &gt;&gt;&gt;</code>时，代表激活成功。</p>
<h3 id="3-3-日常使用"><a href="#3-3-日常使用" class="headerlink" title="3.3 日常使用"></a>3.3 日常使用</h3><p>在终端或命令提示符程序中运行指令<code>python HelsinkiTranslation.py</code>即可进入交互式的翻译程序界面</p>
<p>程序主界面如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">+------------+</span><br><span class="line">|  pyNLP-MT  |</span><br><span class="line">+------------+</span><br><span class="line">Offline translation program</span><br><span class="line">(created by Wesky, modified by WZ on Dec 9th, 2022)</span><br><span class="line"></span><br><span class="line">Loading model: Chinese -&gt; English ...</span><br><span class="line">Loading model: English -&gt; Chinese ...</span><br><span class="line">input `/help` for help</span><br><span class="line">(auto) &gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-帮助界面"><a href="#3-1-帮助界面" class="headerlink" title="3.1 帮助界面"></a>3.1 帮助界面</h4><p>在交互式模式下，输入<code>/help</code>即可得到帮助。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(auto) &gt;&gt;&gt; /help</span><br><span class="line"></span><br><span class="line">All available commands:</span><br><span class="line">    /?      print this information</span><br><span class="line">    /help   print this information</span><br><span class="line">    /exit   quit program</span><br><span class="line">    /quit   quit program</span><br><span class="line">    /mod [mode]</span><br><span class="line">            set translation mode.</span><br><span class="line">            Available value:</span><br><span class="line">                &quot;auto&quot;(default): Automatically select translation mode.</span><br><span class="line">                &quot;zh2en&quot;: Chinese translate into English.</span><br><span class="line">                &quot;en2zh&quot;: English translate into Chinese.</span><br><span class="line">    /clear  clean screen</span><br><span class="line"></span><br><span class="line">If you want to translate any sentence, just type it after prompt.</span><br></pre></td></tr></table></figure>

<h4 id="3-2-翻译与切换翻译模式"><a href="#3-2-翻译与切换翻译模式" class="headerlink" title="3.2 翻译与切换翻译模式"></a>3.2 翻译与切换翻译模式</h4><p>自动检测语言并翻译（默认）：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(auto) &gt;&gt;&gt; Sleep is an integral part of our daily routine, and, among the myriad functions attributed to this state, emotional processing stands out as a crucial aspect. Everyone has experienced at least once how a poor night’s sleep can wreak havoc on our emotions.</span><br><span class="line"></span><br><span class="line">Translation:</span><br><span class="line">睡眠是我们日常工作不可分割的一部分,在这种状态造成的众多功能中,情感处理是一个至关重要的方面。 每个人至少都经历过一次晚上睡得不好会给我们的情绪带来破坏。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(auto) &gt;&gt;&gt; 现在我们知道，每个文明的历程都是这样：从一个狭小的摇篮世界中觉醒，蹒跚地走出去，飞起来，越飞越快，越飞越远，最后与宇宙的命运融为一体。</span><br><span class="line"></span><br><span class="line">Translation:</span><br><span class="line">Now we know that every civilization goes through this: awakening from a tiny cradle world, walking out, flying, flying faster, flying further away, and finally integrating with the fate of the universe.</span><br></pre></td></tr></table></figure>

<p>将翻译模式改为仅英译中：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(auto) &gt;&gt;&gt; /mod en2zh</span><br><span class="line">(en2zh) &gt;&gt;&gt; For markets to achieve biodiversity conservation, biodiversity must endure. A “buy and forget” model, where credits exist forever regardless of whether the biodiversity persists, would lead to perverse outcomes.</span><br><span class="line"></span><br><span class="line">Translation:</span><br><span class="line">为了实现生物多样性保护,市场必须保持生物多样性。 一种“买和忘”模式 — — 不论生物多样性是否持续存在 — — 永远存在信贷,会导致错误的结果。</span><br></pre></td></tr></table></figure>

<p>将翻译模式改为仅中译英：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(auto) &gt;&gt;&gt; /mod zh2en</span><br><span class="line">(zh2en) &gt;&gt;&gt; 由于水体失去约束大量蒸发，小宇宙中云雾迷漫，太阳在云后朦胧地照耀着，出现了一道横跨宇宙的绚丽彩虹。</span><br><span class="line"></span><br><span class="line">Translation:</span><br><span class="line">Due to the loss of water bodies, which binds large amounts of evaporation, clouds in the small universe evaporate, the sun glitters behind them, and there is a beautiful rainbow across the universe.</span><br></pre></td></tr></table></figure>

<h4 id="3-3-退出程序"><a href="#3-3-退出程序" class="headerlink" title="3.3 退出程序"></a>3.3 退出程序</h4><p>在交互式模式下，输入<code>/exit</code>或<code>/quit</code>即可退出。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>huggingface</tag>
        <tag>python</tag>
        <tag>自然语言处理</tag>
      </tags>
  </entry>
  <entry>
    <title>一些杂谈：关于群体遗传学研究</title>
    <url>/2022/12/05/%E4%B8%80%E4%BA%9B%E6%9D%82%E8%B0%88%EF%BC%9A%E5%85%B3%E4%BA%8E%E7%BE%A4%E4%BD%93%E9%81%97%E4%BC%A0%E5%AD%A6%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<p>自然选择最直接的作用就是作用在性状上。因为性状在不同程度上由基因控制，因此最终我们可以用分子遗传学的方法在基因水平上检测选择与进化。</p>
<span id="more"></span>

<p>然而，对性状的选择的研究依然有他的意义，这个意义主要体现在如育种学、养殖学等的实际应用当中，例如通过群体遗传学方法，发现某些基因对增产有帮助，有些可以抗倒伏，这样的研究成果是可以进行转化应用的，其研究意义是看得见摸得着的。</p>
<p>研究人类性状的进化历史，例如我的本科毕业设计所包含的工作，则与这个研究意义并不相同。因此我们需要用一些新的故事对相关研究工作进行包装——最重要的是，我们想要研究的问题是什么？以及，这个研究结果是否具有可解释性？（例如，如果我们经过研究，发现某地人群的身高在最近一万年内出现了增高，这样的变化究竟是环境原因造成的呢，还是别的原因造成的呢？这里需要一个假设去解释相应的现象）</p>
<p>不管怎么说，最终的落脚点依然是群体遗传学，以及选择压力的检测——一般认为，传统的选择压力检测方法存在假阳性高的问题，而目前我们所做的很多工作旨在解决这一问题。在解决了假阳性高的问题以后，我们就可以将这样的方法应用于具体问题的解决当中了。最直接的几个问题，可能就如同<a href="https://www.science.org/content/resource/125-questions-exploration-and-discovery">Science杂志在庆祝上海交大125周年校庆时提出的125个问题</a>那样——“哪些基因使人类与众不同？ 远古人类是否曾与其他类人祖先杂交？未来人类的外貌会有所不同吗？”</p>
<p>以上。</p>
<p><img src="https://pic.imgdb.cn/item/638e0f75b1fccdcd36f2c686.png"></p>
<p><img src="https://pic.imgdb.cn/item/638e0f9cb1fccdcd36f2ffaa.png"></p>
<p><img src="https://pic.imgdb.cn/item/638e0fb0b1fccdcd36f31d98.png"></p>
]]></content>
      <categories>
        <category>杂思</category>
        <category>生物</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
        <tag>群体遗传学</tag>
      </tags>
  </entry>
  <entry>
    <title>一些因为天气原因导致心情烦躁的碎碎念</title>
    <url>/2022/09/13/%E4%B8%80%E4%BA%9B%E7%A2%8E%E7%A2%8E%E5%BF%B5%EF%BC%9A%E5%86%8D%E8%B0%88%E5%AD%A4%E7%8B%AC1/</url>
    <content><![CDATA[<p>上海的初秋，不像北京天津那般晴朗而辽阔，没有“晴空一鹤排云上，便引诗情到碧霄”的诗意。寒冷而潮湿，这是我对她的第一印象。</p>
<span id="more"></span>

<p>台风来了。或者说，他还没来，但是他已经早早的用各种方式宣誓了自己的到来。阴沉沉的天空，淅淅沥沥的秋雨，带给人的不只是寒冷，还有心情上的压抑。</p>
<p>所里安排我们新生体检，昨天因为去的太晚，扑了个空。今天再去，终于赶在上午第一节课下课前完成了所有检查。不知道是这般赶时间的检查导致心神疲惫，还是因为回来的路上淋了点雨，一整天都昏昏沉沉的，而且心情很压抑，很难受。孤独感再次袭来，</p>
<p>可能有些伤春悲秋了吧。今天感觉很难受，很孤独，很想找个依靠。</p>
<hr>
<p>说起来，之前我在网站里谈论过孤独这个话题，不过那段话被我藏到了一个<a href="http://anoms.top/weather_get_v4.0/about.php">页面的彩蛋</a>里。这个彩蛋需要点击“关于我们”栏目的头像才能触发。也不知道之前有没有人发现过那个彩蛋。</p>
<p>其实我想，这种藏小心思，也实在是有些幼稚，那就像是有一个秘密，希望和别人分享，又害怕和别人分享。还是希望自己能成熟点吧。</p>
<p>今天确实有点emo了，可能是天气原因加上一些事情很不顺心。其实想想看，今天写下的这些东西感觉挺幼稚的。以后不会了。也希望读者朋友们不要因为本文破坏我的形象🤪</p>
]]></content>
      <categories>
        <category>杂思</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title>一些碎碎念：写在端午假期</title>
    <url>/2022/06/06/%E4%B8%80%E4%BA%9B%E7%A2%8E%E7%A2%8E%E5%BF%B5%EF%BC%9A%E5%86%99%E5%9C%A8%E7%AB%AF%E5%8D%88%E5%81%87%E6%9C%9F/</url>
    <content><![CDATA[<p>端午假期骑车去了趟北京东站附近，拍了点照片，除此之外一直宅在宿舍。</p>
<span id="more"></span>

<p>近来颇有些伤感（和空虚寂寞？），可能是因为临近毕业，要离开一个熟悉的大环境，有点舍不得同学们。但是再仔细想想，其实大学期间我过得比高中孤独多了，而且魔都那边也有不少同学，综合起来看其实我真没必要太伤感。</p>
<p>可能就是长期缺爱导致的内心空虚，碰上端午小长假，于是emo了吧</p>
<p>还是很喜欢余光中的那篇《塔》。</p>
<blockquote>
<p>“终于都散了，就这么莫名其妙地散了，正如当初，莫名其妙地聚拢来一样。偌大的一片校园，只留下几声知更，只留下，走不掉而又没人坐的靠背长椅，怔怔对着花后的木兰”</p>
<p>“远望岂能当归，岂能当归？就如此刻，山外是平原，平原之外是青山是青山。俄亥俄之外是印第安纳之外是艾奥瓦是内布拉斯加是内华达，乌鸦之西仍是乌鸦是归巢的乌鸦。唯他的归途是无涯是无涯是无涯！”</p>
<p>……</p>
</blockquote>
<p>明天又是工作日，放下这些emo情绪，好好工作、好好生活。</p>
<hr>
<p>附：一些照片</p>
<p><img src="https://pic.imgdb.cn/item/6540f8c0c458853aef16643b.jpg" alt="railways"></p>
<p>北京朝阳，水南庄铁路道口。照片前方是北京东站的方向，右前方远处可以看到国贸的大厦</p>
<p><img src="https://pic.imgdb.cn/item/6540f8d8c458853aef16b483.jpg" alt="国贸"></p>
<p>央视大楼和国贸大厦。天气不太好，照片灰蒙蒙的。</p>
]]></content>
      <categories>
        <category>杂思</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>一点自我反思</title>
    <url>/2023/11/03/%E4%B8%80%E7%82%B9%E8%87%AA%E6%88%91%E5%8F%8D%E6%80%9D/</url>
    <content><![CDATA[<p>我的内心世界、我的社交模式以及其他。</p>
<span id="more"></span>

<p>这周二完成了开题。周三全天无事，然而晚上Hazel找我聊天，却很意外的聊到了许多深入的话题。谨记于此，希望自己可以记住。</p>
<p>之前一直疑惑的一件事情是，为什么我在社交上屡屡碰壁，为什么我没法拥有那些让我羡慕的人际关系？曾经以为是“术”的问题，我固执地相信，在这个阶段，社交是重要的；我也固执地相信，只要掌握了各种社交技术，那么获得人际关系，一定不在话下。</p>
<p>于是从去年春天开始，我固执地学起了很多“社交技能”。一年过去了，回看那些东西，似乎并没有为我带来多少改变——甚至现在的人际关系还不如大学。</p>
<p>错了。从头就弄错了。不是“术”的问题，更大的可能是一些弊病从小到大积累到现在的结果。</p>
<p>当我还很小时，被人欺负了，或者受到了大人的不公正的待遇，我会怎么样做？默默忍受，或者还击，或者……转头去欺负更弱小的人？</p>
<p>至少第三种做法是不对的。强者愤怒，抽刀向更强者；弱者愤怒，却抽刀向更弱者。恃强凌弱，是懦弱者的天性。很可惜，回想了一下小时候的事情，我却好像一直用恃强凌弱的方法解决这样的问题。（对不起我从小到大的同学们 o(TヘTo) ）</p>
<p>所以，不论是初中时干出来的那些王八蛋事情，还是高中时无法建立稳固的同学关系，本质都一样：我将生活中的不顺心转嫁到了比我更弱小的人身上。对于比我强大的人呢，则选择性忽视，不愿面对他们的存在。于是，在我的世界里，能真正引起我注意的，都是比我弱小的人；于是，我开始无端自信，并持续性自我感觉良好。</p>
<p>这对吗？这不对。明明你有另一种选择：努力让自己变强，直到自己足够强大，强大到让那些曾经欺负过、指责过你的人闭嘴。当然，有时候我们可能没法做到特别强，但我们可以 <strong>让人觉得</strong> 自己很强（但此时你知道自己的真实实力是多少，于是并不会无端自信——人贵有自知之明）。这是Hazel同学的做法——和我平白无故的自信形成了鲜明的对比。</p>
<p>这两种态度也导向了不同的人际交往结果。一切尽在不言中。</p>
<p>可以说，我目前的性格是多年来在各种人际因素影响下的结果——不论人际关系是主动还是被动。被灌输除了学习学习什么都不重要，于是有意无意的不关心自己的社交；被欺负被误解被责骂，选择抽刀向更弱者而不是让自己变强；等到进入大学，突然意识到自己是个人，却不知道如何和人正确的建立社交关系，于是开始放低姿态，给人一种很卑微的外在表现。了解我不深的人可能会觉得，你一个好好的人为什么要如此卑微；然而，再了解我深一点的人，就会发现，其实卑微是我的面具，我只想通过低姿态获得他人的关注和青睐——可惜，内心真正的我，实际上并不是这样。</p>
<p>昨晚的谈话，确实解答了我心中的一个大问题。很感谢Hazel的心理分析（很久没有过如此深入的聊天了；她真的，我哭死，谢谢她）。</p>
<p>也许问题还有：例如如何改变自己呢？如何真正做到尊重别人、限制自己的过度自信、不怕事敢担当呢？</p>
<p>这些都是后话。例如，可以从和身边的人的日常交往做起，尝试真正去理解身边的人。</p>
<p>慢慢来。但是必须慢慢改正自己了。</p>
]]></content>
      <categories>
        <category>杂思</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
        <tag>日记</tag>
        <tag>人际交往</tag>
      </tags>
  </entry>
  <entry>
    <title>人生选择中的“二值问题”与“连续函数”</title>
    <url>/2021/07/31/%E4%BA%BA%E7%94%9F%E9%80%89%E6%8B%A9%E4%B8%AD%E7%9A%84%E4%BA%8C%E5%80%BC%E9%97%AE%E9%A2%98%E4%B8%8E%E8%BF%9E%E7%BB%AD%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p> 在生活中我们面临许多抉择，而同样的，一些处于关键节点上的事件的后果可能对我们造成重要的、甚至不可逆的影响。</p>
<span id="more"></span>

<p> 例如高中生物竞赛，例如高考，还例如保研。</p>
<p> 正因为这些事情的后果常常在一个人的人生轨迹中发挥重要作用，对这些事情的分析是必要的。</p>
<p> 分析这些事件的特点与造成的后果，我想至少有一些结论可以得出来。</p>
<p> <strong>如果将一件事看作一个函数，自变量是你为整件事所做的准备和努力，因变量是这件事的结果（例如，对于高考，自变量是高中三年付出的努力，因变量是考上了哪里的大学），我们可以将这些关键性事件按照结果的可能性划分为两类：结果为离散的（二值问题）与结果为连续的（连续函数）。</strong></p>
<p> 高考属于后者。高考的结果可以视为一个连续的变量，无论如何基本都有大学上，但这个大学水平如何还取决于高中三年的努力。</p>
<p> 生物竞赛某种意义上属于前者。生物竞赛的结果可以用一系列名义变量表示：“省队”、“省一”、“省二”、“省三”、“没获奖”。不同的结果有不同的比例，而你准备了两年的生物竞赛，最后能得什么奖，一方面取决于你的努力，另一方面还取决于试卷考察的知识点以及省内友校的准备情况。可能出现一种情况，你努力了两年，最后连个省三都拿不到。</p>
<p> 对于这样两类事件，我想如果事件的结果是连续函数，这样的事件可能更容易被接受一点。结果为连续函数意味着可以吃保底，意味着即使结果略低于预期也不会给你造成太大的心理落差（高考考不上同济大学，考一个南开也不是不可以，反正都是985）。而相反，如果结果是二值的，那么后果可能让人无法接受（我参加竞赛，目标是一等奖，最后只拿了个安慰奖或者什么都没有）。另外，这些事件的消极后果也与心理落差有关。例如，我参加竞赛，只想吃保底，那最后排名多少都无所谓了。</p>
<p> 我们当然不能否定在这些关键事件上失败的消极后果在某些时候起到的积极作用，但总体来说，我们并不希望这些关键事件的后果对我们的人生轨迹造成太大影响。如果能把这些关键事件在我们人生中的权重降低，当然是一个好方法（例如如果保研失败就选择出国），但是，许多时候这些事情的重要性是我们无法掌控的。把一个结果为二值的事件转化为结果为连续函数的事件，是有意义的。</p>
<p> 以保研为例，保研的限制因素有两个，即目标院校是否给你发了offer和本科院校是否给你分配保研名额。大多情况下，本科院校的保研名额是争执的焦点。如果你足够NB，当自己获得本校保研名额成为既定事实以后，保研事件的结果就只剩哪个目标院校给你发offer了。此时，事件的结果可以认为是连续函数，而由于本科院校这一保底offer的存在，即使没有拿到心仪的offer，倒也无妨。</p>
<p>以上。</p>
]]></content>
      <categories>
        <category>杂思</category>
      </categories>
      <tags>
        <tag>人生选择</tag>
      </tags>
  </entry>
  <entry>
    <title>从头建立Hexo博客系统：一个懒人脚本</title>
    <url>/2022/09/28/%E4%BB%8E%E5%A4%B4%E5%BB%BA%E7%AB%8Bhexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%87%92%E4%BA%BA%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>2023年之前的博客系统是基于wordpress建立的，而Hexo作为另一个广为人知的博客系统（参考：<a href="https://zhuanlan.zhihu.com/p/102592286">从零开始搭建个人博客</a>），之前研究的不多。</p>
<p>最近倒是整了点歪门邪道，搞出来了一个脚本出来。这个脚本主要面向懒人和Hexo的小白用户，帮助实现Hexo博客系统本地仓库的一键构建，与GitHub deploy相关参数的配置。<strong>使用方法也很简单，将代码中标为橙色的几个shell变量改成自己的变量，然后<code>chmod +x</code>，之后直接在命令行窗口中运行就行。</strong></p>
<span id="more"></span>

<hr>
<p>我们假设读者已经对命令行操作有所了解，并已经在电脑上安装了<code>nodejs</code>和<code>npm</code>。此外，还需要准备下面的东西：<strong>一个用于存放博客源代码的空文件夹</strong>，<strong>一个已经注册好的GitHub账户</strong>，以及<strong>一个GitHub Pages存储库</strong>。（理论上其他代码托管平台例如Gitee，GitLab的Pages服务也可以，但是可能需要个人提前踩坑，因此无脑选GitHub总还是好的）</p>
<p>然后，将下面这段代码复制下来，粘贴到一个文本文件中，并命名为<code>init_blog.sh</code>。</p>
<hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 本shell脚本的目标是建立一个自动化搭建博客站点的流程，包括环境初始化、设置NexT主题，以及GitHub 账号设置。</span></span><br><span class="line"><span class="comment"># 部分变量值需要手动修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#===========================================================================</span></span><br><span class="line"><span class="comment"># -------------------- 以下段落中的变量需要手动修改 ------------------------</span></span><br><span class="line"><span class="comment">## 0. 部分博客信息的设置。需要手动修改</span></span><br><span class="line">BLOG_NAME=<span class="string">&quot;Blog_name&quot;</span> <span class="comment">#改成博客系统的源代码文件夹的名字</span></span><br><span class="line"><span class="comment"># 不要带空格、英文逗号、英文引号，不然可能会造成bug；可以用下划线和中文标点代替</span></span><br><span class="line"></span><br><span class="line">REPO=<span class="string">&quot;https://github.com/username/username.github.io.git&quot;</span></span><br><span class="line"><span class="comment"># GitHub存储库的地址。在GitHub存储库里点右上角那个绿色的&quot;Code&quot;按钮复制就能得到。</span></span><br><span class="line"></span><br><span class="line">BRANCH=<span class="string">&quot;main&quot;</span></span><br><span class="line"><span class="comment"># GitHub存储库的代码分支。因为有些存储库是main作为主分支，有些则是master作为主分支。建议去GitHub存储库检查一下分支名称是什么。</span></span><br><span class="line"></span><br><span class="line">EMAIL=<span class="string">&quot;user@institute.com&quot;</span></span><br><span class="line"><span class="comment"># GitHub账户绑定的邮箱</span></span><br><span class="line"></span><br><span class="line">USERNAME=<span class="string">&quot;username&quot;</span></span><br><span class="line"><span class="comment"># GitHub的账户名称，例如cyclinbox或者Hazelandinstant</span></span><br><span class="line"></span><br><span class="line">TOKEN=<span class="string">&quot;token&quot;</span></span><br><span class="line"><span class="comment"># GitHub的账户令牌，在`Settings -&gt; Developer settings -&gt; Personal access tokens`处获得</span></span><br><span class="line"><span class="comment"># -------------------- 以上段落中的变量需要手动修改 ------------------------</span></span><br><span class="line"><span class="comment">#===========================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 1. 新建一个目录，用于存放博客源代码</span></span><br><span class="line"><span class="built_in">mkdir</span> <span class="variable">$BLOG_NAME</span></span><br><span class="line"><span class="built_in">cd</span>    <span class="variable">$BLOG_NAME</span></span><br><span class="line">hexo init  --no-clone</span><br><span class="line"></span><br><span class="line"><span class="comment">## 2. 新建一个页面看看：</span></span><br><span class="line">hexo new First_Page</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello World\! This is my First blog\!&quot;</span> &gt;&gt; <span class="built_in">source</span>/_posts/First-Page.md</span><br><span class="line"></span><br><span class="line"><span class="comment">## 3. 安装Next主题</span></span><br><span class="line">npm install hexo-theme-next</span><br><span class="line"><span class="comment"># 此时的安装路径为`node_modules/hexo-theme-next`</span></span><br><span class="line"><span class="comment"># 应该是不需要做其他改动的，例如不用把这个文件夹移动到theme下面。（不然可能会报错？）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 4. 然后在_config.yml文件中修改主题。下面的代码可以自动完成这个过程。</span></span><br><span class="line"><span class="comment"># 这一步也可以通过直接修改_config.yml文件第100行的 theme 的内容实现。</span></span><br><span class="line">sed -e <span class="string">&#x27;s/theme: landscape/theme: next/&#x27;</span> _config.yml &gt; _config.yml.new</span><br><span class="line"><span class="built_in">mv</span>  _config.yml.new  _config.yml</span><br><span class="line"></span><br><span class="line"><span class="comment">## 5. 修改GitHub存储库的信息</span></span><br><span class="line">sed -e <span class="string">&quot;s/  type: &#x27;&#x27;/  type: git/&quot;</span> _config.yml &gt; _config.yml.new</span><br><span class="line"><span class="built_in">mv</span>  _config.yml.new  _config.yml</span><br><span class="line"><span class="comment">#echo &quot;- type: git&quot;             &gt;&gt; _config.yml</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;  repo: <span class="variable">$&#123;REPO&#125;</span>&quot;</span>          &gt;&gt; _config.yml</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;  branch: <span class="variable">$&#123;BRANCH&#125;</span>&quot;</span>      &gt;&gt; _config.yml</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;  token: <span class="variable">$&#123;TOKEN&#125;</span>&quot;</span>        &gt;&gt; _config.yml</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;  name: <span class="variable">$&#123;USERNAME&#125;</span>&quot;</span>      &gt;&gt; _config.yml</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;  email: <span class="variable">$&#123;EMAIL&#125;</span>&quot;</span>        &gt;&gt; _config.yml</span><br><span class="line"></span><br><span class="line"><span class="comment">## 6. 安装hexo-deployer-git插件，否则使用hexo deploy指令时会报错</span></span><br><span class="line">npm install --save hexo-deployer-git</span><br><span class="line"><span class="comment"># 不出意外还得初始化一下存储库</span></span><br><span class="line">git init</span><br><span class="line">git config user.email <span class="variable">$&#123;EMAIL&#125;</span></span><br><span class="line">git config user.name <span class="variable">$&#123;USERNAME&#125;</span></span><br><span class="line">git remote add origin <span class="variable">$&#123;REPO&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 7. 大功告成！</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;博客系统初始化完成！执行下列指令发布第一篇博客吧~&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;cd <span class="variable">$&#123;BLOG_NAME&#125;</span>;hexo deploy&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;执行hexo --help查看更多帮助&quot;</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;如果提示没有配置远程rsa密钥，则使用下列方法获得密钥后，复制公钥内容到github个人设置中的SSH and GPG keys中的 New SSH key中：&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ssh-keygen -t rsa -C <span class="variable">$&#123;EMAIL&#125;</span> #一路回车就行，不用管提示&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;cat ~/.ssh/id_rsa.pub #这个就是公钥内容&quot;</span></span><br><span class="line"><span class="built_in">echo</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;如果遇到其他错误，例如无法合并远程分支，或者其他莫名其妙的报错，可以根据报错内容，在互联网上搜索解决方案，或求助于其他人&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;谢谢您的使用，再会~&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<p>之后按照自己的实际情况，修改上面第一部分的几个shell变量的内容，保存后使用<code>chmod +x</code>授予可执行权限，之后执行即可。</p>
<p>这样我们就得到了一个NexT主题的Hexo博客系统了~</p>
<p>至于之后的更高级配置，可以参考 <a href="https://zhuanlan.zhihu.com/p/106060640">个人博客第8篇——优化主题</a> 这篇文章，以及有空的话也可以自己折腾呀~</p>
<p>最终效果（这个是我用自己的<a href="https://cyclinbox.github.io/">GitHub Page</a>演示的，但目前的博客还是用现在这个。或许未来某天，我也会选择换到Hexo，谁知道呢？）：</p>
<p><img src="https://pic.imgdb.cn/item/6540ff62c458853aef3228ee.jpg" alt="blog example"></p>
<p>以上。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>Hexo</tag>
        <tag>shell编程</tag>
      </tags>
  </entry>
  <entry>
    <title>使用ggtree绘制系统发育树</title>
    <url>/2022/07/26/%E4%BD%BF%E7%94%A8ggtree%E7%BB%98%E5%88%B6%E7%B3%BB%E7%BB%9F%E5%8F%91%E8%82%B2%E6%A0%91/</url>
    <content><![CDATA[<p>绘制系统发育树的方法</p>
<span id="more"></span>


<h2 id="一、基本概念：nwk格式文件"><a href="#一、基本概念：nwk格式文件" class="headerlink" title="一、基本概念：nwk格式文件"></a>一、基本概念：nwk格式文件</h2><p>nwk格式是一种存储系统发育树的格式，更具体的信息可以参考<a href="https://evolution.genetics.washington.edu/phylip/newicktree.html">https://evolution.genetics.washington.edu/phylip/newicktree.html</a>。在这一类型的文件中，系统发育树的节点和分支由圆括号的层次关系所表示。</p>
<p>一颗系统发育树的表达式以分号结尾，用圆括号和逗号标记节点和分支。节点名称可以为空，也可以是一串可打印字符，但是不能包含空格、逗号、分号、圆括号和方括号。</p>
<p>一种拓展的表示方法是在节点名称后加分支长度，二者以冒号隔开。例如</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(B:6.0,(A:5.0,C:3.0,E:4.0):5.0,D:11.0);</span><br></pre></td></tr></table></figure>

<p>另外，由于分支和节点除了拓扑关系以外，不存在其他的排序问题，因此对于同一棵数，可以有多种表示方法。例如，下面五条表达式，所表达的是同一棵树。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(A,(B,C),D);    </span><br><span class="line">(A,(C,B),D);    </span><br><span class="line">(D,(C,B),A);    </span><br><span class="line">(D,A,(C,B));    </span><br><span class="line">((C,B),A,D);</span><br></pre></td></tr></table></figure>

<h2 id="二、使用ggtree绘制系统发育树"><a href="#二、使用ggtree绘制系统发育树" class="headerlink" title="二、使用ggtree绘制系统发育树"></a>二、使用ggtree绘制系统发育树</h2><p>ggtree是一个基于ggplot的R包，可以在R中对系统发育树进行可视化。</p>
<p>具体使用说明可以参考<a href="https://bioconductor.org/packages/release/bioc/vignettes/ggtree/inst/doc/ggtree.html">bioconductor上的主页</a>和<a href="https://yulab-smu.top/treedata-book/">treedata-book文档</a>进行了解。</p>
<p>安装方法：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">BiocManager<span class="operator">::</span>install<span class="punctuation">(</span><span class="string">&quot;ggtree&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>一个简单的例子：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span><span class="string">&quot;ggtree&quot;</span><span class="punctuation">)</span></span><br><span class="line">mytree <span class="operator">&lt;-</span> read.tree<span class="punctuation">(</span><span class="string">&quot;ggtree_test.tree&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## file content of &quot;ggtree_test.tree&quot;:</span></span><br><span class="line"><span class="comment"># ((seq0:0.01222,((((seq1:0.13069,((seq3:0.09087,seq8:0.14246):0.01517,seq13:0.09038):0.01931):0.00424,seq14:0.14715):0.01204,(seq6:0.10536,seq10:0.18353):0.00463):0.00946,((seq2:0.14280,seq11:0.09053):0.01233,(seq7:0.09201,seq15:0.14132):0.02656):0.00825):0.00566):0.00167,seq4:0.10935,((seq5:0.10304,seq12:0.16363):0.01016,seq9:0.05095):0.00454);</span></span><br><span class="line"></span><br><span class="line">svg<span class="punctuation">(</span><span class="string">&quot;ggtree_test.svg&quot;</span><span class="punctuation">)</span></span><br><span class="line">myfig <span class="operator">&lt;-</span> ggtree<span class="punctuation">(</span>mytree<span class="punctuation">,</span>layout <span class="operator">=</span> <span class="string">&quot;rectangular&quot;</span><span class="punctuation">)</span> <span class="operator">+</span> geom_tiplab<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span> geom_point<span class="punctuation">(</span>color<span class="operator">=</span><span class="string">&#x27;firebrick&#x27;</span><span class="punctuation">)</span></span><br><span class="line">myfig <span class="comment"># show plot</span></span><br><span class="line">dev.off<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>上面的代码读取了<code>ggtree_test.tree</code>这个文件，并使用ggtree()这个函数实现了可视化。为了后期修图方便，此处我们将其保存为svg矢量图格式。得到的结果如下图所示。</p>
<p><img src="https://pic.imgdb.cn/item/657ecebcc458853aef31cc26.png" alt="ggtree plot"></p>
<p>ggtree包依赖于ggplot，因此一些针对ggplot的图片参数调整方法同样适用于ggtree。例如，我们可以通过下面的代码，得到一棵更加美观的树。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">myfig2 <span class="operator">&lt;-</span> ggtree<span class="punctuation">(</span>mytree<span class="punctuation">,</span>layout <span class="operator">=</span> <span class="string">&quot;circular&quot;</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">	geom_tiplab<span class="punctuation">(</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">	geom_highlight<span class="punctuation">(</span>node <span class="operator">=</span> <span class="number">10</span><span class="punctuation">,</span>fill<span class="operator">=</span><span class="string">&quot;blue &quot;</span><span class="punctuation">,</span>alpha<span class="operator">=</span><span class="number">0.5</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">	geom_highlight<span class="punctuation">(</span>node<span class="operator">=</span><span class="number">9</span><span class="punctuation">,</span>fill<span class="operator">=</span><span class="string">&quot; orange&quot;</span><span class="punctuation">,</span> alpha<span class="operator">=</span><span class="number">0.5</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">	geom_highlight<span class="punctuation">(</span>node<span class="operator">=</span><span class="number">8</span><span class="punctuation">,</span>fill<span class="operator">=</span><span class="string">&quot; red &quot;</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">	geom_cladelabel<span class="punctuation">(</span>node<span class="operator">=</span><span class="number">3</span><span class="punctuation">,</span>label<span class="operator">=</span><span class="string">&quot;Virtual creature 1&quot;</span><span class="punctuation">,</span>offset<span class="operator">=</span><span class="number">0.048</span><span class="punctuation">,</span>barsize <span class="operator">=</span> <span class="number">4</span><span class="punctuation">,</span>color<span class="operator">=</span><span class="string">&quot;blue&quot;</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">	geom_cladelabel<span class="punctuation">(</span>node<span class="operator">=</span><span class="number">4</span><span class="punctuation">,</span>label<span class="operator">=</span><span class="string">&quot;Virtual creature 2&quot;</span><span class="punctuation">,</span>offset<span class="operator">=</span><span class="number">0.048</span><span class="punctuation">,</span>barsize <span class="operator">=</span> <span class="number">4</span><span class="punctuation">,</span>color<span class="operator">=</span><span class="string">&quot;green&quot;</span><span class="punctuation">,</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">	geom_cladelabel<span class="punctuation">(</span>node<span class="operator">=</span><span class="number">5</span><span class="punctuation">,</span>label<span class="operator">=</span><span class="string">&quot;Virtual creature 3&quot;</span><span class="punctuation">,</span>offset<span class="operator">=</span><span class="number">0.048</span><span class="punctuation">,</span>barsize <span class="operator">=</span> <span class="number">4</span><span class="punctuation">,</span>color<span class="operator">=</span><span class="string">&quot;red&quot;</span><span class="punctuation">)</span></span><br><span class="line">myfig2</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.imgdb.cn/item/657ecf92c458853aef344936.jpg" alt="ggtree plot with decoration"></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>ggtree</tag>
        <tag>R语言学习</tag>
        <tag>系统发育树</tag>
      </tags>
  </entry>
  <entry>
    <title>使用ffmpeg工具将字幕嵌入视频中</title>
    <url>/2022/08/11/%E4%BD%BF%E7%94%A8ffmpeg%E5%B7%A5%E5%85%B7%E5%B0%86%E5%AD%97%E5%B9%95%E5%B5%8C%E5%85%A5%E8%A7%86%E9%A2%91%E4%B8%AD/</url>
    <content><![CDATA[<p>做视频必备</p>
<span id="more"></span>

<p>参考： <a href="https://zhuanlan.zhihu.com/p/61853454">ffmpeg怎么把字幕烧进视频里面 - 路人乙小明的文章 - 知乎</a></p>
<p>ffmpeg是一个强大的开源视频处理工具，市面上很流行的格式工厂、QQ影音等工具中都有它的身影。</p>
<p>srt是一种字幕格式，其以一段文字的开始和结束时间为标记，从而记录字幕与时间轴，一个例子如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">00:00:05,220 --&gt; 00:00:14,470</span><br><span class="line">遗传学已经非常成功地确定了基因组中与疾病风险改变相关的许多区域</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line">00:00:14,480 --&gt; 00:00:26,551</span><br><span class="line">当我们想从全基因组关联研究或GWAS中提取基因，并</span><br><span class="line">将其转化为某种临床影响，例如开发新疗法时</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">00:00:26,575 --&gt; 00:00:30,071</span><br><span class="line">知道这些疾病的机制对我们来说就变得很重要</span><br></pre></td></tr></table></figure>

<p>要将字幕嵌入到视频中，有很多种方法。其中，兼容性最强的方法就是直接把字幕渲染成为视频的一部分。这个任务可以交给ffmpeg完成。</p>
<p>譬如说，我们有一个视频文件<code>input.mp4</code>，和一个字幕文件<code>subtitle.srt</code>，要想得到一个有字幕的视频，可以采用下面的指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -vf subtitles=subtitle.srt output.mp4</span><br></pre></td></tr></table></figure>

<p>这会渲染出一个带字幕的视频，文件名为output.mp4</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python和SciPy解决线性规划问题</title>
    <url>/2022/09/29/%E4%BD%BF%E7%94%A8python%E5%92%8Cscipy%E8%A7%A3%E5%86%B3%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>Python是一种很流行的编程语言，由于其语法简单而功能强大，已被广泛使用。目前的最新版本是3.10。</p>
<p>SciPy是一个Python的软件包，其基于NumPy软件包扩展了大量功能，包括统计方法、信号处理、线性代数以及规划问题。最新版本为1.9.1。</p>
<p>本文将基于Python这一编程语言以及Scipy这一软件包，说明如何使用这二者进行线性规划问题的求解。</p>
<span id="more"></span>

<h2 id="0、准备（Python和SciPy的安装）"><a href="#0、准备（Python和SciPy的安装）" class="headerlink" title="0、准备（Python和SciPy的安装）"></a>0、准备（Python和SciPy的安装）</h2><h3 id="1-Python的安装"><a href="#1-Python的安装" class="headerlink" title="(1) Python的安装"></a>(1) Python的安装</h3><p>有多种方法可以安装Python，这里列举两个方法。</p>
<ol>
<li> 从Python<a href="https://www.python.org/downloads/">官方网站</a>安装。点击网页上的Download按钮，下载安装包，然后直接执行安装即可。<strong>（比较麻烦，不推荐）</strong></li>
<li> 安装<a href="https://anaconda.org/">Anaconda</a>。Anaconda是一个优秀的Python发行版，内置了大量科学计算和数据分析的软件包，并带有<code>conda</code>这一包管理器和<code>Jupyter</code>这一IDE，是数据分析的首选。从<a href="https://www.anaconda.com/products/distribution">官方网站</a>下载安装包，然后直接执行安装即可。<strong>（推荐）</strong></li>
</ol>
<h3 id="2-SciPy的安装"><a href="#2-SciPy的安装" class="headerlink" title="(2) SciPy的安装"></a>(2) SciPy的安装</h3><p>如果已经安装了Anaconda，则无需进行这一步，Anaconda已经打包了SciPy在自己的发行版中。</p>
<p>如果安装的是Python，可以使用下面的方法安装。首先，确定<code>Python</code>和<code>pip</code>已经被加载到环境变量中；然后，打开一个命令行窗口（Windows的“命令提示符”和macOS的“终端”），输入下面的指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install scipy  -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"><span class="comment"># 其中，-i 参数指明使用清华大学软件源进行安装，以提高下载速度</span></span><br></pre></td></tr></table></figure>

<p>即可执行安装。</p>
<h2 id="1、快速上手"><a href="#1、快速上手" class="headerlink" title="1、快速上手"></a>1、快速上手</h2><p>SciPy提供的线性规划计算工具为<code>scipy.optimize.linprog</code>函数。因此要想计算线性规划问题，需要按照要求导入scipy这一软件包</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linprog</span><br></pre></td></tr></table></figure>

<p>与我们在教科书中学习到的形式略有不同，SciPy中的线性规划问题形式如下：</p>
<p>$$<br>\begin{align}<br>min\ z =c^{T}x ; \\<br>s.t.\ ,\\<br>A_{ub}x \le b_{ub}\ , \\<br>A_{eq}x = b_{eq}\ ,    \\<br>l \le x \le u<br>\end{align}<br>$$</p>
<p>其中，$x$是待求解的决策变量向量；$c,\ b_{ub},\ b_{eq},\ l,\ u$均为向量，而$A_{ub},\ A_{eq}$均为矩阵。<strong>在SciPy中，线性规划的目标是最小化目标函数的值，这与我们在教材上学到的最大化刚好相反，因此在构造线性规划问题的参数向量时，目标函数的系数应该取实际问题的相反数。</strong></p>
<p>以一个实际问题为例（参考<a href="https://docs.scipy.org/doc/scipy/tutorial/optimize.html#linear-programming-linprog">SciPy官方文档</a>）：</p>
<p>$$<br>\begin{align}<br>max\ z=29x_{1}+45x_{2};  \\<br>s.t.\ ,   \\<br>x_1-x_2-3x_3 \le 5 \ ,\\<br>2x_2-3x_2-7x_3+3x_4 \ge 10 \ ,\\<br>2x_1+8x_2+x_3=60 \ , \\<br>4x_1+4x_2+x_4=60 \ ,\\<br>0 \le x_1 \ ,\\<br>0 \le x_2 \le 5 \ ,\\<br>x_3 \le 0.5 \ ,\\<br>-3 \le x_4<br>\end{align}<br>$$</p>
<p>在上面这个问题中，我们的目标是最大化目标函数$z$，因此为了使用SciPy求解，我们必须对目标函数的系数向量取相反数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = np.array([-<span class="number">29.0</span>, -<span class="number">45.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>])</span><br></pre></td></tr></table></figure>

<p>在约束条件中，有几个不等式，我们将其全部化成小于等于的形式，得到约束条件的系数矩阵<code>A_ub</code>和列向量<code>b_ub</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A_ub = np.array([[<span class="number">1.0</span>, -<span class="number">1.0</span>, -<span class="number">3.0</span>, <span class="number">0.0</span>],</span><br><span class="line">                [-<span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">7.0</span>, -<span class="number">3.0</span>]])</span><br><span class="line">b_ub = np.array([<span class="number">5.0</span>, -<span class="number">10.0</span>])</span><br></pre></td></tr></table></figure>

<p>在约束条件中，还有几个等式，我们能够得到约束条件的系数矩阵<code>A_eq</code>和列向量<code>b_eq</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A_eq = np.array([[<span class="number">2.0</span>, <span class="number">8.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>],</span><br><span class="line">                [<span class="number">4.0</span>, <span class="number">4.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>]])</span><br><span class="line">b_eq = np.array([<span class="number">60.0</span>, <span class="number">60.0</span>])</span><br></pre></td></tr></table></figure>

<p>此外，我们注意到，变量 $x_1$ 到 $x_4$ 还有取值范围的限制。因此这一项也应该被我们考虑进去。我们使用一个一维数组存储 $x_1$ 到 $x_4$ 的取值范围，其中每个变量的取值范围用一个<a href="https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences">元组（Tuple）</a>进行存储</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x1_bounds = (<span class="number">0</span>, <span class="literal">None</span>)       <span class="comment"># None代表可以取到无穷大</span></span><br><span class="line">x2_bounds = (<span class="number">0</span>, <span class="number">5.0</span>)</span><br><span class="line">x3_bounds = (-np.inf, <span class="number">0.5</span>)  <span class="comment"># +/- np.inf 可以代替None用以表示无穷大或者无穷小</span></span><br><span class="line">x4_bounds = (-<span class="number">3.0</span>, <span class="literal">None</span>)</span><br><span class="line">bounds = [x1_bounds, x2_bounds, x3_bounds, x4_bounds]  <span class="comment"># 这个数组存储了变量x1到x4的取值范围。</span></span><br></pre></td></tr></table></figure>

<p>之后，用一行代码即可完成线性规划的求解</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 别忘了   import numpy as np</span></span><br><span class="line"><span class="comment"># 也别忘了 from scipy.optimize import linprog</span></span><br><span class="line">result = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds)</span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># 输出求解结果</span></span><br></pre></td></tr></table></figure>

<p>SciPy给出的结果如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">    con: array([15.53611731, 16.61287584])</span><br><span class="line">    fun: -370.23223964124924</span><br><span class="line">message: &#x27;The algorithm terminated successfully and determined that the problem</span><br><span class="line">          is infeasible.&#x27;</span><br><span class="line">    nit: 6</span><br><span class="line">  slack: array([ 0.79315063, -1.76308707])</span><br><span class="line"> status: 2</span><br><span class="line">success: False</span><br><span class="line">      x: array([ 6.60059411,  3.9736669 , -0.52664072,  1.09008012])</span><br></pre></td></tr></table></figure>

<p>看到那个<code>success: False</code>了吗？这意味着我们的问题没有可行解。这并不一定意味着我们做错了，因为一些问题确实不存在可行解。但是，也许我们将条件放宽一点，例如令 <code>0 &lt;= x_2 &lt;= 6</code> ，就能得到可行解。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x2_bounds = (<span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line">bounds = [x1_bounds, x2_bounds, x3_bounds, x4_bounds]</span><br><span class="line">result = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<p>SciPy给出的结果如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">    con: array([9.79743930e-09, 1.04769242e-08])</span><br><span class="line">    fun: -505.97435889005345</span><br><span class="line">message: &#x27;Optimization terminated successfully.&#x27;</span><br><span class="line">    nit: 4</span><br><span class="line">  slack: array([ 6.53052723e-10, -2.26972219e-09])</span><br><span class="line"> status: 0</span><br><span class="line">success: True</span><br><span class="line">      x: array([ 9.41025641,  5.17948718, -0.25641026,  1.64102564])</span><br></pre></td></tr></table></figure>

<p>这回确实得到了可行解。我们看一下目标函数的值是多少：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.array(result.x)</span><br><span class="line"><span class="built_in">print</span>(c @ x) <span class="comment"># @运算符是NumPy软件包中的点乘运算符</span></span><br><span class="line"><span class="comment"># out: -505.97435889005345</span></span><br></pre></td></tr></table></figure>

<h2 id="2、函数原型与参数含义"><a href="#2、函数原型与参数含义" class="headerlink" title="2、函数原型与参数含义"></a>2、函数原型与参数含义</h2><p>我们现在研究一下<code>scipy.optimize.linprog</code>这个函数，以便学习其用法。</p>
<p>参考<a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.linprog.html#scipy-optimize-linprog">SciPy文档</a>，这一函数的原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scipy.optimize.linprog(c, A_ub=<span class="literal">None</span>, b_ub=<span class="literal">None</span>, A_eq=<span class="literal">None</span>, b_eq=<span class="literal">None</span>, </span><br><span class="line">        bounds=<span class="literal">None</span>, method=<span class="string">&#x27;highs&#x27;</span>, callback=<span class="literal">None</span>, options=<span class="literal">None</span>, x0=<span class="literal">None</span>, </span><br><span class="line">        integrality=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>接下来，我们逐一分析相关参数。首先是与线性规划问题紧密相关的5个参数：</p>
<ul>
<li><p>  <code>c</code>：一个一维数组（向量），代表目标函数的系数向量</p>
</li>
<li><p>  <code>A_ub</code>：一个二维数组（矩阵），是不等式约束条件的系数矩阵</p>
</li>
<li><p>  <code>b_ub</code>：一个一维数组（向量），是不等式约束条件的资源向量</p>
</li>
<li><p>  <code>A_eq</code>：一个二维数组（矩阵），是等式约束条件的系数矩阵</p>
</li>
<li><p>  <code>b_eq</code>：一个一维数组（向量），是等式约束条件的资源向量</p>
</li>
<li><p>  <code>bounds</code>：一个元组类型的一维数组，每一个元组都定义了一个决策变量 $x_i$ 的取值范围<code>(min, max)</code>，可以在元组中使用<code>None</code>代表正负无穷（例如，<code>(None, 0)</code>代表取值范围为负无穷大到0）。这是一个可选参数，如果不给出，则默认值为<code>(0, None)</code>，即0到正无穷大。</p>
</li>
<li><p>  <code>method</code>：字符串，指定求解方法，默认值为<code>&#39;highs&#39;</code>，可选择的其他方法包括<code>&#39;highs-ds&#39;</code>，<code>&#39;highs-ipm&#39;</code>，<code>&#39;interior-point&#39;</code>，<code>&#39;revised simplex&#39;</code>以及<code>&#39;simplex&#39;</code>。这一参数将在SciPy的1.11.0以后的版本中废除。</p>
</li>
<li><p>  <code>x0</code>：一个一维数组（向量），代表一个初始基可行解。这个参数目前只在<code>&#39;revised simplex&#39;</code>方法中被用到，因此可以不给出。</p>
</li>
<li><p><code>integrality</code>：一个一维数组，指定每个决策变量的取整约束条件，默认是不存在取整约束。这个参数仅在<code>highs</code>方法中被用到。对每一个决策变量，不同的取整约束如下：</p>
<ul>
<li>  <code>0</code>：连续变量，可以取到取值范围内的所有实数，不存在取整约束。</li>
<li>  <code>1</code>：整数变量，只能取到取值范围内的所有整数。</li>
<li>  <code>2</code>：半连续变量，可以取到取值范围内的所有实数，以及0。</li>
<li>  <code>3</code>：半整数变量，只能取到取值范围内的所有整数，以及0。</li>
</ul>
</li>
</ul>
<p>此外，还有两个可选参数<code>callback</code>和<code>options</code>，这两个参数包含一些与程序运行以及返回值有关的选项，而与线性规划问题本身无关，因此本文略过。</p>
<h2 id="3、返回值"><a href="#3、返回值" class="headerlink" title="3、返回值"></a>3、返回值</h2><p>线性规划求解函数<code>scipy.optimize.linprog</code>的返回值是一个<code>scipy.optimize.optimize.OptimizeResult</code>类型的对象，其包含下列属性：</p>
<ul>
<li>  <code>x</code>：决策变量的值。如果问题存在可行解的话，<code>x</code>就是一个可行解。</li>
<li>  <code>fun</code>：目标函数的值，也就是<code>c@x</code>（向量CCC点乘向量XXX）的结果。</li>
<li>  <code>slack</code>：不等式约束中，松弛变量的值，原则上是正的。其等于<code>b_ub-A_ub@x</code>。</li>
<li>  <code>con</code>：等式约束中，残差的值，原则上等于0。其等于<code>b_eq-A_eq@x</code></li>
<li>  <code>success</code>：一个布尔变量，代表是否找到了最优解。</li>
<li><code>status</code>：状态码。含义如下：<ul>
<li>  <code>0</code>：成功找到最优解</li>
<li>  <code>1</code>：达到了迭代次数的最大限制</li>
<li>  <code>2</code>：问题似乎无解</li>
<li>  <code>3</code>：问题似乎存在无界解</li>
<li>  <code>4</code>：遇到了数值困难</li>
</ul>
</li>
<li>  <code>nit</code>：迭代次数</li>
<li>  <code>message</code>：对问题求解结果的文字描述。</li>
</ul>
<h2 id="4、例题"><a href="#4、例题" class="headerlink" title="4、例题"></a>4、例题</h2><p>某工厂在计划期内要安排生产I、II两种产品，已知生产单位产品所需设备台时及原材料消耗如下表所示</p>
<table>
<thead>
<tr>
<th>资源</th>
<th>产品I</th>
<th>产品II</th>
<th>现有条件</th>
</tr>
</thead>
<tbody><tr>
<td>设备</td>
<td>1台时/件</td>
<td>2台时/件</td>
<td>8台时</td>
</tr>
<tr>
<td>原材料A</td>
<td>4kg/件</td>
<td>0</td>
<td>16kg</td>
</tr>
<tr>
<td>原材料B</td>
<td>0</td>
<td>4kg/件</td>
<td>12kg</td>
</tr>
</tbody></table>
<p>该工厂每生产一件产品I可获利2元，每生产一件产品II可获利3元，如何安排生产计划使得该工厂获利最多？</p>
<h3 id="解："><a href="#解：" class="headerlink" title="解："></a>解：</h3><p>我们建立上述问题的线性规划数学模型，编写程序如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linprog</span><br><span class="line">c = np.array([-<span class="number">2.0</span>, -<span class="number">3.0</span>])</span><br><span class="line">A_ub = np.array([[<span class="number">1.0</span>, <span class="number">2.0</span>],</span><br><span class="line">                [<span class="number">4.0</span>, <span class="number">0.0</span>],</span><br><span class="line">                [<span class="number">0.0</span>, <span class="number">4.0</span>]])</span><br><span class="line">b_ub = np.array([<span class="number">8.0</span>, <span class="number">16.0</span>, <span class="number">12.0</span>])</span><br><span class="line">result = linprog(c, A_ub=A_ub, b_ub=b_ub)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<p>程序的运行结果如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">    con: array([], dtype=float64)</span><br><span class="line">    fun: -13.999999982532964</span><br><span class="line">message: &#x27;Optimization terminated successfully.&#x27;</span><br><span class="line">    nit: 4</span><br><span class="line">  slack: array([1.02599227e-08, 1.66172107e-08, 4.00000001e+00])</span><br><span class="line"> status: 0</span><br><span class="line">success: True</span><br><span class="line">      x: array([4., 2.])</span><br></pre></td></tr></table></figure>

<p>我们可以看到，SciPy成功帮助我们求出了最优解，即x1=4,x2=2，此时目标函数值 z=−z1=13.999≈14 ，也就是说，原问题的最大利润值是14元。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>线性规划</tag>
        <tag>运筹学</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>使用高斯消元法求解线性方程组</title>
    <url>/2022/10/27/%E4%BD%BF%E7%94%A8%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</url>
    <content><![CDATA[<p>作为矩阵运算的一个应用，高斯消元法在线性方程组求解中发挥着重要的作用。高斯消元法的本质，是通过一系列线性变换，将线性方程组的系数矩阵变为上三角矩阵或者下三角矩阵，进而通过回代的方法得到所有变量的值。本文作为一篇抛砖引玉的介绍，将简要说一下如何在一个具体的线性方程组上应用高斯消元法，并给出一个python程序用于展示编程求解线性方程组的方法。</p>
<span id="more"></span>

<h2 id="一、矩阵、矩阵的线性变换"><a href="#一、矩阵、矩阵的线性变换" class="headerlink" title="一、矩阵、矩阵的线性变换"></a>一、矩阵、矩阵的线性变换</h2><p>矩阵的本质是一个数据表。例如，下面的这个上三角矩阵（主对角线以下都是零的矩阵）就是一个3×3的数据表。 $$ \left[ \begin{matrix} 1 &amp; 2 &amp; 3 \\ 0 &amp; 5 &amp; 6 \\ 0 &amp; 0 &amp; 9\\ \end{matrix} \right] $$ 矩阵的线性变化包括初等行变换和初等列变换。初等行变换包括三种变换：（1）对换两行（例如，对换矩阵中\(i\)和\(j\)两行，记作\(r_i \leftrightarrow r_j\)）；（2）以一个非零实数乘某一行的所有元素（例如，第\(i\)行乘\(k\)，记作\(r_i\times k\)）；（3）把某一行的所有元素的\(k\)倍加到另一行上（例如第\(j\)行的\(k\)倍加到第\(i\)行，记作\(r_i+kr_j\)）。列变换也包括三种变化，将上述行变换的“行”换成“列”，就得到了初等列变换。</p>
<h2 id="二、高斯消元法"><a href="#二、高斯消元法" class="headerlink" title="二、高斯消元法"></a>二、高斯消元法</h2><p>高斯消元法(Gaussian elimination)是求解线性方阵组的一种算法。它通过逐步消除未知数来将原始线性系统转化为另一个更简单的等价的系统。它的实质是通过初等行变化，将线性方程组的增广矩阵转化为行阶梯矩阵。 我们举一个例子： $$ \begin{align} 2x +y -z &amp; =8 \\ -3x -y +2z &amp; =-11\\ -2x +y +2z &amp; =-3 \end{align} $$ 我们构造增广矩阵，也就是上述线性方程组的系数矩阵\(A\)加上常数向量\(b\)。 $$ \left[ \begin{matrix} 2 &amp; 1 &amp; -1&amp; 8 \\ -3&amp; -1&amp; 2 &amp; -11\\ -2&amp; 1 &amp; 2 &amp; -3\\ \end{matrix} \right] $$ 经过初等变换\(r_2-(-3/2)r_1,\ r_3-(-1)r_2\)得到 $$ \left[ \begin{matrix} 2 &amp; 1 &amp; -1&amp; 8 \\ 0 &amp; 1/2&amp;1/2&amp; 1 \\ 0 &amp; 2 &amp; 1 &amp; 5 \\ \end{matrix} \right] $$ 再经初等变换\(r_3-4r_2\)得到 $$ \left[ \begin{matrix} 2 &amp; 1 &amp; -1&amp; 8 \\ 0 &amp; 1/2&amp;1/2&amp; 1 \\ 0 &amp; 0 &amp; -1&amp; 1 \\ \end{matrix} \right] $$ 于是我们得到了一个简化的三角方程组。在这个三角方程组中，首先就可以得到变量z的值，进而得到y的值，最后得到x的值。 $$ \left( \begin{align} 2x +y -z &amp; =8 \\ 1/2y +1/2z &amp; = 1\\ -z &amp; = 1 \end{align} \right) \\ \Rightarrow z=-1,\ y=3,\ x=2 $$</p>
<h2 id="三、程序实现"><a href="#三、程序实现" class="headerlink" title="三、程序实现"></a>三、程序实现</h2><p>这里我们使用Python实现一个线性方程组的求解程序。这个程序的思想来自文章<a href="https://blog.csdn.net/lzyws739307453/article/details/89816311">《高斯消元法详解》</a>，并结合Python的一些特性进行了修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">## ======== 以下为高斯消元法的算法部分 ========</span><br><span class="line"># 参考代码：https://blog.csdn.net/lzyws739307453/article/details/89816311</span><br><span class="line"></span><br><span class="line"># 打印矩阵的内容</span><br><span class="line">def printM(a):</span><br><span class="line">    m = len(a)</span><br><span class="line">    n = len(a[0])</span><br><span class="line">    for i in range(0,m):</span><br><span class="line">        for j in range(0,n):</span><br><span class="line">            print(&quot;%10f,\t&quot;%a[i][j],end=&quot;&quot;)</span><br><span class="line">        print()</span><br><span class="line"></span><br><span class="line"># 选择列主元并消元</span><br><span class="line">def SelectColE(a): #a:2-dimension matrix; n:int </span><br><span class="line">    n = len(a) # 参数n应该代表的是矩阵的行数，也就是线性方程组的方程个数</span><br><span class="line">    for i in range(0,n): # 循环处理每一行的信息</span><br><span class="line">        r = i</span><br><span class="line">        for j in range(i,n):</span><br><span class="line">            if(abs(a[j][i])&gt;abs(a[r][i])): r=j</span><br><span class="line">        if(r!=i): # 当r!=i时，交换两行的内容。这里的操作基于以下逻辑：</span><br><span class="line">            # 由于单纯的高斯消元法会将矩阵化为梯形矩阵，靠下方的行中系数为0的项更多</span><br><span class="line">            # 而非0项也会有很多分母，在除法运算中会导致精度降低</span><br><span class="line">            # 因此将系数大的项尽可能的往前移动，可以提高精度</span><br><span class="line">            tmp  = a[r]</span><br><span class="line">            a[r] = a[i]</span><br><span class="line">            a[i] = tmp</span><br><span class="line">        for j in range(i+1,n): # 消元</span><br><span class="line">            temp = a[j][i]/a[i][i]</span><br><span class="line">            for k in range(i,n+1):</span><br><span class="line">                a[j][k] -= a[i][k]*temp</span><br><span class="line"></span><br><span class="line"># 高斯消元法</span><br><span class="line">def Gauss(a): </span><br><span class="line">    n = len(a) # 参数n应该代表的是矩阵的行数，也就是线性方程组的方程个数</span><br><span class="line">    SelectColE(a)</span><br><span class="line">    for i in range(n-1,-1,-1): # 回代求解</span><br><span class="line">        # i 从 n-1递减循环到0，可以取到0</span><br><span class="line">        # 从第n-1行循环到第0行。由于前面已经对矩阵进行了变换，得到了一个倒三角矩阵</span><br><span class="line">        # 所以n-1行可以直接求得第n-1个未知数的值（未知数的下标从0开始）</span><br><span class="line">        # 而前面的行则需要经过一些迭代</span><br><span class="line">        for j in range(i+1,n):  # 对行矩阵进行回代</span><br><span class="line">            # 在此行的最后一个元素处存储回代后的值</span><br><span class="line">            # a[i][n]是行矩阵的最后一个元素，是存储回代后的数值的地方</span><br><span class="line">            # a[i][i]是本行对应的未知数的系数。一共i行，那么就是i个未知数</span><br><span class="line">            # 例如一个3*4的矩阵，有3个变量分别是x0,x1,x2，那么当i=1时，</span><br><span class="line">            # 对应位置就是变量x1的系数</span><br><span class="line">            # 同样的，a[i][j]是本行第j个未知数的系数，</span><br><span class="line">            # 而第j个未知数的值刚刚我们已经求过了，是a[j][n]，</span><br><span class="line">            # 所以a[i][n]减去他俩相乘的值就行</span><br><span class="line">            a[i][n] -= a[i][j]*a[j][n]</span><br><span class="line">        # 回代结束后，对系数进行化简，使得第i个未知数的系数变为1，即可</span><br><span class="line">        # 于是第i个未知数的值就等于a[i][n]/a[i][i]。我们把它存储在a[i][n]的位置上</span><br><span class="line">        a[i][n] /= a[i][i]</span><br><span class="line"></span><br><span class="line">## ======== 以上为高斯消元法的算法部分 ========</span><br><span class="line"></span><br><span class="line"># 传入一个线性方程组的增广矩阵，这个函数将会调用高斯消元法的求解程序，并打印出求解结果。</span><br><span class="line">def run(A):</span><br><span class="line">    # 下面的内容是高斯消元法求解线性方程组的测试</span><br><span class="line">    # 最终的方程组的解为a[:,-1]</span><br><span class="line">    a = A.copy()</span><br><span class="line">    print(&#x27;a=\n&#x27;,np.array(a))</span><br><span class="line">    Gauss(a.copy())</span><br><span class="line">    print(&quot;求解结果：&quot;)</span><br><span class="line">    printM(a)</span><br><span class="line">    print(&quot;数据结构：&quot;)</span><br><span class="line">    printM(a)</span><br><span class="line">    for i in range(0,len(a)):</span><br><span class="line">        print(&quot;X%d = %9f&quot;%(i,a[i][3]))</span><br><span class="line">    print(np.array(a)[:,-1])</span><br><span class="line">    print(&#x27;\n\n&#x27;)</span><br><span class="line"></span><br><span class="line"># 主函数。此处展示了4个线性方程组的求解过程</span><br><span class="line">if(__name__==&#x27;__main__&#x27;):</span><br><span class="line">    print(&quot;Gauss_Elimination_Method.py&quot;)</span><br><span class="line">    A1 =[[ 1,-1,-1, 2 ],</span><br><span class="line">        [ 2,-1,-3, 1 ],</span><br><span class="line">        [ 3, 2,-5, 0 ]]</span><br><span class="line">    run(A1)</span><br><span class="line">    </span><br><span class="line">    A2= [[ 1, 2, 1, 8],</span><br><span class="line">         [ 4, 0, 0,16],</span><br><span class="line">         [ 0, 4, 0,12]]</span><br><span class="line">    run(A2)</span><br><span class="line"></span><br><span class="line">    A3= [[ 1, 2, 0, 8],</span><br><span class="line">         [ 4, 0, 1,16],</span><br><span class="line">         [ 0, 4, 0,12]]</span><br><span class="line">    run(A3)</span><br><span class="line"></span><br><span class="line">    A4= [[ 2, 0, 0, 8],</span><br><span class="line">         [ 0, 1, 0,16],</span><br><span class="line">         [ 4, 0, 1,12]]</span><br><span class="line">    run(A4)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
        <tag>高斯消元法</tag>
      </tags>
  </entry>
  <entry>
    <title>关于爱情和人生选择的一些瞎想</title>
    <url>/2022/05/19/%E5%85%B3%E4%BA%8E%E7%88%B1%E6%83%85%E5%92%8C%E4%BA%BA%E7%94%9F%E9%80%89%E6%8B%A9%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9E%8E%E6%83%B3/</url>
    <content><![CDATA[<p>深夜网易云时间。</p>
<span id="more"></span>



<p>分享Richard Clayderman的单曲《星空》下面的一条评论：</p>
<blockquote>
<p>旧城失词-空城旧梦<br>2019-01-12<br>小学时，我喜欢的女孩和班里唯一会弹钢琴的男孩关系亲密，我缠着父母报了钢琴辅导班。通过了一级一级的考试，我已经大二。迎新晚会上，我给心仪已久的女孩弹奏了一首《布达佩斯之恋》，她却和别的系的一个弹吉他的表白了，当着全体新生的面，场面一度失控。那一刻我明白了，有些东西你越追逐，越遥远。</p>
</blockquote>
<p>不管这个故事是否真实，其中透露出的一股无力感真的很令人绝望。那种感觉，是你看到了一个美好的东西，你特别希望得到它，为了它你付出了很多，甚至牺牲了原本属于自己的一些东西，结果到头来一场空。你会怀疑自己的努力，怀疑自己付出了这么多时间精力是否值得，严重者甚至可能走向绝望，坠向一个无底的深渊。</p>
<p>没在开玩笑。其实严格意义上我没有经历过这样的绝望（我也不想经历），但还是会想起去年考研的那几个月，一边默默忍受一段不平衡的感情经历，一边硬着头啃题目的日子。</p>
<p>其实命运待我不薄；我那几个月的努力换来了考研的成功上岸，而即使没上岸，西湖大学的offer也让我不至于没学可上。但是，话说回来，如果当时真的既没有拿到西湖大学的offer又没有考研上岸（然后被甩——这件事是必然发生的），我会以什么样的心态对待这样的结局呢？</p>
<p>可能会挺不过去这么大的挫折，从而一蹶不振吧。</p>
<p>我这人其实没啥道德底线，大学阶段装出来的好像无欲无求的样子，一半是自己懒惰不思进取，另一方面也是怕在人际交往上吃亏。但我这人其实心眼挺小的，在今年认识yxy（注：几个月前来实验室实习的同学）以后，直到现在，我依然还是觉得她的那种卷一点的大学生活才是应该追求的。</p>
<p>说回上面那条评论。主人公因为喜欢一个人而去学了一门艺术，等到真正学会以后却发现这门艺术换不来一个人的心——其实很多爱情悲剧的套路大抵如此，虽然真的很伤人罢了。如果按照这半年经过修正后的我的思路，为了一个人就去傻乎乎的学一门艺术其实有点得不偿失，还不如先从身边的朋友入手探探虚实——虽然即使这样也很难获得对方的心罢了。</p>
<p>其实我现在这种状态也不太适合谈恋爱，如果过于在意交往中的得失，忘记了真心实意，那么这样的关系其实不可能长久。然而，如果关系反过来，自己的真心实意换不来对方的真心实意，其实也是一种得不偿失，这样的关系可能会维持的稍微久一点，但值得吗？</p>
<p>最好的恋爱关系当然是两个人都真心实意的爱着对方——但那种关系可遇而不可求。次一点的关系就是两个人搭伙过日子，谁也瞧不上谁，但是日子还得过，于是在互相计较得失中把生活过下去——我猜这是很大一部分婚姻的状态。这两种关系中，双方都是平等的，要么互相深爱着对方，要么互相计较着对方。怕就怕在不平衡的关系——一方倾注了（或者说期望倾注）倾慕和喜欢，然而另一方看不上这一方。不展开了，懂得都懂。</p>
<p>其实去年下半年的一堆魔幻经历让我心态有些扭曲。但细细想来其实大部分的问题还是出在我自己身上。先是寄希望于躺赢进入IBP，但那几个月我的工作态度说不上认真，最后保研排名被刷也在情理之中。关于谈了拢共不到四个月的失败恋爱，归结起来一句话，还是我不够成熟——“没有金刚钻，别揽瓷器活”——只可惜白瞎了两年多的同学关系了。</p>
<p>还能说什么呢？朝着你希望成为的那种人去努力吧。今晚上的这些思考仅供参考，不必为了让自己可以受一些人的崇敬而去当冤种钻牛角尖，也不必为了报复一些人而彻底沦为精致利己的投机分子（张皖豫你可不能那样啊！）。当然，在这个过程中最好不要喜欢上任何一个人——在没有把握一段亲密关系的信心和能力前，这样冒失的把自己的心交给别人，是最最最最愚蠢的事情了！</p>
]]></content>
      <categories>
        <category>杂思</category>
      </categories>
      <tags>
        <tag>爱情</tag>
      </tags>
  </entry>
  <entry>
    <title>再谈爱情——对南风窗公众号的一篇文章的反思</title>
    <url>/2022/09/04/%E5%86%8D%E8%B0%88%E7%88%B1%E6%83%85-%E5%AF%B9%E5%8D%97%E9%A3%8E%E7%AA%97%E5%85%AC%E4%BC%97%E5%8F%B7%E7%9A%84%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E7%9A%84%E5%8F%8D%E6%80%9D/</url>
    <content><![CDATA[<p>前几天，南风窗的公众号上发表了一篇文章，题目叫做《<a href="https://mp.weixin.qq.com/s/BPJYwU4iFCHp4MxM3duRfA">这样下去，你不配恋爱</a>》。文章从越来越多的年轻人宣称“没时间谈恋爱”这一现象出发，对当代年轻人的爱情观进行了剖析。文章很长，其中的许多观点乍一看也很有道理。只不过，我有话想说。</p>
<span id="more"></span>

<p>文章中提到，“真正的爱情，是这个世界上最反效率的东西之一，它是日久天长的心理和情感需求，所以它不能和其它欲望并列。如果把它和其它欲望并列起来，在效率原则的作用下，它就一定会排在最后。”</p>
<p>请注意上述文章的观点是认为我们应该追求“真正的爱情”，而混杂了利益关系等因素的所谓恋爱和婚姻根本不是爱情。</p>
<p>我看到这篇文章，第一反应是觉得这篇文章的中心论点是纯扯淡，为了真正的爱情放弃那些“世俗的欲望”（然而这些可能是当代年轻人在社会上安身立命的基石），极大的概率是被高速运转的社会所淘汰，最终既失去了爱情，又失去了在社会上安身立命的资格。</p>
<p>然而，这篇文章是否也可以这么理解：这种真正的爱情，是会带给人积极向上的力量的，而这种力量，可以让人们超越自己的极限，实现一些曾经不敢想象的目标，后者完全可以让一个人在社会上安身立命（例如，在爱情的力量下，人们创业成功/考公考研上岸/事业上有了更深入的进展）</p>
<p>如果是后面这种理解方式，那么我们也可以认为所谓“真正的爱情”是一种类似于神经生长因子的精神动力源泉[1]，这种动力源泉可以帮助我们变成更好的人。因此，追求真正的爱情，看起来是一件极其有意义的事情。</p>
<p>然而，不管怎么理解，最关键的问题其实在于，爱情这种东西实在是太难以遇到。牛郎织女、梁山伯祝英台、焦仲卿刘兰芝这样的故事确实很感人，也确实如作者所说可以算作“真正的爱情”，然而这样的故事毕竟太少——不然人们也不会把他们编成神话诗歌戏曲一代代传唱了。即使在社会流动性高度发达的今天，遇见真爱也是件小概率的事件。某种意义上可以说，人们能一代代繁衍下来，主要还是靠所谓“搭伙过日子”的婚姻进行下来的。</p>
<p>或许我们可以理解作者把爱情看得很重要的心态——实际上爱情也确实很重要。然而如果为了这种重要却可遇不可求的爱情，而放弃了其他追求（作者说这些都是些欲望，但有没有一种可能，这些都是正常社会生活所必须的），实在是因小失大。对于我们普通人，最好的办法还是努力完善自我，提高自己的能力和价值，然后在“搭伙过日子”的婚姻中尽可能提高生活的幸福感吧——毕竟很多时候，钱真的能带来幸福。</p>
<p>以上仅为9月3号深夜的一些胡思乱想，其中的诸多观点可能存在幼稚甚至反社会之处。也许未来某一天，我会反过来再把上面这些话批评得体无完肤——谁知道呢？不过爱情这个话题确实值得探讨一番。很想在评论区里听一听不同的意见，不知道各位如何看待。</p>
<hr>
<p><strong>注释：</strong></p>
<p>[1] 神经生长因子：<strong>“在脊椎动物神经系统的发育过程中，约有50%的原始神经元存活并与靶细胞建立了连接，而没有建立连接的神经元则发生凋亡，这与靶细胞分泌的神经生长因子（NGF）有关——只有接受了足够量存活因子的神经元才能生存，其他的细胞则发生凋亡”</strong>（翟中和《细胞生物学》第四版，P344）。有一种理论认为，爱情可以带给人们强大的动力，这种动力会驱动人们变成更好的人。所以是不是可以理解为，每一个渴望爱情的人都是一个孤单的神经元，而爱情就是让神经元生长的NGF。得到爱情的人们会更加积极上进，就像得到NGF的神经元可以免于凋亡——然而，真正的爱情又是那样的稀少，以至于很多人终其一生都没能体会过爱情的滋味——即便很多人最终还是结婚生子，就此操劳一生。</p>
<hr>
<p>评论区备份</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Hazel(2022-09-04 14:47:39):</span><br><span class="line">	把爱情比作神经生长因子，确实很形象。</span><br><span class="line">	但是我更希望有人可以将爱情比作锦上添花，而不是得不到就无法存活的生长因子。拥有会很幸运，但是没有也没关系。</span><br><span class="line">	并且我不觉得人拥有爱情就会积极向上，我感觉追明星追上头的时候也很积极向上（或许没有经历过爱情吧🤪）。</span><br><span class="line">	爱情，哈哈哈哈，我宁愿要很多友情（可能这就是单身狗吧😜），毕竟，爱情又什么用呢？</span><br><span class="line">	以前总觉得经历恋爱是多了一份人生体验，可以学到很多东西，顺便体验一下爱情。后来发现我好像弄反了，大概是先有爱情才能恋爱，因此才能学到很多东西吧。</span><br><span class="line">	还好还好，我有许多要学习的东西，即便体验不到爱情，仍然有许多可以进步的地方。</span><br><span class="line">	最后，再次发问：爱情到底有什么呢？</span><br><span class="line"></span><br><span class="line">&gt; Warren Zhang(2022-09-04 20:01:09)</span><br><span class="line">&gt;	呜呜，我也想要好多好多的友情🤪</span><br><span class="line">&gt;	毕竟友情和爱情并不冲突，小孩子才做选择，大人全都要[doge]</span><br><span class="line">&gt;	说起来，其实我很好奇追星是一种什么样的体验，毕竟从小到大身边追星的男孩子好像不多，而曾经因为各种原因，我和女生的交流也很有限，从来也没和别人探讨过追星这个问题。</span><br><span class="line">&gt;	如果追星上头可以带来积极向上，那也挺好的其实，说不定那种感觉和恋爱很相似……哎呀反正能让自己打鸡血积极学习积极工作积极生活就好了嘛，考虑那么多干什么。</span><br><span class="line">&gt;	所以爱情到底有什么呢？我也想知道awa。</span><br><span class="line">&gt;</span><br><span class="line">&gt; Hazel(2022-09-17 23:23:29)</span><br><span class="line">&gt;	或许我有点明白为什么要恋爱或者结婚。因为恋爱关系是在小范围内表明你们的权利与责任，只要是有正常道德观念的人都会对你们保持尊重和应该拥有的界限；而结婚则是从法律上对你们的权利和义务进行规束，这样只要有正常法律意识和道德观念的人都会默认你们的关系，对你们的行为表示尊重，并划定适当的界限。</span><br><span class="line">&gt;	这是一种非常稳定的关系，非常稳定的友谊。</span><br><span class="line">&gt;	因为我们不得不悲哀地发现，友谊其实是不确定的。并没有什么规定你和这个人成为最好的朋友，就不能和另一个人成为好朋友；同时友谊也并没有身份，就像是我觉得我的好朋友是A，但是可能A只觉得我是一个同学或者暂时的关系，这是不对等的，关系双方对自己的身份是模糊的（我觉得很少有朋友会这样互相说，“我觉得你是我最好的朋友”，“我也这样想的。”）。友谊会随着时间和距离发生变化，如果你不小心维护，很可能迅速消失。同时，如果你的好朋友开始谈恋爱，无论是同性还是异性，和你的关系都会发生变化，这具有极大的不确定性，而且大概率会变得有点糟糕或者生疏。而一个现实大概就是：你身边的朋友不可能一直单身，至少不会一辈子吧。所以你大概率要经受过很多次的难过和开心的纠结，既祝福她同时也会难过于接下来的关系，这时候你就会想 &quot;如果能一直在一起多好，她可以不是我的，但也不能是任何一个人的&quot; 。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>杂思</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
        <tag>爱情</tag>
      </tags>
  </entry>
  <entry>
    <title>回北京的第一个周末</title>
    <url>/2022/01/08/%E5%9B%9E%E7%94%9F%E7%89%A9%E7%89%A9%E7%90%86%E6%89%80%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%91%A8%E6%9C%AB/</url>
    <content><![CDATA[<p>考完研以后，在天津又逗留数日，方才回北京。今天，正好是回北京以后的第一个周末。</p>
<span id="more"></span>

<p>今天虽然是三九，但京津冀气温回升。斜斜的阳光洒落在地面上，恍惚之中以为又是早春三月。</p>
<p>突然意识到来北京快一年了。我还记得去年那个鲜花盛开的四月天，桃、李、海棠、月季竞相盛开，那段日子我的心情也是一样愉悦的。（除了4月中旬小小的emo一下，以及5月上课做展示发现自己挺菜然后有点受打击）</p>
<p>春天给人以希望。而肃杀的秋冬只是平白无故地增加了几分失望和压抑罢。加上这一年来我所经历的一切，更让我对秋天感到一些害怕和恐惧。我喜欢充满希望的生活，讨厌看不到未来的日子。</p>
<p>曾经，我给自己安过不少标签：敏感，缺爱，幼稚，内向……当然，其实大可不必这样。活出真实的自己就好啦。</p>
<p>与人相处是一件很费脑子的事情，但换一种思路，在与人相处之前，想清楚自己的需求是什么，如何让别人满足自己的需求，然后自己再看情况给一点补偿，或许是一种很好的相处模式。这么做看起来挺功利的，但我觉得挺好。</p>
<p>曾经有幸遇到了yyq，他让我改掉了初中时自己身上的很多毛病，当然他是第一个让我感到抱歉和遗憾的人（我想第二个人就是yzy了。不希望还有第三个甚至第四个人出现）。后来，在大学里遇到了yzy，并且在各种机缘巧合之下一度走到了一起，本以为依据和yyq相处的经验，这段关系会发展的更平稳一点。可我忘记了友情毕竟和爱情不一样，忽略了男生和女生的差别，以及我从一开始的不自信导致我放弃了在这段感情中的主动权。现在这个结果，既是我自己咎由自取，也是又一个经验教训罢。</p>
<hr>
<p><img src="https://pic.imgdb.cn/item/62750fb80947543129e3c8e9.jpg" alt="sunlight in the late winter"></p>
<p>”今天虽然是三九，但京津冀气温回升。斜斜的阳光洒落在地面上，恍惚之中以为又是早春三月“</p>
]]></content>
      <categories>
        <category>杂思</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
        <tag>爱情</tag>
        <tag>日记</tag>
        <tag>失恋</tag>
      </tags>
  </entry>
  <entry>
    <title>在网页中引入MathJax</title>
    <url>/2022/10/21/%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%AD%E5%BC%95%E5%85%A5mathjax/</url>
    <content><![CDATA[<p>这篇文章尝试探究如何在页面中引入MathJax以进行公式渲染。</p>
<span id="more"></span>

<h2 id="一、示例"><a href="#一、示例" class="headerlink" title="一、示例"></a>一、示例</h2><p>一段示例代码如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://polyfill.io/v3/polyfill.min.js?features=es6&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">&quot;MathJax-script&quot;</span> <span class="attr">async</span></span></span><br><span class="line"><span class="tag">          <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">对于一元二次方程\(ax^2+bx+c=0\)，在\(a\ne 0\)的情况下，其解为：</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">x = \frac&#123;-b \pm \sqrt&#123;b^2-4ac&#125; &#125;&#123;2a&#125;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">  When \(a \ne 0\), there are two solutions to \(ax^2 + bx + c = 0\) and they are</span><br><span class="line">  \[x = &#123;-b \pm \sqrt&#123;b^2-4ac&#125; \over 2a&#125;.\]</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述代码的效果如下</p>
<hr>
<p>对于一元二次方程\(ax^2+bx+c=0\)，在\(a\ne 0\)的情况下，其解为： $$ x = \frac{-b \pm \sqrt{b^2-4ac} }{2a} $$ When \(a \ne 0\), there are two solutions to \(ax^2 + bx + c = 0\) and they are \[x = {-b \pm \sqrt{b^2-4ac} \over 2a}.\]</p>
<hr>
<h2 id="二、使用方法简介"><a href="#二、使用方法简介" class="headerlink" title="二、使用方法简介"></a>二、使用方法简介</h2><p>MathJax是一个<strong>开放源代码的JavaScript显示引擎</strong>，适用于所有现代浏览器中的LaTeX、MathML和AsciMath表示法。Mathjax的官网见 <a href="https://www.mathjax.org/">https://www.mathjax.org</a> 。</p>
<p>要使用MathJax，首先需要引入它：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://polyfill.io/v3/polyfill.min.js?features=es6&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">&quot;MathJax-script&quot;</span> <span class="attr">async</span>=<span class="string">&quot;&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>之后，有两种方式在正文中编写公式。</p>
<p>对于行内公式，使用<code>\(...\)</code> 作为数学公式的标记。一个公式以<code>\(</code>开始，以<code>\)</code>结束。注意这和markdown语法略有不同，markdown语法中，行内公式以$…$进行标记。这种设计的目的是防止和网页内容中的美元符号（$）混淆。</p>
<p>对于行间公式，可以和markdown一样，以<code>$$...$$</code>进行标记，也可以使用<code>\[...\]</code>标记一个行间公式。</p>
<p>MathJax的公式编写语法和\(L^AT_EX\)的公式语法兼容。因此，在两个<code>$$</code>之间，或者在<code>\(</code>和<code>\)</code>之间，直接按照\(L^AT_EX\)语法进行编写就可以了。</p>
<h2 id="另："><a href="#另：" class="headerlink" title="另："></a>另：</h2><p>如果博客系统是使用hexo搭建的，并不需要这种方法编写公式。hexo自带了MathJax模块，只需要在<code>_config.yml</code>中开启相应的功能即可。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>mathjax</tag>
      </tags>
  </entry>
  <entry>
    <title>假基因是没有功能的基因拷贝</title>
    <url>/2022/09/13/%E5%81%87%E5%9F%BA%E5%9B%A0%E6%98%AF%E6%B2%A1%E6%9C%89%E5%8A%9F%E8%83%BD%E7%9A%84%E5%9F%BA%E5%9B%A0%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<p>本小节内容翻译自 Genes XI, chapter 8.11, p183-185。部分句子参考《基因X》中文版的翻译进行了调整。</p>
<span id="more"></span>

<h2 id="关键内容提点"><a href="#关键内容提点" class="headerlink" title="关键内容提点"></a>关键内容提点</h2><ul>
<li>  “加工的假基因”（processed pseudogenes）来自于mRNA转录本的逆转录与整合</li>
<li>  “未加工的假基因”（nonprocessed pseudogenes）来自功能基因的不完整复制（duplication），或第二拷贝（second-copy）的突变</li>
<li>  一些假基因可能获得一些与他们的亲本基因（parent genes）不同的功能，例如调节基因表达，也因此他们可能会获得不同的名字</li>
</ul>
<p>正如前一章所述，假基因是功能基因的拷贝，并且有一些变异区或者缺失区，这导致它们可能不会产生功能性多肽的产物（但是它们有可能转录，而转录产物可能具有调控功能）。例如，与他们的功能性同僚（functional counterparts）相比，许多假基因含有移码突变或无义突变，这些突变导致它们无法产生有功能的蛋白。从假基因的起源模式来看，一共可以分为两种：</p>
<p><strong>加工的假基因（processed pseudogenes）</strong> 来自成熟mRNA转录本的反转录产物，这些转录本被反转录为cDNA，然后整合到了基因组中。这可能发生在细胞中存在活性逆转录酶的时候，如在活性逆转录病毒感染或逆转录病毒活性期间。由于mRNA已经经过了加工，因此这一类假基因经常缺少正常表达所需要的调控区。虽然这类基因最初都包含功能性肽段的编码序列，但在形成的一开始就是无功能的。这些假基因也缺乏内含子，可能包含mRNA的poly(A)尾的残余，以及逆转录转座子的侧翼直接重复的特征。</p>
<p><strong>未加工的假基因（nonprocessed pseudogenes）</strong> 来自多拷贝基因或单拷贝基因的一个拷贝的失活突变，或者功能基因的不完全复制。通常，这些都是由导致串联重复的机制形成的。一个例子是β-珠蛋白假基因，其在启动子区和外显子区出现了多个突变，并且丢失了剪接位点。如果一个基因连同它的调控区被完整地复制，那么在一段时间内可能会有两个有功能的基因拷贝，但是，在一个副本中发生的失活突变并不一定会受到负选择的影响。因此，基因家族是非加工假基因的一个非常成熟的起源，而在珠蛋白基因家族中存在多个假基因就证明了这一点。另外，一个功能基因的不完全复制，会导致一个新的基因拷贝缺失调控区域和/或编码序列，于是新出现的拷贝会立即成为一个假基因，“在到达时死亡”。</p>
<p>人类基因组中大约含有20000个假基因。核糖体蛋白（RP）假基因由一个很大的假基因家族构成，包含大约2000份假基因的拷贝。这些都是加工的假基因；高拷贝数可能是大约80个功能性RP基因拷贝的高表达率的函数（也就是说，因为RP的编码基因多，因此产生的假基因也相应的更多）。它们插入基因组的过程显然是由L1逆转录转座子介导的。RP基因在物种间高度保守，因此在具有长期独立进化历史和全基因组序列的物种中，识别RP假基因的直系同源基因是可能的。在人类这两千多个RP的假基因中，人-黑猩猩同源的有1282个，而人-大鼠同源的只有11个，人-小鼠同源的则更少，只有6个（然而，大鼠-小鼠同源的有接近400个），这表明灵长类和啮齿类中，大多数RP假基因起源较晚，而大多数祖先物种的RP假基因会因为缺失或突变，在被识别之前就已经丢失了。</p>
<p>有趣的是，RP假基因的进化速率比中性进化的速度更慢，这提示RP假基因可能还有一些功能，因此受到负选择。虽然假基因在刚出现时是无功能的，然而有清晰的例子表明，一些前假基因（former pseudogenes）出现了新功能化（neofunctionalized）或亚功能化（subfunctionalized）的迹象。其中，新功能化（neofunctionalized）指假基因获得了一些新的功能，而亚功能化（subfunctionalized）指假基因获得了其亲本基因的部分功能，或者对亲本基因的功能起到补充。一旦这些假基因重新获得了功能，他们会受到选择压力的约束，因此进化速度会比中性进化的速度更慢。</p>
<p>一个假基因是如何获得一个新的功能？一种可能性是，假基因已经无法被翻译为有功能的蛋白，但其还可以被正常转录。这些无法被翻译的转录本可以影响或调控亲本基因的表达。例如，小鼠中的加工假基因 <em>Makorin1-p1</em> 能够稳定 <em>Makorin1</em> 基因的转录本，后者是一个有功能的基因。一些内源性siRNA是假基因编码的。第二种可能是，一个加工假基因可能插入到了一个带有新的调控区域的位置，例如插入到转录因子结合位点，这种与亲本基因迥然不同的调控环境会让假基因以一种不同于亲本基因的组织特异性方式发生表达。</p>
]]></content>
      <categories>
        <category>生物</category>
      </categories>
      <tags>
        <tag>假基因</tag>
        <tag>基因</tag>
        <tag>著作翻译</tag>
        <tag>生物学</tag>
      </tags>
  </entry>
  <entry>
    <title>在Windows下编译less.exe</title>
    <url>/2023/03/20/%E5%9C%A8windows%E4%B8%8B%E7%BC%96%E8%AF%91less-exe/</url>
    <content><![CDATA[<p>如何将Linux系统下的文本查看器<code>less</code>编译到Windows上？</p>
<span id="more"></span>

<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p><a href="https://www.gnu.org/savannah-checkouts/gnu/www/software/less/">GNU less</a> 是一个很好用的命令行文本查看器，在Linux系统上默认安装，其提供了包括文件查看、字符串搜索在内的许多功能，并且在打开大文件（例如1GB大小的基因组数据）时速度极快。</p>
<p>由于工作环境限制，笔者需要经常在Windows系统的电脑下查看文本文件。windows系统自带了记事本、写字板等文本查看器，但是如上所述，打开大文件时这些软件的速度很慢。此外，笔者也安装了vscode、 <a href="https://www.vim.org/">GVIM</a> 、<a href="https://frippery.org/busybox/">busybox</a> 等软件，但是这些软件也不尽然能够满足笔者的需求（例如，vscode本质上是个浏览器，因此速度更慢；GVIM提供了和Linux vim一致的使用体验，但是在打开大文件时依然很慢；busybox自带了一个精简版的less，勉强可用，但诸多细节依然不及完整版less）。因此，笔者萌生了编译windows版less的想法。</p>
<h2 id="二、材料"><a href="#二、材料" class="headerlink" title="二、材料"></a>二、材料</h2><h3 id="1、编译器安装"><a href="#1、编译器安装" class="headerlink" title="1、编译器安装"></a>1、编译器安装</h3><p>编译less需要C++编译器和perl解释器。本文将以<a href="https://www.mingw-w64.org/downloads/">MinGW-w64</a> 为例介绍C++编译器的安装，以<a href="https://strawberryperl.com/">Strawberry Perl</a> 为例介绍perl解释器的安装。读者也可以选择其他编译器和解释器，但大致思路是相同的。</p>
<h4 id="（1）MinGW-64"><a href="#（1）MinGW-64" class="headerlink" title="（1）MinGW-64"></a>（1）MinGW-64</h4><p><a href="https://www.mingw-w64.org/downloads/">MinGW-w64</a> 是一个大型项目，旨在将GNU Linux上的GCC编译器移植到Windows等系统上。熟悉Linux GCC编译器的同学应该很容易上手MinGW-64的编译器，二者在许多地方是相似的。</p>
<p>下载地址：</p>
<p><a href="https://github.com/niXman/mingw-builds-binaries/releases">Github 存储库</a></p>
<p>根据Windows系统的对应架构选择合适的编译器版本并下载整合包，例如笔者所下载的就是 <code>x86_64-12.2.0-release-win32-seh-msvcrt-rt_v10-rev2.7z</code> 这个文件。下载后将其解压到D盘根目录（“解压文件到目标路径”； <em>读者也可以选择其他位置，但环境变量相应的需要改动</em> ），然后编辑系统环境变量（此电脑→属性→高级系统设置→环境变量），在 <code>Path</code> 这个变量中新建一条记录 <code>D:\mingw64\bin</code> 。修改环境变量的目的是方便后续在命令行中访问MinGW编译器，<strong>其应该与MinGW的安装路径一致。</strong></p>
<p>现在打开Windows命令提示符（也可以用Windows Powershell），输入下列指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc --version</span><br></pre></td></tr></table></figure>

<p>如果看到以下输出</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">gcc (x86_64-win32-seh-rev2, Built by MinGW-W64 project) 12.2.0</span><br><span class="line">Copyright (C) 2022 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the sourcefor copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure>

<p>则说明安装成功。</p>
<p>如果提示“gcc不是内部或外部命令，也不是可运行的程序或批处理文件”，则检查环境变量是否设置正确，或者环境变量是否与MinGW的安装路径一致。</p>
<h4 id="（2）Strawberry-Perl"><a href="#（2）Strawberry-Perl" class="headerlink" title="（2）Strawberry Perl"></a>（2）Strawberry Perl</h4><p><a href="https://strawberryperl.com/">Strawberry Perl</a> 是Perl解释器在Windows系统上的实现。其安装方法很简单。只需要点击 <a href="https://strawberryperl.com/">官网链接</a> ，下载安装包，然后运行安装包，其会自动完成安装的过程，并配置好环境变量。</p>
<p>安装完成后，重启Windows命令提示符，输入下列指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">perl -v</span><br></pre></td></tr></table></figure>

<p>如果看到类似下面的输出</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">This is perl 5, version 32, subversion 1 (v5.32.1) built for MSWin32-x64-multi-thread</span><br><span class="line"></span><br><span class="line">Copyright 1987-2021, Larry Wall</span><br><span class="line"></span><br><span class="line">Perl may be copied only under the terms of either the Artistic License or the</span><br><span class="line">GNU General Public License, which may be found in the Perl 5 source kit.</span><br><span class="line"></span><br><span class="line">Complete documentation for Perl, including FAQ lists, should be found on</span><br><span class="line">this system using &quot;man perl&quot; or &quot;perldoc perl&quot;.  If you have access to the</span><br><span class="line">Internet, point your browser at http://www.perl.org/, the Perl Home Page.</span><br></pre></td></tr></table></figure>

<p>则说明安装成功</p>
<h3 id="2、less程序源代码"><a href="#2、less程序源代码" class="headerlink" title="2、less程序源代码"></a>2、less程序源代码</h3><p>见 <a href="https://www.gnu.org/savannah-checkouts/gnu/www/software/less/">GNU less的官网</a> 。网站上列出了一个FTP服务器（<a href="http://ftp.gnu.org/gnu/less/">http://ftp.gnu.org/gnu/less/</a> ），点击访问，并下载最新版源代码压缩包。笔者所下载的版本是version 608（<a href="http://ftp.gnu.org/gnu/less/less-608.tar.gz">http://ftp.gnu.org/gnu/less/less-608.tar.gz</a> ）。</p>
<p>下载后在任意目录下解压，然后通过Windows命令提示符访问对应位置。整个源代码包的结构如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">D:\linux\gcc\source\less-608&gt;ls</span><br><span class="line">COPYING          Makefile.o2e     brac.c           configure        defines.wn       input.c          lessecho.man     line.c           mkhelp.py        output.c         regexp.h         version.c</span><br><span class="line">INSTALL          Makefile.o9c     ch.c             configure.ac     edit.c           install.sh       lessecho.nro     linenum.c        mkinstalldirs    pattern.c        screen.c         wide.uni</span><br><span class="line">LICENSE          Makefile.o9u     charset.c        cvt.c            filename.c       jump.c           lesskey.c        lsystem.c        mkutable         pattern.h        scrsize.c        xbuf.c</span><br><span class="line">Makefile.aut     Makefile.wnb     charset.h        decode.c         fmt.uni          less.h           lesskey.h        main.c           optfunc.c        pckeys.h         search.c         xbuf.h</span><br><span class="line">Makefile.dsb     Makefile.wng     cmd.h            defines.ds       forwback.c       less.hlp         lesskey.man      mark.c           option.c         position.c       signal.c</span><br><span class="line">Makefile.dsg     Makefile.wnm     cmdbuf.c         defines.h.in     funcs.h          less.man         lesskey.nro      mkfuncs.pl       option.h         position.h       tags.c</span><br><span class="line">Makefile.dsu     NEWS             command.c        defines.o2       help.c           less.nro         lesskey_parse.c  mkfuncs.py       opttbl.c         prompt.c         ttyin.c</span><br><span class="line">Makefile.in      README           compose.uni      defines.o9       ifile.c          lessecho.c       lglob.h          mkhelp.pl        os.c             regexp.c         ubin.uni</span><br></pre></td></tr></table></figure>

<p>less的源代码包中提供了3个适用于windows系统的<code>Makefile</code>，分别是<code>Makefile.wnb, Makefile.wng, Makefile.wnm</code> ，他们对应于三种不同的C++编译器，分别是Bolarnd C++ 、MinGW-w64和Microsoft Visual C++ 。在这三个<code>Makefile</code>中，均标注了各自的编译方法，因此只需要按照其给出的方法编译即可。</p>
<h2 id="三、编译方法"><a href="#三、编译方法" class="headerlink" title="三、编译方法"></a>三、编译方法</h2><p>如前所述，less的源代码包中提供了编译所需的<code>Makefile</code>文件，因此我们直接编译即可。</p>
<p>我们使用的编译器是MinGW-w64，编译指令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mingw32-make -f Makefile.wng REGEX_PACKAGE=regcomp-local</span><br></pre></td></tr></table></figure>

<p>参数<code>REGEX_PACKAGE</code>指出了编译过程中应该链接到哪一个regex库。根据<code>Makefile</code>中的说明，我们指定<code>REGEX_PACKAGE=regcomp-local</code>即可，编译器会使用less源代码包自带的regex。</p>
<p>这里还有一个小插曲：</p>
<p>regex是一个正则表达式处理库，在Linux上自带，但是Windows上没有。默认编译选项指定<code>REGEX_PACKAGE=posix</code>，这会导致编译器从系统中链接regex库。笔者最开始采取的方法是另外安装regex，然而在网上只找到一个2.7版的regex库，编译过程中发现其与编译器不兼容。经过许多摸索，终于发现参数<code>REGEX_PACKAGE</code>的用法，遂设置<code>REGEX_PACKAGE=regcomp-local</code>，并一次编译成功。</p>
<p>编译完成后，当前目录下会出现三个新的exe文件，分别是<code>less.exe, lessecho.exe, lesskey.exe</code> 。输入下列指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">less.exe --version</span><br></pre></td></tr></table></figure>

<p>当看到下面的输出时，表明安装成功：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">less 608 (Spencer V8 regular expressions)</span><br><span class="line">Copyright (C) 1984-2022  Mark Nudelman</span><br><span class="line"></span><br><span class="line">less comes with NO WARRANTY, to the extent permitted by law.</span><br><span class="line">For information about the terms of redistribution,</span><br><span class="line">see the file named README in the less distribution.</span><br><span class="line">Home page: https://greenwoodsoftware.com/less</span><br></pre></td></tr></table></figure>

<h2 id="四、使用"><a href="#四、使用" class="headerlink" title="四、使用"></a>四、使用</h2><p>我们可以将<code>less.exe, lessecho.exe, lesskey.exe</code>这几个可执行文件的路径加入到系统的环境变量PATH当中，这样以后需要打开大文件时，只需要运行 <code>less &lt;filename&gt;</code> 即可。</p>
<p>less提供了多个参数，其中比较有用的参数有两个：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">-N .........  --LINE-NUMBERS</span><br><span class="line">                Display line number at start of each line.</span><br><span class="line">-S  ........  --chop-long-lines</span><br><span class="line">                Chop (truncate) long lines rather than wrapping.</span><br></pre></td></tr></table></figure>

<p>参数 <code>-N</code> 表示开启行号显示，参数 <code>-S</code> 表明长段落不换行显示（此时需要配合左右方向键进行浏览）。对于一些大文件，例如群体基因组变异文件VCF、制表符分隔的表格文件TSV等，这两个参数是极有用的。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>Windows系统使用技巧</tag>
        <tag>less.exe</tag>
      </tags>
  </entry>
  <entry>
    <title>基因敲除（gene knockout）与基因消融（gene ablation）的区别</title>
    <url>/2023/11/19/%E5%9F%BA%E5%9B%A0%E6%95%B2%E9%99%A4%E4%B8%8E%E5%9F%BA%E5%9B%A0%E6%B6%88%E8%9E%8D%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><strong>划重点：基因敲除是完全让基因不表达；基因消融有点类似于基因敲减，是干扰基因的表达量，但是不完全抑制基因表达</strong></p>
<span id="more"></span>

<blockquote>
<p>来源：与new bing（GPT-4）的对话</p>
</blockquote>
<h2 id="1-什么是基因消融（gene-ablation）？其与基因消除（gene-knock-out）的区别是什么？"><a href="#1-什么是基因消融（gene-ablation）？其与基因消除（gene-knock-out）的区别是什么？" class="headerlink" title="1. 什么是基因消融（gene ablation）？其与基因消除（gene knock out）的区别是什么？"></a>1. 什么是基因消融（gene ablation）？其与基因消除（gene knock out）的区别是什么？</h2><p>基因消融是一种遗传工程技术，它通过同源基因重组使一个基因变为“空”（null），从而选择性地抑制一个特定的细胞系或细胞类型。基因消融不仅限于抑制单个基因的活性，还可以通过观察基因消融后的胚胎表达模式来评估特定基因的功能。</p>
<p>基因敲除是一种完全删除或通过无意义突变使目标基因失活的技术。基因敲除可以通过将一个或多个转基因导入受精小鼠卵母细胞的原核，然后重新植入宿主母亲，产生转基因小鼠来实现。基因敲除可以用来研究基因的作用和功能，以及基因缺失对生物体的影响。</p>
<p>基因消融和基因敲除的主要区别是抑制的程度。基因消融被认为是一种基因敲降机制，它通常降低基因的表达，但不完全消除它。相比之下，基因敲除完全从生物体的基因组中擦除基因，因此这些基因完全没有表达。基因消融通常比基因敲除更适合研究，因为基因消融方法允许研究动物模型生存所必需的基因，而这些基因不能被删除。此外，基因消融方法可以提供更完整的疾病发展视角，因为疾病通常与基因表达降低有关。</p>
<p><img src="https://pic.imgdb.cn/item/6559f05ec458853aeff23055.jpg" alt="siRNA技术实现基因消融"></p>
<h2 id="2-哪些实验可以消融一个基因，而不是完全敲除它？"><a href="#2-哪些实验可以消融一个基因，而不是完全敲除它？" class="headerlink" title="2. 哪些实验可以消融一个基因，而不是完全敲除它？"></a>2. 哪些实验可以消融一个基因，而不是完全敲除它？</h2><p>基因消融的实验方法有多种，例如：</p>
<ul>
<li>基因靶向消融：这种方法利用同源重组技术，将一个含有抗生素抗性基因的载体插入目标基因的内含子中，从而使目标基因的表达受到干扰。这种方法可以在特定的细胞系或细胞类型中进行，从而实现组织特异性的基因消融。</li>
<li>Cre-LoxP系统：这种方法利用一种叫做Cre的重组酶，可以识别并切割两个特定的序列，叫做LoxP。通过将目标基因的两端分别插入LoxP序列，然后在特定的细胞或组织中表达Cre，就可以实现目标基因的切除。这种方法可以在转基因小鼠中广泛应用，从而研究基因的功能和发育。</li>
<li>RNA干扰：这种方法利用一种叫做小干扰RNA（siRNA）的分子，可以与目标基因的mRNA互补结合，从而阻止其翻译成蛋白质3。这种方法可以在体外或体内进行，从而实现暂时性或持久性的基因消融。</li>
</ul>
<h2 id="3-您提到了Cre-LoxP系统在基因消融中的应用，但是根据我的经验，Cre-LoxP系统通常用于基因敲除实验，因为Cre酶可以切除整个基因序列。为什么您把这种技术归类为基因消融技术呢？"><a href="#3-您提到了Cre-LoxP系统在基因消融中的应用，但是根据我的经验，Cre-LoxP系统通常用于基因敲除实验，因为Cre酶可以切除整个基因序列。为什么您把这种技术归类为基因消融技术呢？" class="headerlink" title="3. 您提到了Cre-LoxP系统在基因消融中的应用，但是根据我的经验，Cre-LoxP系统通常用于基因敲除实验，因为Cre酶可以切除整个基因序列。为什么您把这种技术归类为基因消融技术呢？"></a>3. 您提到了Cre-LoxP系统在基因消融中的应用，但是根据我的经验，Cre-LoxP系统通常用于基因敲除实验，因为Cre酶可以切除整个基因序列。为什么您把这种技术归类为基因消融技术呢？</h2><p>Cre-LoxP系统确实可以用于基因敲除实验，但是它也可以用于基因消融实验，这取决于LoxP位点的位置和大小。</p>
<p>如果LoxP位点插入到目标基因的内含子中，而不是外显子中，那么Cre酶介导的重组就不会完全切除基因，而是会干扰基因的表达。这种方法可以实现组织特异性或条件性的基因消融。</p>
<p>例如，Cre-LoxP系统可以用于研究心脏发育中的细胞命运和起源。通过将LoxP位点分别插入到心脏前体细胞的特定基因的两端，然后在特定的细胞或组织中表达Cre，就可以实现目标基因的切除。这种方法可以在转基因小鼠中广泛应用，从而研究基因的功能和发育。因此，Cre-LoxP系统是一种灵活的基因消融技术，可以根据实验目的进行调节。</p>
<p><img src="https://pic.imgdb.cn/item/6559f07dc458853aeff28b36.jpg" alt="Cre-LoxP系统"></p>
]]></content>
      <categories>
        <category>生物</category>
      </categories>
      <tags>
        <tag>生物学</tag>
        <tag>基因消融</tag>
        <tag>基因敲除</tag>
        <tag>分子生物学技术</tag>
      </tags>
  </entry>
  <entry>
    <title>《塔》余光中</title>
    <url>/2022/05/25/%E5%A1%94/</url>
    <content><![CDATA[<p>散文摘抄</p>
<span id="more"></span>

<h1 id="塔"><a href="#塔" class="headerlink" title="塔"></a>塔</h1><h3 id="余光中"><a href="#余光中" class="headerlink" title="余光中"></a><strong>余光中</strong></h3><p>一放暑假，一千八百个男孩和女孩，像一蓬金发妙鬘的蒲公英，一吹，就散了。于是这座黝青色的四层铁塔，完全属他一人所有。永远，它矗立在此，等待他每天一度的临幸，等待他攀登绝顶，阅读这不能算小的王国。日落时分，他立在塔顶，端端在寂天寞地的圆心。一时暮色匍匐，万籁在下，塔无语，王亦无语，唯钢铁的纪律贯透虚空。太阳的火球，向马里兰的地平下降。黄昏是一只薄弱的耳朵，频震于乌鸦的不谐和音。鸦声在西，在琥珀的火堆里裂开。西望是艳红的熔岩，自太阳炉中喷出，正淹没当日南军断肠之处，今日艾森豪的农庄。东望不背光，小圆丘上，北军森严的炮位，历历可数。华盛顿在南，白而直的是南下的州道。同一条公路，北驶三英里，便是葛底斯堡的市区了。这一切，这一圈连环不解的王国，完全属他一人所有。</p>
<p>葛底斯堡啊，葛底斯堡。他的目光抚玩着小城的轮廓。来这里半年，他已经熟悉每一条街，每一座有历史的建筑。哪哪，刺入晚空的白塔尖，是路德教堂。风雨打黑的是文学院的钟楼，雉堞上栖着咕咕的野鸽。再过去，是黑阶白柱的“老宿舍”，内战时，是北军骑兵秣马的营地。再过去，再过去该是他的七瓴古屋的绿顶了，虽然他的眼力已经不逮。就在那绿顶下，他度过寥落又忙碌的半年，读书、写诗，写长长的航空信，翻译公元前的古典文学，为了那些金鬘的、褐鬘的女弟子，那些洋水仙。那些洋水仙。纳巴科夫称美国的小女孩做nymphet。他班上的女孩应该是nymph，他想。就在那绿得不可能的绿顶下，那些洋水仙，那些牛奶灌溉的洋水仙，像一部翻译小说的女角那样，走进去，听他朗吟缠绵的《湘夫人》，壮烈的《国殇》。笑他太咸的鱼，太淡的黑莓子酒。他为她们都取了中国名字。金发是文葩。粟发是倪娃。金中带栗的是贾翠霞。她们一来，就翻出他的牙筷，每样东西都夹一下。最富侵略性的，是文葩，搜他的冰箱，戴他的雨帽，翻他的中文字典，皱起眉毛，寻找她仅识的半打象形文字。他戏呼她们为疯水仙，为希腊太妹，为bacchanals。他始终不能把她们看清楚，因为她们动得太快，晃得太厉害。因为碧睛转时，金发便跟着飘扬。她们来时，说话如吟咏，子音爽脆，母音婉柔。她们走后，公寓里犹晃动水仙的影子。他总想教她们停下来，让他仔细阅读那些瞳中的碧色，究竟碧到什么程度。</p>
<p>但塔下只有碧草萋萋。晚风起处，脚下的新枫翻动绿阴。这是深邃的暑假，水仙们都已散了，有的随多毛的牧神，有的，当真回欧洲去了。翠霞要嫁南方的羊蹄人。文葩去德国读日耳曼文学。终于都散了，就这么莫名其妙地散了，正如当初，莫名其妙地聚拢来一样。偌大的一片校园，只留下几声知更，只留下，走不掉而又没人坐的靠背长椅，怔怔对着花后的木兰。牧神和水仙践过的芳草，青青如故。一觉醒来，怎么小城骤然老了三十岁？第一次，他发现，这里的居民多么龙钟，满街是警察、店员、保险商、收税吏、战场向导、面目模糊的游客。闷得发慌的下午，暑气炎炎，蟠一条火龙在林肯方场的顶空。车祸频起，救护车的警笛凄厉地宰割一条大街。</p>
<p>所以水仙们就这么散了。警笛代替了牧歌。羊蹄踹过的草地上，只留下一些烟蒂。临行前夕，神与兽，纷纷来叩门。“我们会惦记你的，”柯多丽说。“愿你能回来，再教我们。”倪娃拿走他的底片。一下午，羊蹄不断踢他的公寓。虬髯如盗的霍豪华，金发童颜的贝伯纳，邀他去十英里外，方丈城的一家德国餐馆，叫Hofbrauhaus的，去大嚼德国熏肉和香肠，豪饮荷兰啤酒。熏肉和香肠他并不特别喜欢，但饮起啤酒来，他不醉不止。笨重而有柄的史泰因大陶杯，满得欲溢的醇醪，浮面酵起一层滃滃的白沫，一口芳冽，顿时有一股豪气，自胃中冲起，饮者欲哭欲笑，欲拔剑击案而歌。唱机上回旋着德意志的梦，舒伯特的梦，舒曼的梦。绞人肚肠的一段小提琴，令他想起以前同听的那人，那人慵懒的鼻音。他非常想家。他尖锐地感到，离家已经很久，很远了。公寓里的那张双人床，那未经女性的柔软和浑圆祝福过的，荒凉如不毛的沙漠。那夜他是醉了。昏黄的新月下，他开车回去，险些撞在一株老榆树上。</p>
<p>第二天，他起得很迟。坐在参天的老橡阴下，任南风拂动鬓发，宿酲中，听了一下午琐琐屑屑细细碎碎申申诉诉说说的鸟声。声在茂叶深处渗出漱出。他从来没有听过那样好听的鸣禽，也从未像那天那么想家。他说不出是知更还是画眉。鸣者自鸣。聆者欢喜赞叹地聆听。他坐在重重叠叠浓浓浅浅的绿思绿想中。他相信自己的发上淌得下沁凉的绿液。城春。城夏。草木何深深。泰山耸着。黄河流着。……东方已有太多的伤心，又何必黯然，为几个希腊太妹？他想起，好久，好久没接触东方的温婉了。隐身的歌者仍在歌着。他幻想，自己在抚弄一只手，白得可以采莲的一只手。而且吟一首《念奴娇》向一只娇小的耳朵，乌发下的耳朵。隐身的歌者仍在歌着。</p>
<p>第三天，停车场上空落落的，全部走光了。园是废园。城是死城。他缓缓走下无人的林阴道，感到空前的疲倦。只有他不能离开，七月间，他将走得更远。他将北上纽约，循传说中惧内猎人的足迹，越过凯茨基山，向空阔的加拿大。但在那之前，他必须像一个白发的老兵，独守一片古战场。小城四郊的墓碑，多于铜像，铜像多于行人。至少墓碑的那一面很热闹，自虐而自嘲地，他想道。至少夜间比昼间热闹。夜间，猫眼的月为鬼魂唱一整个通宵，连窗上的雏菊也失眠了。电影院门首的广告画，虚张声势，探手欲攫迟归的行人。只有逃不掉的邮筒，患得患失地伫立在街角。子夜后的班车，警铃叮叮，大惊小怪地踹过市中心，小城的梦魇陷得更深。为何一切都透明得可怕？这里没有任何疆界。现在覆叠着将来。他走过神学院走过蜡像馆走过郁金香泣血的方场，但大半的时间，他走在梦里走在国内走在记忆的街上。这种完整而纯粹的寂寞，是享受，还是忍受，他无法分辨。冰箱充实的时候，他往往一星期不讲一句话。信箱空洞的时候，他似乎被整个世界所遗忘，且怀疑自己的存在。立在塔顶，立在钢铁架构的空中，前无古人，后无来者，时人亦冷漠而疏远。何以西方茫茫，东方茫茫？寂寞是国，我是王，自嘲兼自慰，他想。她来后，她来后便是后，和我同御这水晶的江山。她来后，一定带她来塔顶，接受寂寞国臣民的欢呼，铜像和石碑的欢呼，接受两军铁炮冥冥的致敬，鼓角齐奏，鬼雄悲壮的军歌。她来后，一定要带她去那张公园椅上，告诉她，他如何坐在那椅上，读她的信。也要她去抚摸街角的那个信箱，那是他所有航空信的起站。她来后，一定要带她去那家德国餐馆，要她也尝尝，那种冰人肺腑的芳冽，他想。</p>
<p>她来后。她来后。她来后。他的生命似乎是一场永远的期待，期待一个奇迹，期待一个蜃楼变成一座俨然的大殿堂。期待是一种半清醒半疯狂的燃烧，使焦灼的灵魂幻觉自己生活在未来。灵魂，不可能的印第安雷鸟①，不可能柔驯地伏在此时此刻的掌中，它的翅膀更喜欢过去的风，将来的云。他钦羡英雄和探险家，羡他们能高度集中地孤注一掷地生活在此时此地，在血的速度呼吸的节奏，不必，像他那样，经常病态地生活在回忆和期待。生死决斗的武士，八肢互绞的情人，与山争高的探险家，他钦羡的是这些。他更钦羡阿拉伯的劳伦斯，同一只手，能陷城，也能写诗，能测量沙漠，也能探索灵魂，征服自己，且征服敌人。</p>
<p>但此刻，天上地下，只剩下他一人。鸦已栖定。落日已灭亡。剩下他，孤悬于回忆和期待之间，像伽利略的钟摆，向虚无的两端逃遁，而又永远不能逸去。剩下他，血液闲着，精液闲着，泪腺汗腺闲着，愤怒的呐喊闲着。剩下他，在恐惧之后回顾恐惧，危险之前预期危险。对于他，这是过渡时期，渡船在两个岸间飘摆。这是大征伐中，一段枕剑的小小假寐。因为他的战场，他的床，他的沙漠在中国，在中国，在日落的方向，他的敌人和情人和同伴同伴。自从他选择了笔，自从他选择了自己的武器，选择了蓝色的不是红色的血液，他很久没有享受过深邃安详如一座寺院的暑假，如他现在所享受的一样。暑假是时间的奢侈品，属于看云做梦的少年。他用单筒的记忆，回顾小时候的那些暑假，当夏季懒洋洋地长着，肥硕而迟钝如一只南瓜，而他，悠闲如一只蝉。那些椰荫下的，槐阴下的，黄桷树阴下的暑假。读童话，读神话，读天方夜谭的暑假。那时，母亲可靠如一株树，他是树上唯一的果子。那时，他有许多“重要”的同学，上课同桌，睡觉同床，记过时，同一张布告，诅咒时，以彼此的母亲为对象。那些暑假呢？那些母亲呢？那些重要的伙伴呢？</p>
<p>至少他的母亲已经死了，好客的伯母死了，在另一座塔下。那里，时间毫无意义地流着，空间寄托在宗教的租界。是处梵呗如呓，香火在神龛里伸着懒腰。他来自塔的国度。古老的上国已经陆沉，只留下那些塔，兀自顽强地自尊地零零落落地立着，像一个英雄部落的遗族。第二次大战后，他和母亲乘汽船，顺长江东下。船泊安庆。母与子同登佛寺的高塔②，俯瞰江面的密樯和城中的万户灰甍。塔高风烈。迷蒙的空间晕眩的空间在脚下，令他感觉塔尖晃动如巨桅，而他是一只鹰，一展翅一切云都得让路。十九岁的男孩，厌倦古国的破落与苍老。外国地理是他最喜欢的一门课。暑假的下午，半亩的黄桷树阴下，他会对着诱人的地图出神，怔怔望不厌意大利在地中海濯足，多龙的北欧欲噬丹麦，望不厌象牙海岸，尼罗河口，江湖满地的加拿大，岛屿满海的澳洲。从一本日历上，他看到一张风景照片，一列火车，盘旋而上庞伟的落基山，袅袅的黑烟曳在空中。他幻想自己坐在这车上，向芝加哥，向纽约，一路阅览雪峰和连嶂。去异国。去异国。去遥远的异国，永远离开平凡的中国。</p>
<p>安庆到葛底斯堡，两座塔隔了二十年。立在这座钢筋的了望塔上，立在二十年的这一边，他抚摸二十年前的自己，自己的头发，自己的幼稚，带着同情与责备。世界上最可爱最神秘最伟大的土地，是中国。踏不到的泥土是最香的泥土。远望岂能当归，岂能当归？就如此刻，山外是平原，平原之外是青山是青山。俄亥俄之外是印第安纳之外是艾奥瓦是内布拉斯加是内华达，乌鸦之西仍是乌鸦是归巢的乌鸦。唯他的归途是无涯是无涯是无涯。半世纪来，多少异乡人曾如此眺望？胡适之曾如此眺望。闻一多如此眺望。梁实秋如此眺望。五四以来，多少留学生曾如此眺望。珊瑚色渐渐吸入加稠的怅青，西南仍有一派依恋的余光。葛底斯堡的方向，灯火零零落落地亮起。值得怀念的小城啊，他想，百年前的战场，百年后的公园，葛底氏之堡，林肯的自由的殿堂。一列火车正迤迤逦逦驶过市中心。当日林肯便乘这种火车，来这里向阵亡将士致敬，且发表那篇演说。他预感得到，将来有人会怀念这里，在中国，怀念这一段水仙的日子，寂寞又自由的日子，在另一个战场，另一种战争之中。这次回去，他将再度加入他的同伴，他将投身历史滔滔的浊流，泳向旋涡啊大旋涡的中心。因为那也是一种内战。文化的内战，精神的内战，我与自己的决斗，为了攻打中国人偏见的巴士底狱，解放孔子后裔的想像力和创造的生命。也许他成功。也许他失败。但未来的历史将因之改向。</p>
<p>但在回去之前，他必须独自保持清醒的燃烧。就如那边的北极星，冷静地亮着，不失自己的方向，且为其他的光，守住一个定点。夜色部署得很快，顷刻间，恫吓已呈多面，从鼠灰到黝青到墨黑。但黑暗只有加强星的光芒。星的阵图部署得更快，在夜之上，在万籁之上之上，各种姓名的光，从殉道的红到先知的皎白透青，一一宣布自己的方位。他仰面向北，发现大熊和小熊开阔而灿明，如一面光之大纛，永不下半旗，那角度，比国内所见的高出许多。抓住冻手的栏杆，他感到金属上升的意志和不可动摇的力量。他感到，钢铁的生命，从他的掌心、脚心上升，如忠于温度的水银，逆流而且上升，达于他的四肢，他的心脏。在一个疯狂的豁然的顷刻，他幻觉自己与塔合为一体，立足在坚实的地面，探首于未知的空间，似欲窃听星的谜语，宇宙大脑微妙的运行。一霎间，他欲引吭长啸。但塔的沉默震慑住他。挺直的脊椎，纵横的筋骨，回旋梯的螺形回肠，挣扎时振起一种有秩序的超音乐。寂寞啊寂寞是一座透明的堡，冷冷地高，可以俯览一切，但离一切都那么遥远。鸟与风，太阳与霓虹，都从他架空的胸肋间飞逝，留下他，留下塔，留下塔和他，在超人的高纬气候里，留下一座骄傲的水晶牢，一座形而上的玻璃建筑，任他自国，自毁，自拯，或自卫。</p>
<p>1965年6月17日，葛底斯堡</p>
<p>-———————————————————-</p>
<p>《文星》编者附记：谢谢周弃子先生！本文在《文星》第九十三期发表的次日，他就写来这样一封信。</p>
<p>白帆老棣：</p>
<p>光中兄大作《塔》附注②的问题解决了。安庆江边的那座寺和塔叫迎江寺振风塔。这是我的朋友廖寿泉告诉我的，他是安徽望江县人，在安庆住了很久。他古典诗作得极好。</p>
<p>请写信便中告诉光中，并代致想念！</p>
<p>1965年7月2日</p>
]]></content>
      <categories>
        <category>摘抄</category>
      </categories>
      <tags>
        <tag>散文摘抄</tag>
      </tags>
  </entry>
  <entry>
    <title>如何对3D数据进行可视化展示</title>
    <url>/2022/10/18/%E5%A6%82%E4%BD%95%E5%AF%B93d%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B1%95%E7%A4%BA/</url>
    <content><![CDATA[<p>很多时候，我们要对三维空间中的数据进行可视化展示和分析。然而，由于三维空间内的数据可视化涉及透视、投影等操作，其复杂性远高于平面内的数据可视化。因此我花了一下午的时间，调研了一下相关工具，汇总成本文。文中一些疏漏之处，还请多多指教。</p>
<span id="more"></span>

<h2 id="一、基于python的方法"><a href="#一、基于python的方法" class="headerlink" title="一、基于python的方法"></a>一、基于python的方法</h2><h3 id="（一）matplotlib"><a href="#（一）matplotlib" class="headerlink" title="（一）matplotlib"></a>（一）matplotlib</h3><p>matplotlib在科学技术和统计分析中多有使用，但是以往人们用得多的是他的二维数据展示功能，例如各种统计图的绘制。但是matplotlib也可也展示三维数据。下面是一个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入三维工具包mplot3dfrom mpl_toolkits import mplot3d</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">#从三个维度构建</span></span><br><span class="line">z = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">x = z * np.sin(<span class="number">20</span> * z)</span><br><span class="line">y = z * np.cos(<span class="number">20</span> * z)</span><br><span class="line"><span class="comment">#创建3d绘图区域</span></span><br><span class="line">ax = plt.axes(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">ax.plot3D(x, y, z, <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>结果如下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/65411f13c458853aefd4509f.png" alt="figure1"></p>
<p>当然，也可也创建三维曲面：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#求向量积(outer()方法又称外积)</span></span><br><span class="line">x = np.outer(np.linspace(-<span class="number">2</span>, <span class="number">2</span>, <span class="number">30</span>), np.ones(<span class="number">30</span>))</span><br><span class="line"><span class="comment">#矩阵转置</span></span><br><span class="line">y = x.copy().T </span><br><span class="line"><span class="comment">#数据z</span></span><br><span class="line">z = np.cos(x ** <span class="number">2</span> + y ** <span class="number">2</span>)</span><br><span class="line"><span class="comment">#绘制曲面图</span></span><br><span class="line">ax = plt.axes(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">ax.plot_surface(x, y, z,cmap=<span class="string">&#x27;viridis&#x27;</span>, edgecolor=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.imgdb.cn/item/65411f3ec458853aefd58842.png" alt="figure2"></p>
<p>然而，上述方法也有缺点。<strong>maplotlib的三维绘图工具本质上只是将三维结构中的点 “拍扁”</strong> <strong>到二维空间中，因此如果两个三维结构有相交，这种绘图方法会导致两个图形的空间位置错乱</strong>，而且根本看不出相交线。</p>
<p>一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#求向量积(outer()方法又称外积)</span></span><br><span class="line">x = np.outer(np.linspace(-<span class="number">2</span>, <span class="number">2</span>, <span class="number">30</span>), np.ones(<span class="number">30</span>))</span><br><span class="line"><span class="comment">#矩阵转置</span></span><br><span class="line">y = x.copy().T </span><br><span class="line"><span class="comment">#数据z</span></span><br><span class="line">z1 = x**<span class="number">2</span>+y</span><br><span class="line">z2 = x**<span class="number">2</span>-y</span><br><span class="line"><span class="comment">#绘制曲面图</span></span><br><span class="line">ax = plt.axes(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">ax.plot_surface(x, y, z1,cmap=<span class="string">&#x27;viridis&#x27;</span>, edgecolor=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">ax.plot_surface(x, y, z2,cmap=<span class="string">&#x27;plasma&#x27;</span>,  edgecolor=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.imgdb.cn/item/65411f65c458853aefd67eec.png" alt="figure3"></p>
<p>可以从上图中看到，函数z2的图像全部遮盖住了z1的图像。然而从函数表达式中我们可以得知，z1与z2有一个相交的曲线（<code>y=0, z=x^2</code>），这并不能从图中体现出来。通过这个例子我们可以知道，使用matplotlib绘制三维函数图像，虽然可行（_真的吗？_），但是总归不严谨。</p>
<h3 id="（二）Mayavi"><a href="#（二）Mayavi" class="headerlink" title="（二）Mayavi"></a>（二）Mayavi</h3><p>Mayavi是一个3-D科学数据可视化工具，其官网为<a href="https://mayavi.readthedocs.io/">https://mayavi.readthedocs.io/</a>。可以通过下列的conda指令进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install -c conda-forge pyqt <span class="comment"># PyQt5为Mayavi所依赖，因此需要预先安装</span></span><br><span class="line">conda install -c conda-forge mayavi</span><br></pre></td></tr></table></figure>

<p>Mayavi是一个很大的工具包，因此安装耗时也比较长，请耐心等待。安装成功后，在命令行输入指令<code>mayavi2 --version</code>，如果能够正确输出版本号（例如<code>Mayavi 4.7.2</code>），则表明安装成功。</p>
<p>Mayavi可以以一个独立的应用程序的形式运行，当然也可也在python代码中调用。Mayavi提供了一个叫做<a href="https://mayavi.readthedocs.io/en/latest/mlab.html">mlab</a>的接口，通过<code>from mayavi import mlab</code>在python中导入这个接口，即可像matplotlib一样使用。</p>
<p>使用mayavi进行数据可视化展示的一个示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> mayavi <span class="keyword">import</span> mlab</span><br><span class="line">x, y = np.ogrid[-<span class="number">2</span>:<span class="number">2</span>:<span class="number">20j</span>, -<span class="number">2</span>:<span class="number">2</span>:<span class="number">20j</span>]</span><br><span class="line">z = x * np.exp( - x**<span class="number">2</span> - y**<span class="number">2</span>)</span><br><span class="line">pl = mlab.surf(x, y, z, warp_scale=<span class="string">&quot;auto&quot;</span>)</span><br><span class="line">mlab.axes(xlabel=<span class="string">&#x27;x&#x27;</span>, ylabel=<span class="string">&#x27;y&#x27;</span>, zlabel=<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">mlab.outline(pl)</span><br><span class="line">mlab.show()</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.imgdb.cn/item/65411fb7c458853aefd88e56.png" alt="figure4"></p>
<p>对于多个相交的曲面，Mayavi的展示效果要强于matplotlib，其可以很好的反映两个曲面的相交情况。下图展示一个例子（仍然以上一小节中的函数z1和z2为例）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> mayavi <span class="keyword">import</span> mlab</span><br><span class="line">x, y = np.ogrid[-<span class="number">2</span>:<span class="number">2</span>:<span class="number">20j</span>, -<span class="number">2</span>:<span class="number">2</span>:<span class="number">20j</span>]</span><br><span class="line">z1 = x**<span class="number">2</span> + y</span><br><span class="line">z2 = x**<span class="number">2</span> - y</span><br><span class="line">pl1 = mlab.surf(x, y, z1, warp_scale=<span class="string">&quot;auto&quot;</span>, colormap=<span class="string">&#x27;autumn&#x27;</span>)</span><br><span class="line">pl2 = mlab.surf(x, y, z2, warp_scale=<span class="string">&quot;auto&quot;</span>, colormap=<span class="string">&#x27;winter&#x27;</span>)</span><br><span class="line">mlab.axes(xlabel=<span class="string">&#x27;x&#x27;</span>, ylabel=<span class="string">&#x27;y&#x27;</span>, zlabel=<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">mlab.outline(pl1)</span><br><span class="line">mlab.outline(pl2)</span><br><span class="line">mlab.show()</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.imgdb.cn/item/65411fe5c458853aefd9baad.png" alt="figure5"></p>
<h3 id="（三）PyVista"><a href="#（三）PyVista" class="headerlink" title="（三）PyVista"></a>（三）PyVista</h3><p>PyVista是另一个基于Python的三维数据可视化软件。其官网为<a href="https://docs.pyvista.org/index.html">https://docs.pyvista.org/index.html</a>。安装方法也很简单，直接执行指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install -c conda-forge pyvista</span><br></pre></td></tr></table></figure>

<p>即可。</p>
<p>使用PyVista绘图的一个示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pyvista <span class="keyword">as</span> pv</span><br><span class="line"><span class="keyword">from</span> pyvista <span class="keyword">import</span> examples</span><br><span class="line"><span class="comment"># Make data</span></span><br><span class="line">x = np.arange(-<span class="number">2</span>, <span class="number">2</span>, <span class="number">0.05</span>)</span><br><span class="line">y = np.arange(-<span class="number">2</span>, <span class="number">2</span>, <span class="number">0.05</span>)</span><br><span class="line">x, y = np.meshgrid(x, y)</span><br><span class="line">z1 = x**<span class="number">2</span> + y </span><br><span class="line">z2 = x**<span class="number">2</span> - y</span><br><span class="line">grid1 = pv.StructuredGrid(x, y, z1) <span class="comment"># 绘制函数z1的多边形模型</span></span><br><span class="line">grid2 = pv.StructuredGrid(x, y, z2) <span class="comment"># 绘制函数z2的多边形模型</span></span><br><span class="line">pl = pv.Plotter() <span class="comment"># 创建绘图对象</span></span><br><span class="line">pl.add_mesh(grid1, color=<span class="string">&quot;#5599aa&quot;</span>) <span class="comment"># 将函数z1的多边形模型加入绘图对象中，并设置颜色</span></span><br><span class="line">pl.add_mesh(grid2, color=<span class="string">&quot;#aa9965&quot;</span>) <span class="comment"># 将函数z2的多边形模型加入绘图对象中，并设置颜色</span></span><br><span class="line">pl.add_axes(line_width=<span class="number">5</span>, labels_off=<span class="literal">False</span>) <span class="comment"># 左下角展示坐标轴</span></span><br><span class="line">pl.show() <span class="comment"># 图像展示</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pic.imgdb.cn/item/65412029c458853aefdb6df5.jpg" alt="figure6"></p>
<h2 id="二、基于matlab的方法"><a href="#二、基于matlab的方法" class="headerlink" title="二、基于matlab的方法"></a>二、基于matlab的方法</h2><p>前面我们讲了三种基于python的三维结构展示方法，但是其实很多科学计算软件内置了三维数据可视化方法，例如matlab。下面举一个例子</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear;<span class="comment">%清除之前所有已有的变量</span></span><br><span class="line">X=[<span class="number">-2</span>:<span class="number">0.05</span>:<span class="number">2</span>];</span><br><span class="line">Y=[<span class="number">-2</span>:<span class="number">0.05</span>:<span class="number">2</span>];</span><br><span class="line">[x,y] = <span class="built_in">meshgrid</span>(X,Y);</span><br><span class="line">z1 = x.^<span class="number">2</span> + y; <span class="comment">% 函数z1</span></span><br><span class="line">z2 = x.^<span class="number">2</span> - y; <span class="comment">% 函数z2</span></span><br><span class="line"></span><br><span class="line">mesh(x,y,z1);</span><br><span class="line"><span class="built_in">hold</span> on; <span class="comment">% 保持上一个图形不消失，继续绘制</span></span><br><span class="line">mesh(x,y,z2);</span><br><span class="line">xlabel(<span class="string">&#x27;x&#x27;</span>), ylable(<span class="string">&#x27;y&#x27;</span>), zlabel(<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">show()</span><br></pre></td></tr></table></figure>

<p>结果如下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/654120a9c458853aefdebe21.png" alt="figure7"></p>
<hr>
<hr>
<blockquote>
<p>旧评论系统备份：</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Hazel(2022-10-19 14:53:41):</span><br><span class="line">	咱就说，可以每周讲一个用法吗？可以别人定那种？</span><br><span class="line">	我还挺好奇内积的，以及希望矩阵的一点点用法多搞一下</span><br><span class="line">	或者是偏数学的东西，比如多元线性回归、最大似然估计啦之类的？</span><br><span class="line"></span><br><span class="line">Hazel(2022-10-19 14:56:40):</span><br><span class="line">	还有就是，可以直接pip install 去安装吗？为什么要conda install 呀</span><br><span class="line"></span><br><span class="line">&gt; WarrenZhang(2022-10-19 15:09:40):</span><br><span class="line">&gt;	可以的哈哈哈，那我试一下，下周写一点数学方面的文章（不过以前没写过这种类型的文章，不保证质量😂）</span><br><span class="line">&gt;</span><br><span class="line">&gt; WarrenZhang(2022-10-19 15:14:32):</span><br><span class="line">&gt;	也可以的，不过我用conda装习惯了，这次也就用了conda，没有踩pip install的坑。</span><br><span class="line">&gt;	或许你可以试试用pip install？这几个工具的文档都很全，里面列了pip的安装方法，例如mayavi就可以用</span><br><span class="line">&gt;		pip install mayavi</span><br><span class="line">&gt;		pip install PyQt5</span><br><span class="line">&gt;	来安装（但是貌似这种安装方法需要手动安装vtk，然而vtk好像要用conda安装）</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>三维数据可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>恋爱年龄测试（仅供娱乐）</title>
    <url>/2022/08/06/%E6%81%8B%E7%88%B1%E5%B9%B4%E9%BE%84%E6%B5%8B%E8%AF%95%EF%BC%88%E4%BB%85%E4%BE%9B%E5%A8%B1%E4%B9%90%EF%BC%89/</url>
    <content><![CDATA[<p>仅供娱乐的小测试</p>
<span id="more"></span>

<p>在网上发现一个在线小测试，挺有意思的，网址奉上：</p>
<p><a href="https://www.arealme.com/when-will-i-get-married/en/">恋爱年龄测试</a></p>
<p>随便测了一下，结果并不是很理想，看来是要孤独终老了。唉~</p>
<p>另外，这个网站上还有些别的测试，也挺有意思，无聊的时候可以测着玩😜</p>
<hr>
<hr>
<blockquote>
<p>旧评论系统备份：</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">小阿鸣(2022-08-08 00:54:15):</span><br><span class="line">	54..孤寡</span><br><span class="line"></span><br><span class="line">&gt; WarrenZhang(2022-08-08 12:02:48):</span><br><span class="line">&gt;	孤寡...🤧</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>杂思</category>
      </categories>
      <tags>
        <tag>恋爱</tag>
        <tag>心理测试</tag>
      </tags>
  </entry>
  <entry>
    <title>我的毕业论文致谢</title>
    <url>/2022/06/28/%E6%88%91%E7%9A%84%E6%AF%95%E4%B8%9A%E6%84%9F%E6%83%B3/</url>
    <content><![CDATA[<p>本科毕业啦</p>
<span id="more"></span>

<hr>
<blockquote>
<p>毕业论文致谢</p>
</blockquote>
<p>如果把人生比作一场长跑，我们大学四年的短暂时光只能算作比赛的起跑阶段。然而，在这短短四年的时间中，我有幸加入了南开大学生物伯苓班这个大家庭，更有幸能来到BP研究所这个神圣的地方，窥见了生命科学的一些奥秘。</p>
<p>和生物学结缘于中学。在那次的实验课上，第一次在显微镜下观察到活细胞，对于十几岁的我来说是既好奇又兴奋。在那以后，我深深迷上了这个学科。后来我获得了安徽省生物学竞赛一等奖。再后来，我考上了南开大学，如愿以偿进入生命科学学院学习。</p>
<p>那个时候我就对生物信息学有所了解，加上自己对计算机科学也很感兴趣，自然而然萌生了想要在生物信息学领域有所发展的想法。于是在大一时，我就开始学习计算机编程和Linux操作系统的有关知识，并一度对机器学习很着迷。然而，因为自身原因，我渐渐沉迷于互联网的繁杂世界中无法自拔，以至于大二大三时一度荒废了学业，也遗忘了心中的梦想——直到大三下半学期。</p>
<p>我很想把大三下半学期看作大学生活的转折点，那个学期里我来到了BP研究所，并进入H老师的实验室学习生物信息学知识和技术。那是我正式接触生物信息学研究的开始。我知道了“单倍型”“连锁不平衡评分回归”等名词，学习了各种软件的配置与使用，并在一次次和师兄师姐的讨论交流中对生物信息学研究的全貌有了越来越清晰的了解。</p>
<p>很感谢我的导师H研究员，谢谢H老师在这一年里对我的关心和照顾，在他的指导下，我才能更加顺利地完成毕业设计与科创计划。只是有些遗憾，因为保研名额的原因，最终没能留在H老师的实验室，也因此在最后这半年里常常对H老师怀有一种愧疚的心情。还记得去年刚结束考研不久，那一次我找H老师为科研训练报告签字，H老师语重心长地告诉我：“最终还是希望你们自己能够对自己负起责任，既然来实习，要投入也要能够有收获。事实上在你以后的人生发展当中，你要做的只是对自己负责。”那时，因为复习考研，我离开实验室三个多月，期间并没有参与科研工作，而H老师的这一番话让我羞愧难当。在这以后，我常常用H老师的这一番话提醒自己，对自己真正负起责任。</p>
<p>考研结束之后，我的毕业设计课题才算正式开始实施。其间经历了不少曲折，但最后还是坚持完成了。很感谢项目实施过程中L老师的指导与建议，L老师经常耐心地解答我的问题，直到我完全理解，在她的影响下我的编程水平也有了很大的提升。也很想感谢Z老师在几个关键数学问题上的点拨。感谢实验室的L师兄、Z师姐以及其他师兄师姐们，在他们的指导帮助下我学到了许多有用的技术和思维理念，为我今后的科研道路奠定了坚实的基础。感谢开朗外向的H师姐为实验室带来的欢声笑语，也感谢她对我的陪伴与鼓励。感谢豪爽大方的实习生Y同学，在我完成毕设的几个月里和她交流了很多话题，和她相处的这些日子里，我对人生有了许多新的思考，谢谢她让我在大学的最后阶段又收获了一段友谊。</p>
<p>要感谢的不止这些。一路走来，只感到自己真的很幸运，不论是最初选导师时选择了H老师，还是在保研失败后大家对我的关心和帮助，抑或是完成毕设的那几个月里来自身边同学朋友的陪伴和支持，都令我倍感温暖。还要特别感谢邹承鲁班这个大家庭里的亲人们（点名C同学，S同学，W同学，Y同学），因为有你们的一路相伴，大学最后一年的生活变得丰富多彩了起来。</p>
<p>当然，也想感谢努力前行的自己。</p>
<p>还有很多想说的话，想感谢的人，限于篇幅不再多言。诸多感触，难以写出，唯如人饮水，冷暖自知。</p>
<p><em>（为保护隐私，部分人名地名被隐去）</em></p>
<hr>
<hr>
<blockquote>
<p>旧评论系统备份：</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Chuanbo(2022-11-13 23:32:42):</span><br><span class="line">	哇好长的论文致谢，感觉未来好多年之后回头来看很有纪念意义！</span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>杂思</category>
      </categories>
      <tags>
        <tag>毕业感想</tag>
        <tag>致谢</tag>
      </tags>
  </entry>
  <entry>
    <title>小故事两则</title>
    <url>/2022/07/01/%E5%B0%8F%E6%95%85%E4%BA%8B%E4%B8%A4%E5%88%99/</url>
    <content><![CDATA[<p>某天想到的几篇小故事。</p>
<p>可能并不是故事，而是人生。</p>
<span id="more"></span>

<h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>有个黑客想要入侵一个电脑小白的电脑。</p>
<p>小白虽然是小白，但他不傻，他在他的电脑上安装了361安全卫士，只要361在，黑客进不来。</p>
<p>于是黑客进行了一波看似好心的舆论宣传：“361是个毒瘤”“361拖慢开机速度，占据系统资源，严重影响使用”“361天天弹广告，还未经允许扫描我的文件，是个彻彻底底的流氓”。</p>
<p>于是小白听信了这些宣传，卸载了361安全卫士。</p>
<p>没有了361的保护，黑客长驱直入，迅速入侵了小白的电脑。于是小白的个人信息，工作文件，还有许多不可描述的资料，全被黑客拿到了。小白的家人和同事也要遭殃。</p>
<p>诚然，361的某些表现很像流氓软件；然而，这个“流氓”的行为，相比于黑客的入侵行为来说，根本不值一提。</p>
<p>那么小白应该怎么做才能保护好自己呢？一种就是不要在意那些舆论宣传，继续让361保护好自己。另一种就是练就内功，成为网安大佬，在这以后他的电脑上有没有361已经不重要了，因为他自己就会开发出个542卫士、723杀毒，照样能给保护好自己。</p>
<p>有人看了这个故事，对小白很不屑一顾，他们说，“我宁愿让黑客入侵自己，也不愿意让流氓软件天天弹广告”“被黑客入侵以后，你就自由了，你就从邪恶的361下面解放出来了”。然而，点开这些人的头像一看，他们要不就是黑客的小号，要不就是和黑客同一阵营的人，并且还用着黑客开发的“卡扎斯基”反黑客软件。</p>
<h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>从前有个商人，他来到一片地区推销他的产品。然而这片地区上的人民自给自足、怡然自乐，没人理会他。</p>
<p>商人就想，我应该通过舆论造点势，让大家都来买我的产品。</p>
<p>他的目光首先落在了青年男女身上。这群年轻人开朗而自信，热情而团结，正是谈恋爱的年龄，虽然他们都不怎么打扮化妆，但都互相爱慕。</p>
<p>商人说，不化妆的女孩子不配被男人喜欢。商人又说，没钱且不上进的男孩子不配称为男人，更不配拥有女朋友。</p>
<p>于是一些女孩子画起了妆，并且对自己体贴但赚钱不多的男友挑剔了起来。于是一些男孩子开始攀比工资，攀比工作，渐渐忽略了自己的女友，也对自己素颜的女友挑挑拣拣。</p>
<p>于是商人的化妆品卖出去了。于是商人收获了一批打工人，每天数钱不亦乐乎。</p>
<p>然而还有一部分思想比较保守（传统？）的年轻人，他们还像以前那样生活，互相爱慕，相濡以沫。</p>
<p>于是商人又发话，“人应该自私一点，为自己活着，任何替他人着想的行为都是傻X行为，要么就是别人想要利用你”。</p>
<p>于是这些年轻人开始互相猜忌，互相疏远，最终又回到了一个人生活的状态，曾经两个人可以轮流分担的家务劳动变成了一个人的负担。</p>
<p>于是商人的家务机器人大卖。不仅如此，因为人们之间相互疏远，很多情绪没有地方宣泄，于是商人的元宇宙产品《素仙》大卖，而年轻人们则一边花着钱，一边感谢着商人带来的家务机器人和《素仙》元宇宙。</p>
<p>商人又看到这片地区上人们家庭和睦幸福，父母在孩子成长中给了孩子很多的爱，而孩子也会在长大后回报父母。商人说，“你们年轻人生活中一半多的痛苦，都来自于你原生家庭带给你的创伤”。商人又说，“为了一个孩子的健康成长，父母应该投入巨量的资源用于培养孩子，让他除了会学习，还要会xxx，还要去过xxxx”。</p>
<p>于是刚刚遭到社会毒打的年轻人，开始怪罪自己的父母，并渐渐和他们疏远。于是那些初为人父人母的，开始怀疑自己是不是不应该生孩子，并视孩子为吞金兽，不再给孩子足够的爱。</p>
<p>于是一些老年人没有了孩子的照顾，商人的养老产品得到大卖。于是一些父母听信了商人的话，培训课程得到了大卖。于是一些年轻的夫妻决定不要孩子，计生产品也得到了大卖。</p>
<p>最重要的，越来越多的人失去了和亲人、和伴侣、和孩子交流沟通的机会（也有人把这个事情视作自己的权力，认为这会让自己拥有更多属于自己的时间），于是他们将这些时间花在了替商人打工上，花在了挑选购买商人的产品上，花在了从商人那里买来的元宇宙《素仙》上。</p>
<p>于是商人成为了地区首富。地区也变得“现代化”“智能化”了起来。</p>
<p>只不过，可能比以前少了些人与人之间的温情吧。</p>
<hr>
<hr>
<blockquote>
<p>旧评论系统备份：</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Hazel(2022-07-12 14:22:56):</span><br><span class="line">	对第二个故事印象深刻。有人选择从前的生活方式，有人在“现代化”的气球里，但是只要很快乐就没有反对的权利。</span><br><span class="line">	问题只是在于，我们越来越在乎别人的眼光、社会的评价，因此分不清有些愿望和快乐究竟是社会告诉我们的，还是我们自己内心真正的想法。</span><br><span class="line">	可是，关于怎么问清楚自己的内心，一直是个大难题。而且人是社会动物，有时候在洪流中过完一生也难以自知。</span><br><span class="line"></span><br><span class="line">&gt; 小阿鸣(2022-08-26 16:04:32):</span><br><span class="line">&gt; 	桢姐见解精辟啊 👍</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>杂思</category>
      </categories>
  </entry>
  <entry>
    <title>教授、研究员、高级工程师、工程师，各系列职称体系对比</title>
    <url>/2022/06/02/%E6%95%99%E6%8E%88%E3%80%81%E7%A0%94%E7%A9%B6%E5%91%98%E3%80%81%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E3%80%81%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%8C%E5%90%84%E7%B3%BB%E5%88%97%E8%81%8C%E7%A7%B0/</url>
    <content><![CDATA[<p>各系列职称体系对比</p>
<span id="more"></span>

<blockquote>
<p>时间：2020-07-21 23:02:13   作者：一笑而过   阅读：2200   评论：0<br>原文链接：<a href="http://www.ahcost.net/cost/news/?412.html">http://www.ahcost.net/cost/news/?412.html</a></p>
</blockquote>
<h2 id="一：高校教育系列"><a href="#一：高校教育系列" class="headerlink" title="一：高校教育系列"></a>一：高校教育系列</h2><p>一般是即从事教学又从事科研的教师系列职称分为四级。</p>
<p>助教，讲师，副教授，教授。</p>
<h2 id="二：工程技术系列"><a href="#二：工程技术系列" class="headerlink" title="二：工程技术系列"></a>二：工程技术系列</h2><p>一般从事工程技术系列或从事科研向工程应用技术研究过度的工程技术人才职称，高校试验人才、应用型技术研究，一般不从事教学岗位。</p>
<p>分为五级：正高级工程师，高级工程师（副高），工程师，助理工程师，技术员。</p>
<h2 id="三：研究类"><a href="#三：研究类" class="headerlink" title="三：研究类"></a>三：研究类</h2><p>一般是研究单位研究院等科研机构职称。</p>
<p>分为四级：研究员，副研究员，助理研究员，实习研究员。</p>
<h2 id="四：三类系列一般对比对应如下："><a href="#四：三类系列一般对比对应如下：" class="headerlink" title="四：三类系列一般对比对应如下："></a>四：三类系列一般对比对应如下：</h2><table>
<thead>
<tr>
<th>等级</th>
<th>教育类</th>
<th>工程技术类</th>
<th>研究类</th>
<th>简称</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>教授</td>
<td>正高级工程师</td>
<td>研究员</td>
<td>正高</td>
</tr>
<tr>
<td>2</td>
<td>副教授</td>
<td>高级工程师（副高）</td>
<td>副研究员</td>
<td>副高</td>
</tr>
<tr>
<td>3</td>
<td>讲师</td>
<td>工程师</td>
<td>助理研究员</td>
<td>中级</td>
</tr>
<tr>
<td>4</td>
<td>助教</td>
<td>助理工程师</td>
<td>实习研究员</td>
<td>初级</td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>技术员</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>各系列职称体系对比</p>
]]></content>
      <categories>
        <category>摘抄</category>
      </categories>
      <tags>
        <tag>职称对比</tag>
      </tags>
  </entry>
  <entry>
    <title>数学插值与三次样条曲线</title>
    <url>/2023/11/18/%E6%95%B0%E5%AD%A6%E6%8F%92%E5%80%BC%E4%B8%8E%E4%B8%89%E6%AC%A1%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF/</url>
    <content><![CDATA[<p>本文介绍了样条曲线的原理，以及如何计算三次样条曲线。</p>
<span id="more"></span>

<h2 id="一、从插值问题说起"><a href="#一、从插值问题说起" class="headerlink" title="一、从插值问题说起"></a>一、从插值问题说起</h2><p>样条函数是一种用于多项式插值的分段函数。</p>
<p>先来解释一下什么是多项式插值。在科学实践中，我们经常会遇到这种情况：采集到了多个样本点，然后对这些样本点进行处理，用一个函数代表这些样本点的特征。一般我们有两种策略去提取这些样本点的特征：（1）拟合（2）插值。拟合不要求方程通过所有的已知点，讲究神似，就是整体趋势一致。插值则是形似，每个已知点都必会穿过，但是高阶会出现龙格现象(Runge Phenomenon) ，所以一般采用分段插值。而样条曲线，特别是分段三次样条曲线，就是一种很常用的插值方法。</p>
<blockquote>
<p>龙格现象(Runge Phenomenon) ：对于某些函数，使用均匀节点构造高次多项式差值时，在插值区间的边缘的误差可能很大的现象。如下图所示，蓝线为样本点的真实方程（ $y=1/(1-25\times x^2)$ ，红线为高阶函数插值结果，可以看出其与实际方程差别很大 ）</p>
</blockquote>
<p><img src="https://pic.imgdb.cn/item/6558e4ebc458853aef156483.jpg" alt="龙格现象"></p>
<p>高阶函数插值会出现上述问题，那么另一种方法就是分段函数插值了。最简单的分段函数就是直接用线段连接各个点，但那样得到的曲线并不平滑，各段函数之间有很大的转折。另一种策略就是用曲线进行插值，这就是所谓的样条曲线。</p>
<blockquote>
<p>样条曲线（spline）这个词来源于一种在工程制图时用来画出光滑形状的工具，这种工具一般为富有弹性的细木条或薄钢条。由这样的样条形成的曲线在连接点处具有连续的坡度与曲率。</p>
</blockquote>
<h2 id="二、三次样条（cubic-spline）曲线"><a href="#二、三次样条（cubic-spline）曲线" class="headerlink" title="二、三次样条（cubic spline）曲线"></a>二、三次样条（cubic spline）曲线</h2><p>如前文所述，要想平滑插值，我们可以在每一段区间使用曲线。例如，我们可以在各段曲线的交界处令插值方程 $S(x)$ 连续，插值方程的一次导函数 $S’(x)$ 连续，二次导 $S’’(x)$ 也连续，从而获得平滑的插值曲线。由此，在每个小区间上，插值函数都是一个三次方程，这就是三次样条曲线函数的由来。</p>
<p>三次样条函数的计算方法如下：</p>
<p>给定区间 $[x_0,x_n]$ 以及属于这一区间的 $n-1$ 个样本点 $x_1,x_2,…,x_{n-1}$ ，我们可以以这些样本点为界将整个区间分为 $n$ 个小段 $[(x_0,x_1),(x_1,x_2),…,(x_{n-1},x_n)]$ 。在这些小段上，三次样条函数满足以下条件：</p>
<ul>
<li>对于 $\forall i \in [0,n)$ ，在区间 $[x_i,x_{i+1}]$ 上， $S(x)=S_i(x)$ 都是一个三次方程</li>
<li>满足插值条件 $S(x_i)=y_i\ (i=0,1,…,n)$</li>
<li>曲线光滑，即 $S(x),S’(x),S’’(x)$ 连续</li>
</ul>
<p>则这个三次方程 $S_i(x)$ 可以构造为以下形式：</p>
<p>$$<br>y=a_i+b_ix+c_ix^2+d_ix^3<br>$$</p>
<p>在每个小区间 $[x_i,x_{i+1}]$ 上，要求的未知数个数有四个（ $a_i,b_i,c_i,d_i$ ）。有 $n$ 个小区间，因此未知数总数为 $4n$ 。我们需要 $4n$ 个方程求解这些未知数。</p>
<p>幸运的是，根据三次样条函数需要满足的条件，我们可以得到 $4n-2$个方程，其中插值方程 $S(x)$ 连续这一条件可以构造出 $2n$ 个方程，插值方程的一次导函数 $S’(x)$ 连续和二次导函数 $S’’(x)$ 连续各可以构造出 $n-1$ 个方程。还缺少两个方程就可以解出所有未知数，这两个方程由边界条件获得。</p>
<p>对于三次样条函数来说，边界条件有三种：</p>
<ul>
<li><p>自然边界 ( Natural Spline )：指定端点二阶导数为0， $S’’(x_0)=S’’(x_n)=0$ </p>
</li>
<li><p>固定边界 ( Clamped Spline ): 指定端点一阶导数的值为固定值。</p>
</li>
<li><p>非扭结边界( Not-A-Knot Spline ): 强制第一个插值点的三阶导数值等于第二个点的三阶导数值，最后第一个点的三阶导数值等于倒数第二个点的三阶导数值。</p>
</li>
</ul>
<p>三种边界条件的区别如下图所示。可以看出，自然边界和非扭结边界看起来更自然一点。</p>
<p><img src="https://pic.imgdb.cn/item/6558ed9ec458853aef3c5f88.jpg" alt="边界条件"></p>
<p>如此，我们得到了 $4n$ 个方程组，可以解对应的 $4n$ 个方程系数。具体推导略，主要涉及多元一次函数的解法，或者参考文章：<a href="https://zhuanlan.zhihu.com/p/62860859">《三次样条（cubic spline）插值》</a>。总之在确定方程以后，主要工作就是解方程组。</p>
<h2 id="三、代码方法求解三次样条曲线"><a href="#三、代码方法求解三次样条曲线" class="headerlink" title="三、代码方法求解三次样条曲线"></a>三、代码方法求解三次样条曲线</h2><p><code>scipy</code>库是一个强大的科学计算函数库，其中提供了<code>interpolate</code>模块，实现了多种插值方法。其中，<code>scipy.interpolate.CubicSpline</code>是三次样条插值的官方实现。我们可以使用这一模块来实现插值程序。</p>
<p>下面的程序将接收两个数组作为输入，一个代表样本点的x坐标，另一个代表y坐标，返回一个代表样条曲线系数的矩阵。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.interpolate <span class="keyword">import</span> CubicSpline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 测试数据</span></span><br><span class="line">x = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">y = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 三次样条函数插值</span></span><br><span class="line">cs = CubicSpline(x, y)</span><br><span class="line">xs = np.arange(<span class="number">0</span>,<span class="number">5</span>,<span class="number">0.001</span>)</span><br><span class="line"><span class="comment"># 绘制图形</span></span><br><span class="line">plt.plot(xs, cs(xs))</span><br><span class="line">plt.scatter(x,y)</span><br><span class="line"><span class="comment"># 获取样条函数的系数</span></span><br><span class="line"><span class="built_in">print</span>(cs.c)</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.imgdb.cn/item/6558f4d8c458853aef589055.jpg" alt="插值结果"></p>
<p>样条函数的系数矩阵：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[[ 0.28888889  0.28888889  0.55555556 -0.51111111 -0.51111111]</span><br><span class="line"> [-1.86666667 -1.         -0.13333333  1.53333333  0.        ]</span><br><span class="line"> [ 2.57777778 -0.28888889 -1.42222222 -0.02222222  1.51111111]</span><br><span class="line"> [ 0.          1.          0.         -1.          0.        ]]</span><br></pre></td></tr></table></figure>

<h2 id="四、其他样条曲线"><a href="#四、其他样条曲线" class="headerlink" title="四、其他样条曲线"></a>四、其他样条曲线</h2><p>上述方法为三次样条曲线的原理和计算方法。但样条曲线的家族成员还有很多，例如smooth P-spline、bivariate P-spline等。这些样条曲线的计算原理大同小异，并且在不同的领域有重要作用，例如三次样条插值主要用于生成平滑曲线，而平滑P样条和二元P样条更多用于统计建模和分析。</p>
<ol>
<li>B-spline（基础样条函数）：B-spline是样条函数中最基础且最常用的一种，它是通过一组控制点来定义的，并且具有局部支撑性，即改变一个控制点只会影响到该点附近的曲线形状。B-spline曲线在每个区间内部是多项式函数，通常是三次多项式。本文前述的三次样条曲线即属于这一类函数。</li>
<li>P-spline（惩罚样条函数）：P-spline是”Penalized Spline”的简称，它是一种通过添加惩罚项来增强样条函数光滑性的方法。在P-spline中，我们不仅要求样条函数通过所有的数据点，而且要求样条函数的曲率（二阶导数）尽可能小，以此来增加曲线的光滑性。这个要求是通过在目标函数中添加一个惩罚项来实现的。它的优点是可以自动选择平滑参数，而且计算速度较快。它的缺点是可能对数据的噪声敏感，而且不能很好地处理不规则的网格数据</li>
<li>S-spline（光滑样条函数）：S-spline是”Smoothing Spline”的简称。与P-spline类似，S-spline也是通过最小化一个包含惩罚项的目标函数来求解样条函数的。不过，S-spline通常用于非参数回归中，它的目标是找到一个函数，该函数在拟合数据的同时，也使得函数本身的粗糙度（即曲线的弯曲程度）最小。</li>
</ol>
<p>总的来说，这三种样条函数的主要区别在于如何权衡拟合精度和光滑性。B-spline是最基础的样条函数，它不包含任何惩罚项，因此它的形状完全取决于控制点。P-spline和S-spline则通过添加惩罚项来增加 光滑性，但它们的目标函数和求解方法略有不同。</p>
<blockquote>
<p>参考：</p>
<ul>
<li>龙格现象(Runge Phenomenon) - sslchi的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/138747068">https://zhuanlan.zhihu.com/p/138747068</a></li>
<li>三次样条（cubic spline）插值 - 阿贵的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/62860859">https://zhuanlan.zhihu.com/p/62860859</a></li>
<li>样条函数 - 百度百科 <a href="https://baike.baidu.com/item/%E6%A0%B7%E6%9D%A1%E5%87%BD%E6%95%B0/5863303">https://baike.baidu.com/item/%E6%A0%B7%E6%9D%A1%E5%87%BD%E6%95%B0/5863303</a></li>
<li>从零开始几何处理：函数拟合 - 启思的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/412459069">https://zhuanlan.zhihu.com/p/412459069</a><br>拓展阅读：</li>
<li>R smooth.spline 拟合平滑样条曲线 <a href="https://vimsky.com/examples/usage/r-stats-smooth.spline-eh.html">https://vimsky.com/examples/usage/r-stats-smooth.spline-eh.html</a></li>
<li>B样条算法(B-spline) - 矢月的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/260724041">https://zhuanlan.zhihu.com/p/260724041</a></li>
<li>从零开始几何处理：RBF函数 - 启思的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/413596878">https://zhuanlan.zhihu.com/p/413596878</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>插值</tag>
        <tag>样条曲线</tag>
        <tag>龙格现象</tag>
        <tag>scipy</tag>
      </tags>
  </entry>
  <entry>
    <title>无题</title>
    <url>/2022/11/04/%E6%97%A0%E9%A2%98/</url>
    <content><![CDATA[<p>晚上好啊，朋友。</p>
<span id="more"></span>

<p>又一次这么晚了才开始写日记。今天晚上睡不着，总是想心事，辗转反侧许久，最后决定写下来。</p>
<p>有多久没和人有过正儿八经的聊天了呢？又有多久，没有和人认真谈论过过人生了呢？</p>
<p>晚上和室友讨论到社交和恋爱的话题，再一次被伤到了。室友是有对象的。他以为我是母单，却没有想到我曾经谈过恋爱——对，去年那三个月勉强算是恋爱的感情经历。室友还说你打算什么时候谈，你得走出去，得多创造机会，得让女生对你感兴趣，如此种种。</p>
<p>其实有点沮丧。沮丧的是很多问题没有答案。例如室友强调了创造和其他人认识的机会最重要，我说我也在尽可能的走出去，尽可能的积极地参与社交活动，积极地创造机会了啊，室友又说你得提高自己的吸引力，不然就算加上了好友也是白搭。</p>
<p>其实很多浅显的道理不用他说我也看得明白。机会确实很重要，不然连认识足够多的人都做不到，从何谈起交朋友甚至找对象呢？可是，谈恋爱也得靠吸引，不然人家凭啥和你交往？</p>
<p>但是光明白这些道理管啥用。没有方法论的指导，一切都是白搭。光知道要创造机会，要提高吸引力，可怎么tmd创造机会，怎么tmd提高吸引力？</p>
<p>讲道理，我一直都觉得自己社交能力存在问题。在北京实习的一年多的快乐经历算是意外，碰巧和一群很social的人遇到了一起，碰巧这群非常social的小伙伴对我也很包容，这让我产生了一种错觉，一种以为自己变得不那么社恐的错觉。但是到了新环境，没有social的人找你交朋友，才发现，原来最不会社交的人竟是我自己。</p>
<p>更加令我受挫的一点是，我并不知道如何提高社交能力。yxy确实教了我很多，但她那些东西远不能总结为一套成熟的方法论体系。此外，我渐渐意识到，正确解读聊天中的非语言信息和各种隐喻暗示是正常社交的基础（我想我应该是错过了不少暗示，不然也不至于像今天这样）。室友说我很直，我能感觉到言下之意可能是说我不太会考虑他人的感受（所谓共情能力很糟糕？）。可是，我也想有很好的共情能力啊😭而且我特别希望拥有看穿别人内心想法的能力😭如果我的想法常常被人看穿，而我却看穿不了其他人的思想，这本身就是一种不公平。</p>
<p>纠结于这些问题，以致辗转反侧，竟难以入眠。作为非典型小镇做题家的一员，遇到不会的问题总想要想明白，可是人际交往的问题我怎么想都想不明白。谁来告诉我正确答案？</p>
<p>也可能这些问题并没有答案。擅长social的人可以在同学们中混得风生水起，不擅长social的人如果专攻某一行也可以得到人们的尊敬。就怕啥都不行还想摆烂，最后输的一定是你。</p>
<p>以上。共勉。</p>
<p>11月4日夜。</p>
<hr>
<hr>
<blockquote>
<p>旧评论系统备份：</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">痴情的妖怪(2022-11-05 05:17:11):</span><br><span class="line">	我从入学到现在，年级里除了室友没有认识新的人，校园里能互相叫出名字的只有一个社团的两个负责人。</span><br><span class="line">	此外是实验室的10个师兄师姐，还有2个轮转导师。我觉得这种感觉很不错，甚至已经在尽量避免跟一个新的人产生足够见面需要打招呼的交集了。</span><br><span class="line">	我现在希望，除了必须产生交集的人之外没有任何社交，因为工作交集的人尽量不引入私人情感，越来越觉得这种淹没在人海里的感觉很爽</span><br><span class="line"></span><br><span class="line">&gt; WarrenZhang(2022-11-06 01:20:12):</span><br><span class="line">&gt;	那么樊总的意思是不是说，要尽可能地避免无用社交呢？</span><br><span class="line">&gt;	其实感觉樊总说得很有道理，但是如果放在我身上，我可能会觉得这样做对自己和对身边的同学都太残忍了，有些不近人情。</span><br><span class="line">&gt;	可能我的修为还没有樊总深吧。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 痴情的妖怪(2022-11-06 03:32:44):</span><br><span class="line">&gt;	皖总言重了，我不是说要不近人情啊，只是想表达我不想认识新的人了，不认识自然不会让人家觉得不近人情嘛。</span><br><span class="line">&gt;	毕竟每个阶段，我们都有必须要共事的人，不会因为缺少交流而抑郁的。如果想去认识人就去嘛嘿嘿😬。</span><br><span class="line">&gt;	我是觉得已经有许多像皖总这样的朋友了，与其认识新的人，不如就像我们现在这样，偶尔相互打探，有种君子之交淡如水的感觉。</span><br><span class="line">&gt;	其他形形色色的“朋友”，绝大多数是阶段性的热情，永久性冷漠，本科这样的“朋友”大概有上百位，里面不乏一起吃过饭现在我却名字都记不住的人，倦了倦了，诶😩。</span><br><span class="line">&gt;	而且认识的人越多，总会有社交压力来占用精力。也许我只是想完完全全颠覆一下生活状态吧</span><br><span class="line"></span><br><span class="line">Hazel(2022-11-06 10:18:35):</span><br><span class="line">	其实我有点赞同樊总的观点。但另一方面要考虑的是，樊总已经足够强了，他不是特别需要外界的帮助，只要从自己的角度来精进自己。</span><br><span class="line">	但是我现在自己本身就菜得要命，如果不去认识更多的人，去了解别人从别人身上吸收进步，自己就闭关锁国了。</span><br><span class="line">	所以我的观点是，可以去交朋友，尽可能认识更多的朋友，但是把每个朋友的作用单一化（听起来有点精致利己😂）</span><br><span class="line">	比如说我喜欢羽毛球，就去球场上交朋友，和这些朋友只谈球。这样如果你无法收获一份友谊，至少能收获一点技能；并且从球到人，如果话很投机，还可以继续拓展；</span><br><span class="line">	和同学我特别喜欢讨论课堂问题，因为和这些人聊起来，不需要介绍那么多的背景知识，我也懒得管别人怎么看我，得到答案要紧；</span><br><span class="line">	但是我好像对强制性分配认识的人不太感冒，比如说舍友、班级的同学等。</span><br><span class="line">	我们是因为部分相似的特质走到一起的，但是我个人好像并不是特别看重这些特质（比如性别、专业啊），那么我就泛泛而交了，有时候确实会因为没有认真交往而错过一些人觉得可惜，</span><br><span class="line">	但是，如果从一种更宏大的角度去想，这些似乎都是注定的，错过就是错过，我错过了班级里很好的同学，但会在球场上认识一个很好的朋友。</span><br><span class="line">	因为我的恋爱意愿并不是特别强烈，所以你提到的如何提高自我形象，我只能说顺着自己的心来。</span><br><span class="line">	每个人都有自己的风格，如果为了吸引别人改变自己的风格，到头来你要别人如何面对真实的你呢？她喜欢的是表面的你还是真实的你？如果只是那个修饰之后的你，那爱的人就不再是你了。</span><br><span class="line">	我有时候觉得硬着头皮认识新的人会很怪，别人有时候也会觉得我奇奇怪怪，但我想的是，这就是现阶段的我，你可以和将来的我、过去的我成为朋友，但如果不是现在的我，那么我们现在没有成为朋友也没什么可惜的。</span><br><span class="line">	所有事情讲究的缘分大概可以这样解释😂。（是的，我也在一边社恐一边交友）</span><br><span class="line">	如果没想到什么好办法，真诚就是最好的方式，我现在和别人说话越来越喜欢直接了，觉得不明白就问好了，“你是不是还暗指什么”，如果别人否定，那就是没什么了。</span><br><span class="line">	与其花很多心思揣测别人怎么思考自己，不如把精力放到如何成为一个能够取悦自己的人，让自己一个人做事情也能快快乐乐的。最后达到一种“谈不谈都无所谓”的状态就好啦！</span><br><span class="line">	最后，送一句话（哈哈哈哈，就是你的blog随机展示的话：</span><br><span class="line">	爱欲于人，犹如执炬，逆风而行，必有烧手之患。</span><br><span class="line">	《四十二章经》</span><br><span class="line"></span><br><span class="line">Hazel(2022-11-06 10:37:36):</span><br><span class="line">	其实直就直呗，不共情就不共情呗。</span><br><span class="line">	现在越来越少有人愿意共情了，咱不是说一定要追逐什么流行趋势。我只是觉得不共情不代表你不理解别人的感性，不代表你是一个冷冰冰的机器人。这就够了，天天共情别人得累死，也没有那么多值得你共情的人。</span><br><span class="line">	不打扮就不打扮呗，因为你没有打扮的需求和意愿呗。</span><br><span class="line">	为啥吸引别人就一定得好看呢？咱能力突出难道就吸引不了谁了吗？有得必有失，你花时间交友搞自我形象，用的又是什么时间呢？失去的又是自己的什么能力呢？</span><br><span class="line">	我认真打扮穿衣服（似乎我在女生群体中都不能算作打扮）时也只是因为我想穿，我觉得自己有点邋遢要换一换。</span><br><span class="line">	别人的想法有个屁用啊，是他给你买衣服还是给你钱还是给你课题还是给你发文章还是给你高分啊？有道理就听听，无所谓就当背景噪音了。</span><br><span class="line">	再说，谈恋爱就快乐幸福了吗？也未必吧，单身多爽！我感觉自己现在才算是心智开启，终于脱离父母思维的束缚，开始有了自己的思考和生活，我一点都不想让别人挤占我的时间，浪费我的精力，对我指指点点。</span><br><span class="line">	我现在想把生活的中心全都放在自己这，全方面看看自己，搞清楚自己。如果这时候谈恋爱大概也是不成熟的，虽然恋爱分手也无所谓，但要是没什么收获就很可惜。（哈哈哈哈，太自私了，还是别谈了）</span><br><span class="line">	所以，别把单身当作一回事，当成一种选择呀，是我们选择单身，而不是单身选择我们。</span><br><span class="line"></span><br><span class="line">&gt; WarrenZhang(2022-11-07 01:05:46):</span><br><span class="line">&gt;	谢谢桢总，感觉你说的这些很有道理。</span><br><span class="line">&gt;	可能我们活着并不需要在乎太多其他人的眼光，我们只需要做好我们自己，做到问心无愧，就行了。至于直不直会不会共情外表漂不漂亮擅不擅长社交，这些并不那么重要。</span><br><span class="line">&gt;	另外，关于恋爱，其实最近我也有了些思考。桢总的爱情观好豁达，我好佩服。不过我可能因为成长的过程中比较缺爱吧，很长一段时间我在期待恋爱，期待通过恋爱把成长中缺失的这一部分爱补回来。</span><br><span class="line">&gt;	不过现在我也想开了，真正的恋爱应该是两个人相互付出的，不然就变成一方对另一方的扶贫了，因此我现在的状态也不适合谈恋爱。</span><br><span class="line">&gt;	现在能做的，是努力提升自己，自己爱自己，等到内心足够强大，足够向别人释放善意和关爱时，再去选择要不要开启一段感情也不迟。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 痴情的妖怪(2022-11-07 05:03:40):</span><br><span class="line">&gt; 	别别别，我甚至没有念过分子生物学，垃圾中的垃圾，没人愿意和我社交😭</span><br><span class="line">&gt;</span><br><span class="line">&gt; Hazel(2022-11-07 10:10:51):</span><br><span class="line">&gt;	其实别人的眼光还是要重视的。但是并不是人人的眼光都需要重视。</span><br><span class="line">&gt;	我现在处于一个新环境，没几个人对我有什么深入了解，所以我不在意他们的目光；但是老朋友的眼光我还是很重视的，我导师、我的师兄师姐的建议我也会考虑的。</span><br><span class="line">&gt;	因为这些人更了解我，同时我也相信我们都是希望对方越来越好的，我觉得你需要在意这些人的想法，并且认真考虑，反驳（如果站得住脚，肯定就行）。</span><br><span class="line">&gt;	（所以这就是为什么当我以为的朋友做出一些超乎我认知的行为时，我会觉得难过甚至把原因都归到自己身上，但是现在已经不太这么想了）</span><br><span class="line">&gt;	关于缺爱，我想</span><br><span class="line">&gt;	每个人的成长过程都不会是完美的，缺失了就是缺失了，没办法弥补的。但是我们不要总是关注于缺失那一部分给你带来了什么损失，你也要想到它给你带来什么好处。</span><br><span class="line">&gt;	没准缺爱的成长让我们更加独立、让我们在面对具有类似处境的人有同理心，让我们将更多的希望寄予自己而不是总想着依赖他人，或许正是这样的成长让我们时刻警觉，保持进步，最终见到更大的世界遇见更好的人。</span><br><span class="line">&gt;	也让我们将别人的善意不是当作理所当然，而是感激、并珍惜这样的真情实意；让我们不会轻易错过以后人生中向我们释放善意的人，并和他们成为朋友互相鼓励。</span><br><span class="line">&gt;	我听到一句话，“其实在你来到人间之前，你就在天上选好了你这一生的剧本。你之所以有这样的过去，一定是因为这个剧本有某些独特的、触动你的地方。”</span><br><span class="line">&gt;	希望我们共勉，现在我们大概都不够好，也有许多让人难过的过去，但是我相信我之所以拥有那些让人难过、觉得困难的时光，一定是因为，在将来，会有我期待的东西，极其期待，以至于这个剧本的前半部分再糟糕我都不愿意放弃的东西。</span><br><span class="line">&gt;</span><br><span class="line">&gt; Hazel(2022-11-07 10:29:40):</span><br><span class="line">&gt;	我说的是，樊总目标已经足够清晰了。你已经知道自己的目标是什么，自己目前的问题是什么，你也知道该怎么做去解决。并且你也很坚定，很相信可以通过自己的这种思路去达到自己的目标，这就很了不起了。</span><br><span class="line">&gt;	有时候我给自己设定目标常常放弃，一个是因为有时候还承担不起这个责任，总是想要逃避，说白了就是不够信任自己，总是想相信别人。😂所以我真的很佩服那些相信自己的判断，并且坚定不移去实现它的人。</span><br><span class="line">&gt;</span><br><span class="line">&gt; Hazel(2022-11-07 10:34:51):</span><br><span class="line">&gt;	我感觉这都要成我们三个人的私人论坛了😂（因为好像也只有我们几个还在看）</span><br><span class="line">&gt;</span><br><span class="line">&gt; WarrenZhang(2022-11-07 23:00:13):</span><br><span class="line">&gt;	这不也挺好的嘛（手动狗头）</span><br><span class="line"></span><br><span class="line">Chuanbo(2022-11-13 23:43:52):</span><br><span class="line">	此时一位不知名路人路过——（发现除了自己都相互是熟人的感觉诶）</span><br><span class="line">	我想说的是想要有一些改变自然是好事，但是也不用勉强自己，每个人有每个人与别人交流的节奏，有很多东西都是语言上面很难表述和传达的东西。比如所谓的机会和吸引力。我觉的博主能写出这样的博客来能说明平常生活中博主的思想生活已经很丰富了，只是可能并没有被那么多人看到。人际交往讲究的是双方的节奏，如果对方节奏和你对上了，正好多了解了你的更多，那么说不定关系就会延续下去，但是即使节奏对不上也不必勉强和失望，因为这是每个人的特性。我们需要做的就是着眼于自己，把自己变得有趣，变得丰富，这样在遇到别人的时候我们有更大的几率会让别人对你感觉到兴趣。别人不可控，所以不要有压力。</span><br><span class="line"></span><br><span class="line">&gt; WarrenZhang(2022-12-04 01:18:21):</span><br><span class="line">&gt;	抱歉博客久未更新，刚刚才看到您的留言。说实话，在生活中我挺没有存在感的，而且思想生活也不是很丰富，倒是成天瞎想一些东西。因此，您说着眼于自己，把自己变得有趣，变得丰富，这一点我非常认同。不管怎么说，我都很感谢您的留言，并感到惊喜。谢谢！</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>杂思</category>
      </categories>
  </entry>
  <entry>
    <title>无题之二</title>
    <url>/2023/11/24/%E6%97%A0%E9%A2%98%E4%B9%8B%E4%BA%8C/</url>
    <content><![CDATA[<blockquote>
<p>一篇没有标题的日记</p>
</blockquote>
<span id="more"></span>

<p>今年的冬天会是个暖冬——如果还没有经历傍晚气温的骤降，我可能会如此坚信。连续一个星期的晴天，使得江南大地气温有所回升。暮秋的天空是蓝色的，天气很晴很好，阳光从树叶的缝隙里穿过，斜斜地洒在地上，很明亮，却不怎么晒人。然而今天傍晚，阵风忽起，气温骤降，终于有了初冬的感觉。</p>
<p>连续两周的闲暇无事，使我有时间去整理大学期间的日记，顺便也重温了考研那个学期的心路历程。那时的压力确实很大，但始终没有放弃，在心态接连崩溃的情况下依然坚持到了交卷前的最后一秒。回看那些日记时，在图书馆备战考研的生活依然历历在目。相比之下，最近这段时间确实懈怠了很多，突然有点自愧不如。</p>
<p>学习的重要性高过所有——这句高考誓词在曾经的学生时代经常被提起。也许这句话到现在依然成立，但我好像经常忽视了这一点，纵容自己沉迷在无休止的娱乐中无法自拔。也许现在回过头已经迟了；也许，还不算太迟——谁知道呢？</p>
<p>是什么时候开始认为学习不再重要？也许从某个时候，从我开始固执的相信，自己在人际交往方面有问题、人际交往的重要性高过所有的时候——从那时开始，学习在我心中的重要地位就在渐渐降低。我开始怀疑，努力学习究竟是为了什么，付出了很多究竟能不能换回我们想要的东西。既然努力学习做一个好孩子，并不能挽回我们失去的友情，那么还要好好学习做什么？为什么不直接从人际关系下手，直接去追求我们想要的那种人与人之间的联系呢？</p>
<p>至少大一的那个寒假中，我是这么想的。在和高中时的好友彻底闹掰、再也回不去以后，一切就变了。我开始学着打游戏，开始无休止的刷知乎、刷b站，期望通过观察和模仿网络上其他人的生活来提高自己的社交能力。也许这么做使我的社交能力确实有提升吧，但在另外的方面，我也失去了许多。</p>
<p>我是一个有点分离焦虑的人——在看过一些心理学公众号推送后，我想得出这样一个结论。至少对于那些我所在意的人，我很害怕失去。这样的心理有时却可能起到反作用，当我处在一段关系（友情或恋情）中时，在一次又一次对关系的确认和对自己可能会被抛弃的怀疑中，将我们所在意的人越推越远。</p>
<p>所以自始至终，我是孤独的。因为孤独而渴望有人和自己分享生活的乐趣，渴望有人参与我的生活、为我的生活带来光明，却始终不知道这样的人应该去哪里找寻。当终于有机会恋爱时，我可能将自己的这种孤独感和需求感投射在别人身上，这无助于关系的稳定。</p>
<p>来到上海生科院以后，我对人际交往产生了很大的焦虑，并认为现阶段维持人际关系是一项极其重要的工作。也许现在该转变思路了。人际关系固然重要，但是一来我的社交技能确实很糟糕，二来提高社交技能依旧无方。因此，不如专注于自己的事业。</p>
<p>然而依然会有孤独寂寞的时候，会有需要安慰需要社交的时候。这些时候又该怎么度过呢😭或许除了慢慢熬过去也没有别的方法了吧。</p>
<p>这种状态下，倒是不可能也不应该谈恋爱了。毕竟这些需求其实挺消耗另一个人的精力的。也许，只能靠自医。（虽然对恋爱依然会有所期待；现在我对恋爱的认识倒是有些变化，也许在恋爱中还得想方设法换位思考、在意对方的感受，向别人展示自己的吸引力和爱意，而不是通过恋爱索取对方的爱。后者不可能长久）</p>
<p>但是，今天的阳光确实很好看。</p>
<p>以上。</p>
<hr>
<p>附：今天白天的阳光：</p>
<p><img src="https://pic.imgdb.cn/item/656211b7c458853aeff86b83.jpg" alt="sunlight1"></p>
<p>以及，华为日历昨天推送的小雪节气背景图：</p>
<p>（江南的冬天似乎不太会下雪。突然很怀念北方的雪天。）</p>
<p><img src="https://pic.imgdb.cn/item/6562122ec458853aeffa9395.png" alt="小雪"></p>
]]></content>
      <categories>
        <category>杂思</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】日本年轻人不爱不婚不生子，是为了“体面”？</title>
    <url>/2023/11/19/%E6%97%A5%E6%9C%AC%E5%B9%B4%E8%BD%BB%E4%BA%BA%E4%B8%8D%E7%88%B1%E4%B8%8D%E5%A9%9A%E4%B8%8D%E7%94%9F%E5%AD%90%E6%98%AF%E4%B8%BA%E4%BA%86%E4%BD%93%E9%9D%A2/</url>
    <content><![CDATA[<ul>
<li>有四分之一的年轻人对未来感到不安，是日本少子化的主要原因。要采取让年轻人不会对未来过不上富裕生活而感到不安的措施。</li>
<li>在东亚社会里，让子女接受比自己更好的教育，找到比自己更好的工作，是父母的生活意义所在。</li>
<li>如果现实恋爱的满足度下降了，那虚拟恋爱的价值就会上升。也许现在已经不能说现实中的满足就更优越了。</li>
</ul>
<blockquote>
<p>本文转载自南方周末公众号，发表日期为2023年11月17日</p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>文｜南方周末记者 潘轩 南方周末实习生 温若梅</p>
<p>责任编辑｜李慕琰</p>
</blockquote>
<p><img src="https://pic.imgdb.cn/item/6559f1d0c458853aeff6c6a4.jpg" alt="山田昌弘"></p>
<p>▲ 日本社会学家山田昌弘，中央大学教授，专攻家庭社会学和情感社会学等，著有《少子社会》《“婚活”时代》《低生育陷阱》等。（受访者供图 / 图）</p>
<p>全文共7750字，阅读大约需要18分钟</p>
<hr>
<p>日本中央大学教授山田昌弘长年深耕家庭社会学领域。高中之前，他一度想做数学家，但“因为我自己没有家庭，所以我决定探索什么是亲情”，自此步入“研究凌乱家庭的世界”。</p>
<p>在学校教书时，他利用大量关于家庭的素材，讲述现代日本家庭的起源、现状和去向。他和学生一起召开的研讨会，话题前沿，探讨的问题包括：人孤独到何种地步需要“出租朋友”？“同居伴侣婚姻”（注：只同居不结婚）是否探究了现行婚姻制度之外的另一种可能性？日本单身的年轻人越来越多，他们的亲密情感需求在何处得到满足？他最终在歌舞俱乐部（注：提供歌唱和跳舞表演的场所）、真人或虚拟偶像、宠物身上找到一些答案。</p>
<p>在《低生育陷阱》一书里，山田昌弘试图解答一个问题：近些年，日本年轻人为何不愿意生孩子了？</p>
<p>一直以来，低生育率是盘桓于日本社会之上的一朵阴云。自1989年起，日本的生育率持续低迷，总和生育率低于1.6的情形维持了三十余年，2022年更是达到了1.26的历史低值。</p>
<p>过去三十多年，日本社会力图解决这一“顽疾”，但收效甚微。山田昌弘曾任少子化对策委员。有一次，一位委员提议要举办一场“育儿很精彩”的宣传活动，提升大众的生育积极性。“日本社会的很多有识之士和政策负责人在很长时间内都忽视了与日本少子化原因直接相关的两个重要因素，即‘不婚化’和‘年轻人经济水平差距的扩大’。”山田认为，“对于‘想生但因条件尚不具备，所以不生孩子’的多数人来说，开展这类宣传活动毫无意义。”</p>
<p>在山田昌弘看来，年轻人的生育意愿和社会整体的经济状况挂钩。</p>
<p>1955年，日本经济进入高速成长期，繁荣的经济环境催生出年轻人对未来的积极预期，他们倾向于相信，通过个人努力能够跻身“中流阶层”，过上比父辈更好、更富裕的生活。“自第二次世界大战至1980年左右，人们没想过结婚后的经济生活会出现很大的风险，那时候的男性可以指望成为正式员工后，收入根据‘年功序列制度’（注：工资随年龄和工龄的增长而增加）得到提高。”在山田昌弘看来，那一代人笃信孩子会在优于自己的成长环境下长大。</p>
<p>而到了1980年代，情势发生了翻转。</p>
<p>“进入平成时代（注：1989年1月8日），日本经济结构调整，出现了大量的非正式雇佣人员（指有固定期限员工、兼职员工、派遣员工等），在就业方面产生了社会性差距，进而导致家庭贫富、子女教育环境产生差距，社会的两极分化进一步发展。”山田昌弘接受日本媒体采访时说，“对于大多数非正式雇佣人员而言，无论自身怎么努力，都无法获得能让自己将来过上富裕生活的收入，也没法结婚组建家庭。也就是说，自己的将来变得没有指望了。”</p>
<p>山田观察到，日本人更注重从经济角度看待婚姻的意义，作出结婚决定前，会作出慎重的风险评估。评估常从两个角度出发：一是相比婚前，婚后的生活水平会不会更好，或者至少不会更差；二是婚后能否为子女创造比自己更好的成长环境。</p>
<p>“这种婚育观背后体现的是现代日本社会特有的价值观：希望回避未来生活所面临的风险。日本人将维持中产生活水平作为最高目标，认为在人生设计上，‘男女交往’‘结婚’‘生子’‘育儿’和‘子女教育’这一连串问题不是单一、割裂的，而是环环相扣的。”山田昌弘在《少子化问题的东亚特征》这篇论文中写道。</p>
<p>这种风险意识也延伸至恋爱阶段。山田发现，在日本，不少年轻人甚至连恋爱的欲望都在减退。</p>
<p>NHK放送文化研究所曾经对日本的初高中生做过调查，发现“有喜欢对象的”初、高中生的比例，在1982年分别是41%和54%，而到了2012年，这个数据锐减到了25%和31%。2014年，日本内阁府曾对年轻人做过调查，发现超过三分之一的调查对象更愿意把时间花在工作和学习上，46.2%的人觉得“恋爱很麻烦”。在山田昌弘看来，“麻烦”的意思或许是“性价比不高”。</p>
<p>1990年代，少子化现象刚刚在日本社会出现时，人口学家们持有一种主流观点：年轻人只是为了享受单身生活而推迟结婚，总有一天他们会步入婚姻。山田昌弘认为，这样的逻辑基础未必成立。几十年来，随着日本社会逐步朝“高消费型社会”发展，育儿的焦虑和压力也向年轻人袭来。</p>
<p>2015年，日本国立社会保障及人口问题研究所曾做过一次调查，关于30-34岁年龄段的已婚女性为何没能拥有预期数量的孩子，81.1%的调查对象认为原因在于“孩子的养育及教育太花钱了”。</p>
<p>在山田看来，现代社会对婚育功能的预期已和前现代社会不同。在以农业生产为中心的社会，生育意味着劳动力的添补，父辈在子女身上寄托着继承家业、晚来照拂父母的期待，孩子是一种“生产性财产”。但是到了1950年代后，日本参考欧美的家庭制度，开始“核心家庭化”，一对夫妻和他们的未婚子女成为基本的家庭单元。在现代社会，养育孩子需要投入大量的育儿金，孩子因此成了“消费性财产”。</p>
<p>“孩子作为劳动力的意义不复存在，而且当核心家庭成为一种原则时，很难期待孩子在自己晚年时给予赡养和照顾。另外，可让孩子继承家业的父母也变少了。”山田昌弘在《低生育陷阱》中写道，不同于欧美父母享受育儿本身的愉悦和乐趣，很多时候，东亚父母在意的是是否拥有一个“高价值感”的孩子——在学历、工作等外在因素搭建起来的社会评价体系里，孩子能否占据鳌头。</p>
<p>山田认为，东亚父母对孩子常有“呵护之情”，不想让孩子“过得辛苦”，孩子在接受高等教育乃至成年后，得到父母的帮助，也是父母价值的一部分。因而，东亚父母对孩子的责任年龄无限延长。</p>
<p>2023年10月，日本社会学家山田昌弘接受了南方周末记者的书面专访。</p>
<h2 id="1-东亚父母认为给孩子花钱理所当然"><a href="#1-东亚父母认为给孩子花钱理所当然" class="headerlink" title="1. 东亚父母认为给孩子花钱理所当然"></a>1. 东亚父母认为给孩子花钱理所当然</h2><p><strong>南方周末：</strong> <em>中国的总和生育率在2022年跌至1.09，这个数值低于日本的1.26，高于韩国的0.78，2022年东亚三国的总和生育率下降至历史最低值。你在日本做了很多关于生育意愿的调研，为什么年轻人不愿意生孩子了？</em></p>
<p><strong>山田昌弘：</strong> 在东亚（中日韩），结婚和育儿首先会从经济角度进行考虑。人们在养育孩子时，会想把超出自己父母培养自己的钱花在自己的孩子身上。</p>
<p>以前（日本是50年前，中韩是30年前），大多数年轻人的父母的生活，以及年轻人自己的成长生活都处于相对贫穷的水平。又由于社会整体处于经济增长期，年轻人未来收入的增加是可以预期的。所以，在那个时候，把超出自己父母培养自己的钱花在自己的孩子身上会更容易，实际上也确实很容易。</p>
<p>但是，日本从30年前开始，中韩从10年前开始，上一世代被父母花了更多金钱养育的孩子，如今成了需要花钱养育自己孩子的人。这些年轻人，往往拥有比自己更富裕的父母。中国则由于独生子女多，这一代独生子女的花费估计会是日韩的两倍以上。</p>
<p>在经济增长趋缓的情况下，想要在未来出生的孩子身上花费更多的钱，是非常困难的。</p>
<p><strong>南方周末：</strong> <em>东亚社会家庭现代化的过程，是模仿学习欧美核心家庭的过程，同样的社会模型，为何东亚国家现阶段面对的生育困境比欧美社会更加剧烈？</em></p>
<p><strong>山田昌弘：</strong> 东亚国家模仿的只是核心家庭的模式，但因为不同的社会环境和传统，这些模式得到的反馈自然也不同。例如，东亚的父母更多地认为给孩子花钱是理所当然的，也能带来很多情绪价值；比起夫妻之爱，更相信亲子之爱。这也导致如果不打算生孩子的话，结婚的必要性就大幅下降了。</p>
<p>欧美认为养育孩子到成年为止，而东亚各国则认为负担孩子的高等教育费用是理所当然的。相比之下，东亚国家的父母要承担更多的育儿责任，甚至在孩子成年后，也经常需要帮助解决孩子遇到的各种问题。</p>
<p><strong>南方周末：</strong> <em>过去几年，中国政府出台了一些鼓励生育的政策，比如三孩政策、多地提出建立育儿补贴制度等。你在《低生育陷阱》里说，日本政府没能赶上干预低生育的最好时机，日本的少子化政策因此失败了。日本经验能给其他国家带来哪些教训和启示？</em></p>
<p><strong>山田昌弘：</strong> 必须考虑减轻孩子的教育费负担。有四分之一的年轻人对未来感到不安，是日本少子化的主要原因。要采取让年轻人不会对未来过不上富裕生活而感到不安的措施。</p>
<p>要将我们的社会改造成一个无论哪个年轻人都有希望将来能够不让自己的孩子受苦的社会。即，建立一个工作可以重新再来、对双职工家庭同样友好，以及万一出了问题也可以通过社会保障重新自立的社会。</p>
<p><strong>南方周末：</strong> <em>能否结合你自己和你的上一代、下一代的经历，谈谈日本年轻人婚育处境和观念的变化？</em></p>
<p><strong>山田昌弘：</strong> 观念本身并没有太大的变化。如果有过上相对好的生活的预期，那就自然会结婚生子。区别可能在于，上一代的人会认为，仅靠丈夫的收入就能过上富裕的生活（大概30年前）。即便在今天，那些能够达到预期的将近四分之三的年轻人也都已经结婚生子，而剩下四分之一的年轻人之所以不选择结婚生子，大多也是因为自身收入不稳定，以及无法预期在结婚生子后能过上相对好的生活。</p>
<h2 id="2-婚育事关体面？"><a href="#2-婚育事关体面？" class="headerlink" title="2. 婚育事关体面？"></a>2. 婚育事关体面？</h2><p><strong>南方周末：</strong> <em>你提出了一个观点：等待适合自己的对象出现然后结婚，这种从前被普遍接受的想法，如今很难把人领入婚姻。今天的年轻人如果想结婚，需要参加“婚活”（注：寻求结婚对象的各种活动，由山田昌弘首次提出），为何会有这样的变化？难道不参加婚活，就无法结婚了吗？</em></p>
<p><strong>山田昌弘：</strong> 因为让年轻人可以自然相互邂逅的场所变少了。不说男性，就连女性所谓的“即便自己不主动，男性也会主动搭讪”的状况都变少了。不得不由社区或者企业提供一些机会，让年轻男女可以有更多的接触。如果想要找到结婚对象，还是应该积极采取行动。</p>
<p><strong>南方周末：</strong> <em>“婚活”在中国叫做相亲。对于中国1970、1980年代出生的人来说，自由恋爱结婚在他们年轻时是普遍的婚恋观，但在如今的年轻人中，门当户对的观念正在被重提。日本社会是否有类似的婚姻观念变化？</em></p>
<p><strong>山田昌弘：</strong> 在日本，“先恋爱后结婚”的意识并没有改变。年轻人对恋爱结婚的憧憬和讨厌父母干涉自由恋爱的意识还是比较强烈的。</p>
<p>虽然没有那么在意对象的家庭背景，但婚后的经济生活，即婚后夫妻两人的整体家庭收入是很重要的参考因素。现在的年轻人“中流”意识十分强烈，他们大多觉得在父母身边时处于一种中流的生活状态，因而非常不希望婚后生活会从中流跌落，这也是习惯“规避风险”和“重视体面”的日本社会特征的反映。不过日本没有像中国那样，结婚时男方家庭需要出很多钱的习俗。</p>
<p><strong>南方周末：</strong> <em>你似乎非常强调在经济层面上分析婚姻、生育的动机。你提到，在欧美社会，人们将构建家庭（结婚、生子）与经济状况联系在一起的想法并不强烈，但在东亚社会不是，为何东亚社会如此强调这两者之间的关联性？</em></p>
<p><strong>山田昌弘：</strong> 东亚人更看重体面，也就是中文里的“面子”。人们不想让别人看到自己过着不幸福的婚姻生活，或有着较差的育儿水平。过着贫穷的生活会有很强的耻辱意识。</p>
<p>在欧美，夫妻之间的爱情才是幸福的表现，生活贫穷也可以幸福的意识很普及；而在东亚社会里，即使没有夫妻间的爱情，过着富裕的生活也可能是很幸福的，这种意识十分强烈。</p>
<p><strong>南方周末：</strong> <em>有一种观点认为，现代家庭“男主外，女主内”的分工意味着女性要为育儿付出更多的时间和精力，你怎样看待这个现实问题？日本社会对此有何对策？</em></p>
<p><strong>山田昌弘：</strong> 女性拥有一定的收入并持续工作，正在逐渐成为富裕家庭生活的前提。既然能够做到“男主外，女主内”的高收入男性人数有限，那么为了在富裕的生活条件下养育孩子，女性外出工作和男性参与家务就变得十分必要了。</p>
<p>在日本，通过普及产假和完善幼儿园的建设，这一理想正逐渐变得现实起来。不过日本政府对女性工作与育儿的“两立支援”也显然还远远不够，后续仍需要继续完善工作环境，消除性别歧视，并让更多的女性从事有意义的工作。</p>
<h2 id="3-培养“高价值”的孩子，一种扭曲的期待"><a href="#3-培养“高价值”的孩子，一种扭曲的期待" class="headerlink" title="3. 培养“高价值”的孩子，一种扭曲的期待"></a>3. 培养“高价值”的孩子，一种扭曲的期待</h2><p><strong>南方周末：</strong> <em>你提到，日本年轻人抱有一种“不能让孩子受苦”的想法，这种想法在中国年轻人当中也存在，为什么年轻人会对哺育下一代产生如此强烈的责任意识？“受苦”的意涵是否随着时代的发展也在发生变化？</em></p>
<p><strong>山田昌弘：</strong> 在东亚社会里，让子女接受比自己更好的教育，找到比自己更好的工作，是父母的生活意义所在。</p>
<p>另外，孩子之间的歧视意识也很强，现如今的年轻人会担心自己的贫穷会让孩子受到欺负。孩子们在一起玩耍的时候，有时也会需求类似Switch游戏机这样的外部硬件。如果不买这些东西，会不会让孩子感到痛苦？年轻父母的这种想法正越来越强烈。</p>
<p>以前只要父母能够陪在孩子身边就足够了，但现在越来越多的父母觉得，不能在孩子身上花费足够的金钱会很难受。</p>
<p><strong>南方周末：</strong> <em>在中国，未婚适龄男女可能会遭到父母和长辈的催婚，被称为光棍、剩女，带有一定贬义。日本有类似情况吗？你如何理解这种现象？</em></p>
<p><strong>山田昌弘：</strong> 单身=不受欢迎，这一等式会让人间接联想到，没进入婚姻是不是因为男性收入低，或者是不是因为女性的容貌有问题。</p>
<p>在日本，因为未婚率高得非常明显，想结婚却做不到的人，和能做到但不想结婚的人都混杂在一起，因而单纯对于未婚者的贬低并不常见。</p>
<p>同样由于未婚率非常高，来自父母的压力已经要比以前小很多了。很多父母会认为，与其让孩子和收入低的人结婚，然后过上不太理想的贫困生活，还不如独身在家。在日本，越来越多的父母认为，与其被奇怪的结婚对象缠住，还不如让孩子保持单身。继承家业的意识在日本正逐渐淡薄（现在70岁以上的人仍然有很强烈的这种意识）。</p>
<p><strong>南方周末：</strong> <em>你提到，在前现代社会，子女是一种“生产性财产”，进入现代社会则变为“消费性财产”，需要投入较高的育儿金，拥有一个“高价值感”的孩子成为育儿行为追求的价值，而高价值感由孩子的学历、工作的光鲜程度等因素决定。为什么父母对育儿会有这样的期待？</em></p>
<p><strong>山田昌弘：</strong> 孩子的地位=父母的地位，东亚文化圈的这种关乎面子或虚荣心的意识很强烈。从感情上看，这源于父母希望子女在经济上能过着无忧无虑的生活。虽然初心是好的，但随着体面意识带来的比较心理，培养高价值的孩子也就成了一种扭曲的期待。</p>
<p>欧美的传统则有很大的不同，孩子成年后不再在经济上依赖父母，有着较强的自我责任意识。对于父母来说，孩子在养育过程中很可爱，长大后则只期待情绪交流的存在。</p>
<p><strong>南方周末：</strong> <em>看上去，育儿正在逐渐演化成一种竞争。日本有没有“学区房”“鸡娃”现象？高度竞争的社会是否会对生育率产生影响？</em></p>
<p><strong>山田昌弘：</strong> 日本的就业市场对学历的要求则相对比较宽松，高中毕业和大学毕业的工资差距在世界上也算小的。也就是说，即使是高中毕业或专科毕业，也有可能过上相对好的生活。父母也没必要那么热心，尤其是那些自己本身也只是高中毕业的父母。</p>
<h2 id="4-年轻人规避风险的倾向在不断加强"><a href="#4-年轻人规避风险的倾向在不断加强" class="headerlink" title="4. 年轻人规避风险的倾向在不断加强"></a>4. 年轻人规避风险的倾向在不断加强</h2><p><strong>南方周末：</strong> <em>年轻人结婚意愿消退的一个可能的原因是，越来越多人意识到婚姻是一种契约关系，而契约有破裂风险。为何越来越多年轻人倾向于对结婚这件事做风险评估？</em></p>
<p><strong>山田昌弘：</strong> 对年轻人来说，将来能否过上中流生活是他们非常关心的事情。在日本，1990年以前，大多数年轻人都可以期待依靠“年功序列制度”过上工资每年都增长的生活，但随着全球化的发展，经济风险越来越大，如今的年轻人已经不能再乐观地认为“将来总会有办法的”。出于这个原因，年轻人规避风险的倾向在不断加强。</p>
<p>如果从一开始就过着相对贫穷的生活，那么一般都不会觉得有什么风险存在，但现在的很多年轻人在未成年时期过着相当充实且富裕的生活。不想放弃这种生活的意识会很强烈。特别是作为独生子女的这一代中国年轻人，这种意识应该会更加强烈。</p>
<p><strong>南方周末：</strong> <em>你提到一个现象：如今的年轻人甚至连恋爱的欲望都在消退。韩国有“三弃”（放弃爱情、婚姻、生育），日本有“草食男”（恋爱被动、不积极），中国也有一些年轻人觉得恋爱是件麻烦事，为何年轻人会丧失恋爱的欲望？</em></p>
<p><strong>山田昌弘：</strong> 因为现代的年轻人觉得，恋爱感情总是会“降温”的。在欧美，“与相爱的人在一起”就是人生的意义。但是，在东亚各国，这种想法并不普及。在不少人看来，谈恋爱其实就是寻找结婚对象的一种过程，因此他们也认为，和明知道不能结婚的人交往，是在浪费时间和金钱。越来越多的人认为，恋爱本身就是一种需要顾虑别人的不快乐的事。因为色情行业的扩大，尤其在日本，谈恋爱的性价值也降低了。</p>
<p><strong>南方周末：</strong> <em>许多人通过虚拟关系满足恋爱需求，比如时下流行的AI男女友，或是“嗑CP”，在围观他人恋爱的过程中获得情感满足。你怎么理解这些现象？也有人质疑，通过数据计算、金钱付出而获得情感满足，削弱了爱情的复杂性。</em></p>
<p><strong>山田昌弘：</strong> 虽然我认为这是逃避的一种形式，但对现在的年轻人来说，有越来越多的人认为这是比现实恋爱还要愉快的交流时间。如果现实恋爱的满足度下降了，那虚拟恋爱的价值就会上升。也许现在已经不能说现实中的满足就更优越了。</p>
<p><strong>南方周末：</strong> <em>1997年你就命名了日本社会的“单身寄生族”现象，近年，中国社会也出现了“全职儿女”，即儿女们放弃工作，回家承担家务、给父母养老，生活开支由父母负担，部分全职儿女还会得到父母开的工资。你似乎有意强调“单身寄生族”和婚育意愿的关联，能否再展开谈谈？</em></p>
<p><strong>山田昌弘：</strong> 在遇到自己理想的结婚对象之前，在父母身边过着富裕的生活，这种“等待”很可能是没有尽头的。</p>
<p>在欧美，因为成年后必须脱离父母自立，所以两个年轻人凑一起过日子会比较有利。但是在东亚国家，脱离父母独立，一般意味着孩子能在外面过上比待在父母家里更好的生活。在遇到能一起过上更好生活的结婚对象之前，先在父母家里“等待”也没什么关系，甚至父母也如此期待着。</p>
<p>但是，一直等不到理想的人出现，而就这样慢慢老去的“前”年轻人层出不穷，在日本，人到中年也依然与父母同居的未婚者正在不断增加。</p>
<p><strong>南方周末：</strong> <em>人们通常认为，年轻人拥有无限可能，正是积极试错的年龄段。但你却提出“社会为什么对年轻人冷酷无情”的疑问，为什么？</em></p>
<p><strong>山田昌弘：</strong> 如果能像欧美那样，大多数孩子在成年后就离开父母自立，那么即使在社会中冒险失败，重新来过也确实不是什么难事。</p>
<p>但是，在东亚各国，年轻人会拿自己和父母做比较，越来越多的年轻人认为达不到父母的水平就是失败。在父母的关照下过着富裕生活的人更是如此。</p>
<p>此外，在日本，很多年轻人认为就业和结婚是不能重新来过的，这也是很重要的影响因素之一。</p>
]]></content>
      <categories>
        <category>摘抄</category>
      </categories>
      <tags>
        <tag>爱情</tag>
        <tag>人生选择</tag>
        <tag>恋爱</tag>
      </tags>
  </entry>
  <entry>
    <title>常见服务器作业管理系统</title>
    <url>/2023/12/15/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>如题。本文是对几种服务器作业管理系统的简要介绍。</p>
<span id="more"></span>

<h2 id="一、在Linux高性能服务器集群上，常用的作业管理系统有哪些"><a href="#一、在Linux高性能服务器集群上，常用的作业管理系统有哪些" class="headerlink" title="一、在Linux高性能服务器集群上，常用的作业管理系统有哪些"></a>一、在Linux高性能服务器集群上，常用的作业管理系统有哪些</h2><p>在Linux高性能服务器集群上，常用的作业管理系统包括：</p>
<ol>
<li>PBS（Portable Batch System）：PBS最初由NASA的Ames研究中心开发，为了提供一个能满足异构计算网络需要的软件包，特别是满足高性能计算的需要。它力求提供对批处理的初始化和调度执行的控制，允许作业在不同主机间的路由。</li>
<li>LSF（Load Sharing Facility）：LSF是一个集群环境和高性能计算环境中作业调度和集群负载均衡的管理平台。它允许用户从单个节点提交和管理集群环境中的作业，支持跨多个节点和处理器分配作业，并提供丰富的调度和负载均衡功能。</li>
<li>Condor：Condor是由威斯康星大学麦迪逊分校开发的分布式系统软件，用于管理高性能计算机集群 中的工作负载。它允许用户在集群中的多个节点上提交和管理作业，并支持复杂的调度策略，包括优先级调度、抢占式调度和基于策略的调度。</li>
<li>SGE（Sun Grid Engine）：SGE是Sun Microsystems开发的一个开源集群管理系统，用于在高性能计算环境中进行作业调度和集群管理。它支持跨多个节点和处理器分配作业，并提供丰富的调度和负载均衡功能。</li>
<li>Slurm：Slurm是一个免费、开源、容错的集群管理系统和作业调度器，适用于大型和小型Linux集群。Slurm不需要数据库配置即可实现高伸缩性，并且可以方便地在现有系统上安装。</li>
</ol>
<p>这些作业管理系统各有特点和优势，可以根据具体需求选择适合的系统来管理Linux高性能服务器集群 上的作业。</p>
<h2 id="二、-除了这些作业管理系统以外，还有没有别的作业管理系统呢"><a href="#二、-除了这些作业管理系统以外，还有没有别的作业管理系统呢" class="headerlink" title="二、 除了这些作业管理系统以外，还有没有别的作业管理系统呢"></a>二、 除了这些作业管理系统以外，还有没有别的作业管理系统呢</h2><p>除了上述提到的作业管理系统，还有一些其他的作业管理系统可供选择，例如：</p>
<ol>
<li>Torque：Torque是一个基于PBS（Portable Batch System）的开源作业管理系统，适用于Linux集群环境。它提供了强大的作业调度和集群管理功能，支持跨多个节点和处理器分配作业，并具有可扩展性和灵活性。</li>
<li>Moab Cluster Suite：Moab Cluster Suite是一个功能强大的作业管理系统，适用于各种高性能计 算环境，包括Linux集群。它提供了丰富的调度和负载均衡功能，支持复杂的作业管理需求，并具有易 于使用的界面和可扩展性。</li>
</ol>
<p>这些作业管理系统在功能和特点上可能有所不同，可以根据具体的需求和集群环境选择适合的系统来管理作业。</p>
<h2 id="三、各个作业系统如何查询计算节点的状态"><a href="#三、各个作业系统如何查询计算节点的状态" class="headerlink" title="三、各个作业系统如何查询计算节点的状态"></a>三、各个作业系统如何查询计算节点的状态</h2><p>各个作业系统查询计算节点状态的指令如下：</p>
<ul>
<li>PBS：   <code>pbsnodes</code></li>
<li>LSF：   <code>bhosts</code></li>
<li>slurm： <code>sinfo -N -l</code></li>
</ul>
<p>以slurm系统为例，使用<code>sinfo -N -l</code>指令可以详细的列出所有计算节点的状态（如下），从而便于用户选择计算任务的执行节点</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(base) user@server:~$ sinfo -N -l</span><br><span class="line">Sun Dec 17 18:00:23 2023</span><br><span class="line">NODELIST      NODES  PARTITION       STATE CPUS    S:C:T MEMORY TMP_DISK WEIGHT AVAIL_FE REASON</span><br><span class="line">gnode001          1        hpc   allocated   24   2:12:1 257252        0      1   (null) none</span><br><span class="line">gnode001          1  prj-ocean   allocated   24   2:12:1 257252        0      1   (null) none</span><br><span class="line">gnode002          1        hpc   allocated   24   2:12:1 257252        0      1   (null) none</span><br><span class="line">gnode002          1  prj-ocean   allocated   24   2:12:1 257252        0      1   (null) none</span><br><span class="line">gnode003          1        hpc   allocated   24   2:12:1 257252        0      1   (null) none</span><br><span class="line">gnode003          1  prj-ocean   allocated   24   2:12:1 257252        0      1   (null) none</span><br><span class="line">gnode004          1        hpc   allocated   24   2:12:1 257252        0      1   (null) none</span><br><span class="line">gnode004          1  prj-ocean   allocated   24   2:12:1 257252        0      1   (null) none</span><br><span class="line">gnode005          1        hpc   allocated   24   2:12:1 257252        0      1   (null) none</span><br><span class="line">gnode005          1  prj-ocean   allocated   24   2:12:1 257252        0      1   (null) none</span><br><span class="line">gnode006          1        hpc   allocated   24   2:12:1 257252        0      1   (null) none</span><br><span class="line">gnode006          1  prj-ocean   allocated   24   2:12:1 257252        0      1   (null) none</span><br><span class="line">gnode007          1        hpc   allocated   24   2:12:1 257252        0      1   (null) none</span><br><span class="line">gnode007          1  prj-ocean   allocated   24   2:12:1 257252        0      1   (null) none</span><br><span class="line">gnode008          1    zelixir       mixed   48   2:12:2 320904        0      1   (null) none</span><br><span class="line">gnode008          1        gpu       mixed   48   2:12:2 320904        0      1   (null) none</span><br><span class="line">gnode008          1 lowzelixir       mixed   48   2:12:2 320904        0      1   (null) none</span><br><span class="line">gnode008          1  prj-ocean       mixed   48   2:12:2 320904        0      1   (null) none</span><br><span class="line">mnode019          1    mqueue*        idle   48    8:6:1  64000        0      1   (null) none</span><br></pre></td></tr></table></figure>

<p>另外，还有一个指令， <code>free -h</code> ，是查看当前服务器的内存使用状态的，有时候内存用完了，运行代码也会很卡</p>
<hr>
<p>另外参考这些文章：</p>
<p><a href="https://www.cnblogs.com/bio-mary/p/13500255.html">PBS LSF 作业管理系统 SLURM 资源管理系统</a><br><a href="https://www.jianshu.com/p/2f6c799ca147">PBS 作业管理系统</a><br><a href="https://www.jianshu.com/p/601ca9f33b31">LSF 作业管理系统</a><br><a href="https://www.jianshu.com/p/e560b19dbd3e">SLURM 资源管理系统</a><br><a href="https://zhuanlan.zhihu.com/p/500313444">PBS作业调度详解 - 宝禄计算的文章 - 知乎</a><br><a href="https://blog.csdn.net/charlee44/article/details/104018595">高通量计算框架HTCondor(一)——概述</a></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>ssh</tag>
        <tag>nodejs</tag>
        <tag>vscode</tag>
        <tag>远程服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>考研日记day69</title>
    <url>/2021/11/26/%E6%B2%A1%E6%9C%89%E6%84%8F%E4%B9%89%E7%9A%84%E4%BA%BA%E7%94%9F-%E8%80%83%E7%A0%94%E6%9C%9F%E9%97%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E7%BB%AA/</url>
    <content><![CDATA[<p>“那些我们拥有过的或者会拥有的，亲情，友情，爱情，都会随着时间的流逝而最终从我们手中失去。而金钱、名誉这些，全是身外之物，一时的名誉也不能帮助你一辈子过上安稳的生活。”</p>
<span id="more"></span>

<blockquote>
<p>考研日记day69</p>
</blockquote>
<p>有没有一瞬间，你会觉得人生没有意义、人间不值得？</p>
<p>尤其是在你看不到生活的希望之时。对你而言，生活是一条漫长的隧道，根本走不到头，而隧道的黑暗以及周边潮湿冰冷的空气压得你喘不出气？</p>
<p>我们活着的意义是什么呢？不知道。中学以前，老师和父母会告诉你要好好学习，好好学习可以换来老师的夸奖、父母的爱，以及同学投来的羡慕的眼神。那时，只要学习好，就算社交能力再差、朋友再少，也不会有什么负面情绪。所以，那时的我，为了保持一个好的成绩无所不用其极，就算有害于同学关系也一点都不在意。</p>
<p>到了大学，评价标准变得多样化，然而不像中学，哪一条评价标准的路都不好走，也没人手把手告诉你某条特定的路应该怎么走。聪明的人已经想到了办法：他们积极融入学长学姐的生活，用各种方式从学长学姐那里换取到信息，然后基于这些信息走上了追求成就的道路——虽然也会很累，但不至于走弯路。</p>
<p>一些脑子不太灵光的人不愿意在人际上下功夫，他想自己独立自主、自力更生探索大学发展道路。于是，在信息有限的情况下，他做了大量尝试，当然也几乎处处碰壁，最后不得不和更多的人一起，走上考研这条窄窄的独木桥，然后还要被嘲讽“原来你还是个差点进队的竞赛大佬——怎么现在混成这个样子？”</p>
<p>当我们拥有很多珍贵的东西时，我们不会珍惜；直到真正失去，才追悔莫及——这是今年年初我发的一条朋友圈。当时只是伤春悲秋，吐槽IBP住宿条件不如南开，同时暗搓搓的秀优越感。现在看来，你是真的已经失去了很多珍贵的东西——而且不出意外你还会失去更多。可是，现在的这一切，似乎在那之前就已经注定了——除非你再回到年初，然后说服家长给你报个托福班（光报考试不行，凭你的英语基础自学通过不了托福考试的）。</p>
<p>说真的，这些已经失去的我都坦然接受了；但我更害怕的是一些岌岌可危、将要失去的东西。可转念一想，人生不就是一个不断失去的过程吗？可既然这样，既然我们一直在体验失去的痛苦，我们还活着干嘛？</p>
<p>那些我们拥有过的或者会拥有的，亲情，友情，爱情，都会随着时间的流逝而最终从我们手中失去。而金钱、名誉这些，全是身外之物，一时的名誉也不能帮助你一辈子过上安稳的生活。甚至，我们连自己的人生都是不确定的，说不定哪天倒霉出门就被泥头车创死了呢？</p>
<p>仔细想一想，人的一生真的很累。反正我人生前20年，在中学阶段取得的那些成就，背后是更多的汗水和泪水。而且付出和收获是不对等的，我付出了那么多，结果连个省队都不让我进去，我付出这么多凭什么啊？我的大学生活也挺累的，我没什么去全球TOP10这种远大志向，我只想安安稳稳在国内读个PhD，你连保研名额都不给我，凭什么啊？还有考研。我确实没有那些从大一就开始准备考研的同学复习时间长，知识也没他们扎实，可是我这几个月天天过着朝8晚12一天泡在图书馆12个小时的苦逼生活，到头来还得再复习一年，你觉得那个时候我的心态会不会崩？还有，我已经预料到了，如果走科研这条路，未来还会有更多的付出了很多，但到头来一场空的事情。不敢再往下想了。</p>
<p>Life Restart 可以解决问题吗？不知道。反正确实能逃避很多问题。我现在甚至觉得整个大自然就是个坑货。你想一个场景，在培养着的细菌中间加一滴抗生素，不努力突变产生新基因的细菌就得死，那些努力突变产生新基因的细菌，如果突变错了，照样还是得死。到头来都是死，付出这么多何必呢？</p>
<p>当然，按照马哲辩证法和生物进化论的思想，正是因为这样一轮一轮的淘汰，才造就了今日的我们——作为“万物之灵”的Homo sapiens还应该感谢这样的过程。我可一点都不感谢这个过程，我觉得挺残酷的，如果有得选我可不愿意参加这种过程。</p>
<p>然而，你不按规则玩是吧，那作为规则制定者的universe有一亿种方法让你难受。你本以为躺平还可以就着老本吃个保底，对不起，保底没有，你已经出局了。对，你连保研都不配，你只配和更多的学生卷100选1甚至1000选1的考研。</p>
<p>这公平吗？我不知道。或许对很多人来说非常公平吧。但对我来说一点都不公平，这相当于把我的饭碗砸了还和我说要做好公民，不能骂人打架。你谁啊就搁这要求我，我按你的要求做了我能得到什么好处？</p>
<p>这两天模考成绩不理想，依然没过340的线。心情很糟，想骂一骂人。而且我感觉自己可能确实存在一些心理问题了。希望扛过这一个月。祝好。</p>
]]></content>
      <categories>
        <category>杂思</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>负面情绪</tag>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器UA与部分网页功能异常的关系</title>
    <url>/2022/07/26/%E6%B5%8F%E8%A7%88%E5%99%A8ua%E4%B8%8E%E9%83%A8%E5%88%86%E7%BD%91%E9%A1%B5%E5%8A%9F%E8%83%BD%E5%BC%82%E5%B8%B8%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>User-Agent字符串也会影响网站功能</p>
<span id="more"></span>

<p>前些日子不知道怎么回事，我电脑上的Firefox浏览器抽风了，百度地图没法用鼠标滚轮缩放，WPS云文档编辑器里面没法Ctrl+V粘贴。然而，同样的网页，在Microsoft Edge中功能是正常的。</p>
<p>之前一度以为是Firefox抽风，于是每次都开F12调试，期望从调试器的报错中找到一些蛛丝马迹——然而什么都没有。</p>
<p>今天突然发现是我的问题。我在Firefox中安装过一个插件，叫做User-Agent Switcher and Manager，是用来改UA字符串的。因为有些网站（点名飞书网页版）曾经只支持Chrome不支持Firefox，为了用那些网站，我有时候会用这个插件伪装Chrome浏览器。</p>
<p>上一次用这个插件不知道是什么时候的事情了，然而我一直忘了关，所以这段时间在各个网站眼里我一直是在通过Chrome上网。我猜可能正是这个原因，百度地图和WPS云文档调用了一些本属于Chrome的API，而Firefox不兼容这些API，从而造成了网页功能的异常。</p>
<p>在关闭插件以后，所有网页的功能都恢复正常了。一个困扰我很久的玄学问题也得到解释了。</p>
<p>PS：UA字符串对照</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">关闭插件之前：Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">关闭插件之后：Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>满城已是桂花香</title>
    <url>/2022/10/17/%E6%BB%A1%E5%9F%8E%E5%B7%B2%E6%98%AF%E6%A1%82%E8%8A%B1%E9%A6%99/</url>
    <content><![CDATA[<p>秋天是桂花盛开的季节。</p>
<span id="more"></span>

<p>上海的桂花开了。园区里飘散着一股甜甜的香味。</p>
<p>虽然上海的桂花比家乡晚开了一个多月，但这也足够让我惊喜。在我的印象中，桂花是秋天的代表，当桂花的香气在飘散在空中时，人们就会意识到，原来秋天已经来了。</p>
<p>可惜，我在北方上大学的四年里，并没有如尝所愿在秋天到来时品尝这沁人的芬芳。北京太冷，天津太干，可能都不适合桂花的生长吧。</p>
<p>刚刚过去的周末过得懒洋洋的。周六补了个觉，在草草做了点计算生物学的作业以后去和同学打羽毛球了。三个多小时的运动，很累，但是很快乐。于是周日就惨了，我要完成作业，要帮某人检查作业，还要规划点别的任务。当然，懒散如我，肯定不可能真的按照计划完成。在昨天下午匆忙完成计算生物学作业以后，又一次骑上自行车，出门溜达去了。这一次去了一些不一样的地方，例如西岸艺术中心和油罐艺术中心，例如上海南站，还例如虹漕体育馆。虽是仲秋，天气也有些阴沉，但穿梭于满城桂花的香气中，心情是愉悦放松的。</p>
<p>有时候还是会追忆大学生活，特别是大三下和大四下的时光。单纯是觉得那些时光很快乐，很充实。这几天又看到了很多人的恋爱和分手故事，实在有些百感交集。曾经我以为自己缺少的是恋爱，现在却觉得，我只是缺爱，缺少那种由别人对我的关心、关注所代表的爱。然而恋爱却不能弥补我内心对爱（或者说，来自他人的关心关怀）的缺失，反而可能加重内心的空虚感和寂寞感。所以为什么要恋爱呢？把那些功夫用在提升自己和结交新朋友，不好吗？</p>
<p>一些碎碎念，写于岳阳路。</p>
]]></content>
      <categories>
        <category>杂思</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title>由一场线上云参观引发的碎碎念</title>
    <url>/2022/08/25/%E7%94%B1%E4%B8%80%E5%9C%BA%E7%BA%BF%E4%B8%8A%E4%BA%91%E5%8F%82%E8%A7%82%E5%BC%95%E5%8F%91%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
    <content><![CDATA[<p>今天下午，闲聊群里有人转发了IBP云参观的直播链接。点进去看了会儿，然后退出了。不是因为对直播内容不感兴趣，只是已经到了下午的上班时间，在这里摸鱼看直播总还是不太好。</p>
<p>可是，直播开始的几分钟里，那些闪过的画面，依然刺痛了我，让我回忆起在生物物理所的那些日子。</p>
<span id="more"></span>

<p>北京的天依然很晴，天空是蓝色的，没有一朵云。这是夏末秋初的北京，就如记忆中的那样。</p>
<p>赛利麦，江州渔父，711，熟悉的街道，熟悉的建筑，甚至还有熟悉的六号楼和建所60周年纪念长廊。这些景物一一划过镜头，也不断冲击着我的神经，提醒着我可能再也不能亲眼目睹这些场景了。</p>
<p>有时候人们会说自己很怀旧。有一个英文单词叫做nostalgia，过去的美好时光，不正是表明人们更喜欢过去那些已经回不来的事情了吗？你看，生物物理所对面的那家旅馆，就叫时光漫步酒店，nostalgia hotel，多巧啊。我在回忆着过去的美好时光，而那段美好时光，就发生在一座以“过去的美好时光”命名的酒店旁。</p>
<p>上初中时，并不会怀念小学生活，因为小学过得并不美好。高中时，倒是很怀念初中生活，因为熟悉的小伙伴很多，那时也有很多开心的回忆。大学时常常怀念高中，怀念那些孤独而充实的时光。然而我并不特别想念大学期间在南开园度过的两年；如果说大学生活有什么值得回忆的，那一定是在生物物理所度过的一年时光，是和邹承鲁班的同学们，和课题组的师兄师姐们以及yxy一起度过的时光——那是充实的一年，我把很多的时间用在了写代码、学习和社交上，虽然也有不少时间被浪费，但至少比在南开园里要好很多。</p>
<p>我们为什么会怀念过去呢？可能是现在过得不好，也可能纯粹是在新环境中暂时感到不适应。后者是暂时的，因为我们可以相信，只要不断努力，生活最终会变好。</p>
<p>也许将来有一天，我还会怀念起在上海生科院度过的这些日子。 不过这些都不重要。虽然说，“当我们拥有很多珍贵的东西时，我们不会珍惜；直到真正失去，才追悔莫及”。可是，我们也可以不用后悔，只需要我们过好当下的每一天，好好珍惜我们身边那些美好的事物就行了。</p>
<p>以上。</p>
<p>2022年8月24日写于岳阳路</p>
<hr>
<hr>
<blockquote>
<p>旧评论系统备份：</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">小阿鸣(2022-08-26 15:57:53):</span><br><span class="line">	果然每个人的世界就是一个一个的平行时空啊。那些让你记忆深刻的东西，有的我想了想才能想起来，</span><br><span class="line">	比如60周年纪念长廊，至于赛丽麦、江洲渔父、时光漫步酒店，我甚至没有印象。。可能我就是这么没心没肺吧哈哈。</span><br><span class="line"></span><br><span class="line">&gt; WarrenZhang(2022-08-28 02:07:47):</span><br><span class="line">&gt; 	每个人的世界就是一个一个的平行时空，这句话说得真好。我想，其实这种情况更多的是和个人经历有关。</span><br><span class="line">&gt;	例如樊总在南开的龙舟队有很多关系好的兄弟姐妹，我想，在那里的经历一定会成为樊总的难忘回忆；相比之下，邹承鲁班的经历就逊色多了。</span><br><span class="line">&gt;	然而对我来说，南开并不是一个让我感到开心的地方，和高中好朋友的断交、体测不及格、恋爱分手，以及大二大三一次次赶ddl的不愉快经历，为我心中的南开园蒙上了一层灰蒙蒙的色彩；</span><br><span class="line">&gt;	而在生物物理所的那一年，我体验到的是一种不同的生活，在那里我看到了生活的希望。</span><br><span class="line">&gt;	很多情绪难以表达，总之就是那里对我来说意义非凡，因此我对生物物理所附近的一草一木都很怀念。</span><br><span class="line">&gt;	其实我想，等樊总从清华毕业以后，可能也会怀念起清华的一草一木。毕竟值得我们怀念的，很多都是一些美好的事物啊</span><br><span class="line">&gt;</span><br><span class="line">&gt; Hazel(2022-09-04 14:59:46):</span><br><span class="line">&gt;	我也非常怀念ibp的生活，因为感觉在这里的一年里慢慢找到了自己。</span><br><span class="line">&gt;	看到自己经历挫折、得到帮助、剖析自己、面临一次次选择、找到自己喜欢的样子、和小伙伴一起玩耍时自己越来越松弛，都感觉自己的每一个细胞都在慢慢变好。</span><br><span class="line">&gt;	我很喜欢在IBP极度放松的自己，是再也不用遮遮掩掩，想毒嘴就毒嘴，想去吃什么就说出来，没什么顾忌的日子。</span><br><span class="line">&gt;	我无比怀念朋友就在身边的日子，保持着联系沟通也拥有各自的独立。我们如此怀念当时，更多是因为我们的经历和陪伴我们的人。</span><br><span class="line">&gt;	至少在周围的朋友都走了之后，换到了新的实验室，我发现日子变得无聊了起来。</span><br><span class="line">&gt;	旅行重要的不是目的地，而是陪你走过的人。</span><br><span class="line">&gt;	可是你看最后，我们都更加理性地选择了未来将要去的方向，而不是充满回忆的地方。</span><br><span class="line">&gt;	或许是因为，我们相信，我们仍然可以创造一个新的美好的回忆在新的地方。</span><br><span class="line">&gt;</span><br><span class="line">&gt; WarrenZhang(2022-09-04 18:02:01):</span><br><span class="line">&gt;	所以说，我们在IBP的一年，实际上是让我们变得更好的一年。</span><br><span class="line">&gt;	在这一年，我们看到了比南开更大的世界，知道了更多的可能；然而不管怎样，最终我们还是要毕业，要走向下一个人生阶段，要去面临新的问题和挑战。</span><br><span class="line">&gt;	“过去的美好时光”只能是过去的时光，我们可以怀念，可以追思，但绝不能沉湎其中。一切还是要向前看。</span><br><span class="line">&gt;	愿我们都有一个光明的未来。</span><br><span class="line">&gt;</span><br><span class="line">&gt; Hazel(2022-09-05 18:52:59):</span><br><span class="line">&gt;	是的。并且这种东西不可衡量。</span><br><span class="line">&gt;	就像是：即便最后考研失败，但是在ibp准备考研的日子以及在ibp呆过的整个日子还是会让我觉得开心快乐；</span><br><span class="line">&gt;	而在南开，真的是无论做什么，都达不到那种非常放松、相信结果再差自己都能hold住的感觉。</span><br><span class="line">&gt;	我有时候试图把一些好事强加在南开上，比如能来ibp就是因为南开，但是现在回想起来，觉得也只是觉得感谢，这和熟悉以及深深的怀念是完全不一样的。</span><br><span class="line">&gt;	我在把nku物质化，但是却把ibp拟人化。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>杂思</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
        <tag>生物物理所</tag>
      </tags>
  </entry>
  <entry>
    <title>程序人生</title>
    <url>/2022/08/12/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/</url>
    <content><![CDATA[<p>这是小米公司董事长雷军在二十多年前写下的一篇帖子。感触很深，摘抄于此，以供品读。</p>
<span id="more"></span>

<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">今天有朋友发给我一篇我在20年前在BBS上写的帖子。那还是1996年，我们通过电话线拨号连接到西点BBS上飙帖子玩的年代。</span><br><span class="line"></span><br><span class="line">那是一个互联网混沌初开的年代，那是一个BBS和Email几乎主宰了全部互联网的年代，那是一个青春的理想和热血沸腾的年代。</span><br><span class="line"></span><br><span class="line">我是一个程序员，一个软件工程师。到今天，我也依然是一个程序员，一个软件工程师。</span><br><span class="line"></span><br><span class="line">本文是20年前我对程序人生的一点看法。20年后的今天，重读之后，这依然是我对程序人生的态度。</span><br><span class="line"></span><br><span class="line">2016年3月24日 雷军</span><br></pre></td></tr></table></figure>

<p>“程序人生”的作文</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">From: Lei Jun</span><br><span class="line"></span><br><span class="line">To: Dai Jun</span><br><span class="line"></span><br><span class="line">时间: 1996-08-31 00:28</span><br></pre></td></tr></table></figure>

<p>戴老师：</p>
<p>你的命题作文我已经写完，如有不妥之处，请指出。今天下午我已经写完，但突然 ZRM 死机，我没有存盘。晚上只好接着写，真是不幸。文中如有错漏之处可能是我第二遍写漏了。</p>
<p>本文参考过 WT 和 JH 的有关讨论信，在此致谢。</p>
<hr>
<h2 id="程序人生"><a href="#程序人生" class="headerlink" title="程序人生"></a>程序人生</h2><p><strong>[题记] 如果程序人生的话，这条路太漫长</strong></p>
<p>“程序人生”这个词是什么意思，刚开始时我并不明白。这个词源于业余 BBS 站，站上 PROGRAMMER 栏目的中文名就是这个词，英文翻译过来就是”程序员”，但程序人生又比程序员多了很多含义，似乎多了一种沧桑感。但不管这么多，讲讲编程感受不算跑题。</p>
<p>首先我先讲讲自己的路，这样也许大家才能相信我的坦诚和我的这篇编程感受的真实性。这些感受是我个人感受，不全面的地方，请大家指正。</p>
<p><strong>我的程序人生路</strong></p>
<p>我并非天生喜欢电脑，上高中时也没有想过程序员的生活。我学电脑非常偶然，小时候的一个好朋友上大学时选择了电脑专业，为了和这个朋友有更多的共同语言，我也选择了计算机系，开始步入程序人生的道路。</p>
<p>当我学了一点电脑知识后，就发现电脑将是我人生的最爱。读书时，我不是特别会搞关系的人，同学关系说不上差，也好不到那里去。我是八七年上的大学，我们大一下学期才有专业课。当我有资格上机的时候，发现电脑世界太美妙，就一头扎进去。当时用的是 Motorola 68000 (相当于 Intel 8088), 540K 的内存，运行的 UNIX 操作系统，八个人一起用。</p>
<p>大二学 PC，又过了一学期，开始出现在老师的实验室，帮忙干活，当时写了现在还有人用的 RI （一个清内存的小工具）。又过了一个学期，开始和校外的公司接触。大二暑假，和一个朋友组建了 Yellow Rose 组，写了我第一个商品软件 BITLOK 0.99。后来开过公司也写过一些软件。</p>
<p>大学毕业后，分到研究所，不太适应研究所的气氛。调槽到金山软件公司，开始了职业程序员的生涯。后来成了北京金山软件公司的经理，但我还是一名程序员。</p>
<p><strong>编程的感受</strong></p>
<p><strong>-– 程序员活在自己想象的王国里 —</strong></p>
<p>我刚接触电脑就发现电脑的妙处，电脑远没有人那么复杂。如果你的程序写得好，你就可以和电脑处好关系，就可以指挥电脑干你想干的事。</p>
<p>这个时候你是十足的主宰。每每你坐在电脑面前，你就是在你的王国里巡行。这样的日子简直就是天堂般的日子。</p>
<p>电脑里的世界很大，编程人是活在自己想象的王国里。你可以想象到电脑里细微到每一个字节、每一个比特位的东西。</p>
<p><strong>-– 我爱编程这个工作，可以肯定我会干上一辈子 —</strong></p>
<p>不少人认为程序员最多干到三十五岁就可以收山换环境了，脑子也差不多该歇歇了，体力也不支了。并认为写程序是年轻人的事情，到了一定岁数，估计没什么人再当程序员了。</p>
<p>当我刚有一点水平的时候，我也认为编程辛苦，也想三十岁后干别的。当我年长一点后就发现了自己的无知。一个人大学毕业就二十一二岁，有点水平的时候可能二十五，接着就是老婆加上孩子和房子等等诸多事情。</p>
<p>一切搞掂的时候，也许就是三十五岁。如果这样的话，我们就不用选择程序人生的道路。</p>
<p>电脑进入我国时间不短，但真正大规模开始用，还是八五年 PC 开始的，因此国内真正写电脑程序的人最长也就写了十几年（不知道是否还有这样的人）。由于电脑应用在国内时间比较短，国内开发的主力是三十五岁以下的年轻人为主。但这不表示程序员如同红粉佳人般的容易衰老。美国和台湾开发以三十四十多岁的人为主。开始的时候，我们觉得我们没有什么不能做的（现在还能听到这样的豪言壮语），而且更要命的是好象我们特别聪明，特别适合开发软件，比老外强得多。当我们真正接触那些杰出的开发人员的时候，发现他们太厉害了，都有十多年的开发经验。虽然也有很多年轻人做了很多好东西，但决大多数的产品出自这些有丰富开发经验的程序员的手。</p>
<p>刚毕业的时候，编程不仅仅是爱好，而且也成了一辈子的工作。整天不知道写些什么东西，觉得特别没劲，找不到感觉，特别灰心。后来，才明白，只有全身心地投入，程序才会有意识。</p>
<p>写程序简直是在自杀，巨费精力巨费脑子巨累。但我爱编程这个工作，可以肯定我会干上一辈子，虽然我没有打算一生只干这一件事。用一生来编程序是一件既容易又困难的事。如果碌碌无为，为交差写点程序，这样写两辈子的人都有。但如果想全身心地写程序，写十年就不是一件容易的事。现在我不少朋友都洗手了，有时我也想”用什么电脑，Windows 外的世界不是也很大吗?”。面对电脑的时候，立刻顿悟：电脑还是自己最擅长干的事，也是最顺手的事。</p>
<p><strong>-– 高级程序员不是追求的目标 —</strong></p>
<p>有的人学习编程技术，是把高级程序员做为追求的目标，甚至是终身的奋斗目标。后来参与了真正的商品化软件开发后，反而困惑了，茫然了。</p>
<p>一个人只要有韧性和灵性，有机会接触并学习电脑的编程技术，就会成为一个不错的程序员。刚开始写程序，这时候学得多的人写的好，到了后来，大家都上了一个层次，谁写的好只取决于这个人是否细心、有韧性、有灵性。掌握多一点或少一点，很快就能补上。成为一个高级程序员并不是件困难的事。</p>
<p>当我上学的时候，高级程序员也曾是我的目标，我希望我的技术能得到别人的承认。后来发现无论多么高级的程序员都没用，关键是你是否能够出想法出产品，你的劳动是否能被社会承认，能为社会创造财富。成为高级程序员绝对不是追求的目标。</p>
<p><strong>-– 编程不仅仅是技术，还是艺术 —</strong></p>
<p>有人认为编程是一种熟练工种，也有人把编程说成是艺术创作。这两种意见争论比较激烈。</p>
<p>我们换个工种来看，石匠应该是熟练工种，属于工人，更艺术似乎沾不上边。但正是这些石匠，给我们留下多少文物古迹，如乐山大佛、莫高窟等等。应该说这些石匠给我们留下了无穷的文化财产。</p>
<p>现代软件工业已具相当规模，很多软件的完成需要的是大兵团作战。</p>
<p>一名普通程序员接受编写某一模块的任务后，往往只是写代码，发挥的余地很小。在大项目中，很多程序员只能了解到和自己所编模块相关的很局部的细节，另外还受到开发环境的限制，真的很难体会到自己在从事”艺术”创造，更多的时候是感到自己在从事重体力劳动。有的时候还担心自己苦苦参与的这个项目究竟有没有意义，是不是在同类产品中有竞争力，会不会开发出来以后就因为硬件的发展，操作系统的换代而过时…</p>
<p>我认为编程的工作和石匠比较相似，有很多是技术活甚至是体力活，但编写优秀软件是件很难的事。这两种想法都有片面性，编程应该说两种属性都有。编程不仅仅是技术，也还是艺术。</p>
<p>编程是技术活，才有可能大规模进行，才会有软件工程。也正是编程是艺术，才会有如此多的好产品。</p>
<p>=== END ===</p>
<p>-– 雷军 (ID: Lei Jun) —</p>
<p>… 那一天知道你要走，我们一句话都没有说</p>
<p>-– Blue Wave/DOS v2.20</p>
<ul>
<li>  Origin: West-Point Programmer’s BBS * 86-10-6237-8307 (6:650/27)</li>
</ul>
]]></content>
      <categories>
        <category>摘抄</category>
      </categories>
      <tags>
        <tag>程序员</tag>
        <tag>雷军</tag>
      </tags>
  </entry>
  <entry>
    <title>研究生培养中的马太效应</title>
    <url>/2022/07/24/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%9F%B9%E5%85%BB%E4%B8%AD%E7%9A%84%E9%A9%AC%E5%A4%AA%E6%95%88%E5%BA%94/</url>
    <content><![CDATA[<p>“旱的旱死，涝的涝死”</p>
<span id="more"></span>

<p>最近在上海生科院参与暑期实习，期间和师兄师姐还有很多同级的同学有不少交流，当然也对上海生科院这边的实习轮转情况有了些初步的认识。情况不容乐观。</p>
<p>这种并不乐观的情况，来源于轮转的热门实验室和冷门实验室的差别。当然，再深入思考一点，会发现一些别的东西——例如<a href="https://baike.baidu.com/item/%E9%A9%AC%E5%A4%AA%E6%95%88%E5%BA%94/70100">马太效应</a>这种东西。</p>
<p>在研究生阶段的实习和轮转中，存在一个显著的马太效应：轮转时，实力更强、风评更好的实验室会有更多的人选择，而这些实验室的导师也倾向于从这些学生中选择更好的学生——而风评不佳的实验室在招生时是不挑人的——于是好的实验室越来越好，不好的实验室越来越不好，两极分化愈来愈严重。</p>
<p>这种轮转时的马太效应会对一个刚入学的研究生的未来发展造成巨大影响；除非仅仅是想混个毕业证然后去公司或者选调，否则实验室的好坏会直接影响一个人的学术生涯——注意，本科阶段的学习经历所带来的能力方面的差距会被不同实验室的环境差异迅速抹平。</p>
<p>这其实对现阶段我的实习和轮转生活有一定的启发和警示作用。当时放弃西湖大学的一个原因是认为自己凭借足够高的考研分数，在SINH可以得到老师们更好的待遇，可以更轻松的选择更好的老师。然而，即使是SINH，轮转期间的竞争依然激烈，而仅仅期望考研分数而躺平的后果是本科优势被迅速拉平与超越——而我，可能还没有做好未来去工商界或者政界的准备。</p>
<p>竞争确实是一个残酷的事情；尤其是当有几十号人争抢所里不到十个的计算生物学实验室时——虽然我确实不喜欢竞争，虽然如果在资源足够丰富的情况下，我更愿意混吃等死——但这种情况下，可能还是得直面这种激烈而残酷的竞争吧。</p>
<hr>
<hr>
<blockquote>
<p>旧评论系统备份：</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Eamon(2022-07-31 02:02:22):</span><br><span class="line">	我就是那种“混子”😉</span><br><span class="line">	你敢想，我至今一个导师都没联系过😏</span><br><span class="line"></span><br><span class="line">&gt; WarrenZhang(2022-07-31 10:16:57):</span><br><span class="line">&gt; 	樊总说笑了😂毕竟樊总足够强，不用等暑期轮转也可以选择更好的老师（PS：你咋两点还没睡🐶）</span><br><span class="line">&gt;</span><br><span class="line">&gt; Eamon(2022-09-02 23:37:10):</span><br><span class="line">&gt;	然后现在真的没人要我啦呜呜呜呜呜呜呜</span><br><span class="line">&gt;</span><br><span class="line">&gt; WarrenZhang(2022-09-04 10:49:55):</span><br><span class="line">&gt;	呜呜</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>杂思</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>轮转实习</tag>
        <tag>马太效应</tag>
      </tags>
  </entry>
  <entry>
    <title>第一批 00 后的奔二体验</title>
    <url>/2020/05/14/%E7%AC%AC%E4%B8%80%E6%89%B9-00-%E5%90%8E%E7%9A%84%E5%A5%94%E4%BA%8C%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<p>知乎上有个问题，叫做“作为第一批 00 后，奔二是什么体验？”</p>
<p>这是我对这个问题的一篇回答，一篇写于深夜的回答。</p>
<span id="more"></span>

<p>时间过得真的很快，不知不觉就奔二了。今年又是极为特殊的一年，一直在家上网课，学习效果不是很理想。</p>
<p>上大学以来，我能感觉到自己在慢慢变得浑浑噩噩。中学时有老师和家长的监督，同龄人的压力，让自己静下心学习是一件比较容易的事情，但是到了大学没人管我，反而开始松懈。我知道这样不对，但是很难约束自己。这次疫情的爆发也使得这个缺点无限放大。我很怕自己前面12年的努力最终白费。</p>
<p>高中时生物成绩很好，也有竞赛的底子，所以不顾知乎上生化环材的劝退，报了某华北985高校的天坑专业。可是，当我真的进入这个专业，才发现和我的梦想不太一样。读书太苦，诱惑太多，越来越难让自己静下心来读书，专业课的学习基本上在吃高中竞赛的底子。要说学到了什么，估计只有大一下半学期自学了一点linux系统入门知识，离实际应用差了很远。</p>
<p>其实我对未来一直是很迷茫的。进入大学时，给自己定了目标，是考研/推免到国内top1高校。后来觉得编程有意思，又想转行当码农。之后又想过往生物信息学方向发展。然后发现周围的同学都在考雅思托福准备出国，又想跟风一波。我内心其实很抵触出国留学，因为学外语让我很痛苦，而出国对我个人适应环境的能力以及家庭经济条件要求很高。今年年底就大三了，转专业这条路恐怕走不通了，还是专心学习专业课，以后读个想点样的研究生吧。</p>
<p>其实我中学时，光顾着提高成绩，人际交往这一块不太看重，导致现在还有点“情商低”“思想单纯”。初中时班级搞过匿名投票选取不受欢迎的人，我赫然在位；高中时班级同学遇到事情喜欢拿我开涮，动不动还因为一些事情黑我，但是我无法辩解，自己的思想水平被别人碾压，只有被别人看笑话的份。我自认为自己心很大，什么事情都看得很开，但是我却一直没有朋友，就连那种可以随时说上两句话的同学都很少，更别提对象了。高中时也有一些特别的经历，但是我不敢写出来，我怕会对我造成不太好的影响。总之，我现在的性格，就是可以和关系比较近的人好好相处，一副人畜无害的模样，但是一旦关系再进一点，我会各种“作”，直接把关系搞僵。因此伤害过一些人，我也很对不起他们。但是我，真的很孤独。</p>
<p>高考结束的那个暑假，接触到了知乎、b站、微博等平台，最终前两个平台留下了我。少不更事，经常被知乎上一些回答所吸引，也看过不少“如何提高情商”“如何与他人处好关系”“如何让异性对自己的好感增加”等问题，但是感觉并没有什么用，反而是我自己花费了大量时间在上面。为了避免沉迷于此，也曾试着用fooview悬浮球的自定义任务功能写过一个防沉迷脚本，但是收效甚微。当别的同学在学习、参加社团活动、参加各种评比、考证、参与社会实践时，我依然在无聊的刷知乎，看b站，继续荒废自己的青春。</p>
<p>抱歉写了这么多带负面情绪的内容。人生规划我还是没想好，估计以后会随波逐流，按部就班读完本科、研究生，之后去药企或者生物公司找份工作，再不济回家乡当老师。前几天看了b站《后浪》，并没有特别深的感触，但是知乎的讨论让我觉得有意思。我觉得自己大概率不是视频中后浪的一员吧，但是我会尽可能的去努力活着，不求未来大富大贵，但求过上安稳日子，再有个家。知乎上“内卷”“割韭菜”之类的言论听过不少，曾经觉得是真理，现在看来不是，至少信这个会让我主观上放弃正在做的努力。还没进入社会，为什么不能趁这个机会再提升自己点呢？</p>
]]></content>
      <categories>
        <category>杂思</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
        <tag>日记</tag>
        <tag>知乎回答</tag>
        <tag>零零后</tag>
      </tags>
  </entry>
  <entry>
    <title>网易云音乐随机听歌组件</title>
    <url>/2022/08/20/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E9%9A%8F%E6%9C%BA%E5%90%AC%E6%AD%8C%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>本文实现了一种网易云音乐随机听歌的组件</p>
<span id="more"></span>

<p>网易云音乐一直提供外链播放器，这为博客系统的搭建带来了新组件。</p>
<p>然而，官方的插件只能播放一首音乐，而如果我们想要实现随机听音乐的效果，就只能靠自己魔改代码了。</p>
<p>先来分析一下网易云音乐的外链播放器组件。我们在网易云音乐网页版中，选取一首歌曲，在歌曲页面中点击<strong>“生成外链播放器”</strong>，可以得到一串外链播放器的代码，如下所示（以一首《卡农》为例）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">marginwidth</span>=<span class="string">&quot;0&quot;</span> <span class="attr">marginheight</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">330</span> <span class="attr">height</span>=<span class="string">86</span> <span class="attr">src</span>=<span class="string">&quot;https://music.163.com/outchain/player?type=2&amp;id=29414800&amp;auto=0&amp;height=66&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这段代码嵌入到网页中，则会是下面的效果：</p>
<p>这个组件实现了音乐播放功能，但是只能循环播放一首音乐。我们想播放多首音乐，怎么办？</p>
<p>先来分析上面这段代码吧。可以看到，这段代码定义了一个<code>iframe</code>框架，其中<code>border/width/height</code>等属性是对框架长宽和边框等的设置，而能让我们听歌的关键在于最后的那一段<code>src</code>链接。</p>
<p>那么我们看一下这个链接：<code>https://music.163.com/outchain/player?type=2&amp;id=29414800&amp;auto=0&amp;height=66</code></p>
<p>链接通过GET传参，定义了四个参数，分别是<code>type/id/auto/height</code>。研究了一下发现，id是音乐的标识符，auto定义了是否允许自动播放（0为不允许，1为允许），height定义了播放器高度。那么如果我们想播放多首音乐，只要改变id的参数就行了。</p>
<hr>
<p><strong>下面上代码，一共分三块。</strong></p>
<p><strong>第一块是HTML，这里定义了一个iframe框架和一个按钮，包在一个div里面。</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;MusicPlayer&#x27;</span> <span class="attr">style</span>=<span class="string">&quot;width:100%;height:100%;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;mp-content&#x27;</span> <span class="attr">style</span>=<span class="string">&quot;width:100%;height:auto;&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--replace this xml with netease iframe--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&#x27;mp-shuffle-btn&#x27;</span> <span class="attr">onclick</span>=<span class="string">&#x27;shuffle(&quot;1&quot;);&#x27;</span>&gt;</span>切歌<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>第二块是JavaScript代码，实现了随机切歌的功能</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> lastIndex = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 下面定义了一个数组mList，这个数组的每个元素均为一首音乐的id，注释后面是乐曲名</span></span><br><span class="line"><span class="keyword">var</span> mList=[</span><br><span class="line"><span class="string">&#x27;1492283139&#x27;</span>,<span class="comment">//疾如猛火</span></span><br><span class="line"><span class="string">&#x27;1392438000&#x27;</span>,<span class="comment">//Raindrop</span></span><br><span class="line"><span class="string">&#x27;1910966474&#x27;</span>,<span class="comment">//华灯星聚</span></span><br><span class="line"><span class="string">&#x27;5197160&#x27;</span>,<span class="comment">//Proud of you</span></span><br><span class="line"><span class="string">&#x27;1645112&#x27;</span>,<span class="comment">//For River(Johnny Version)</span></span><br><span class="line"><span class="string">&#x27;5284529&#x27;</span>,<span class="comment">//祝福-叶倩文</span></span><br><span class="line"><span class="string">&#x27;757757&#x27;</span>,<span class="comment">//朝(早晨)-ゴンチチ</span></span><br><span class="line"><span class="string">&#x27;28219176&#x27;</span>,<span class="comment">//虹之间</span></span><br><span class="line"><span class="string">&#x27;29097535&#x27;</span>,<span class="comment">//彩蝶舞夏</span></span><br><span class="line"><span class="string">&#x27;5188837&#x27;</span>,<span class="comment">//卡农-1</span></span><br><span class="line"><span class="string">&#x27;478507889&#x27;</span>,<span class="comment">//卡农-2</span></span><br><span class="line"><span class="string">&#x27;1439409941&#x27;</span>,<span class="comment">//Rainbow Mile</span></span><br><span class="line"><span class="string">&#x27;569214126&#x27;</span>,<span class="comment">//可能否</span></span><br><span class="line"><span class="string">&#x27;27946926&#x27;</span>,<span class="comment">//Positive Outlook</span></span><br><span class="line"><span class="string">&#x27;1645140&#x27;</span><span class="comment">//To the moon(Ending Version)</span></span><br><span class="line">]</span><br><span class="line"><span class="comment">// 一首歌曲的id可以通过网易云音乐网页版获取</span></span><br><span class="line"><span class="comment">// 查看方法为在网易云音乐网页版里，点进一首歌的主页，然后读取浏览器地址栏里面的URL</span></span><br><span class="line"><span class="comment">// 此时的URL里会有一个&quot;id=xxxxx&quot;，这里就是音乐的id。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来我们定义一个切歌的函数，其中auto参数指定是否允许随机播放</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shuffle</span>(<span class="params">auto</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> mlen  = mList.<span class="property">length</span>;        </span><br><span class="line"><span class="keyword">var</span> index = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">100000</span>%mlen); <span class="comment">// 随机取下标</span></span><br><span class="line"><span class="keyword">if</span>(index==lastIndex)&#123; <span class="comment">// 如果下标取重了（随机选到的歌曲和当前播放的相同）</span></span><br><span class="line"><span class="keyword">if</span>(index+<span class="number">1</span>&lt;mlen) index += <span class="number">1</span>; <span class="comment">// 则切换到播放列表的下一首歌</span></span><br><span class="line"><span class="keyword">else</span> index = <span class="number">0</span>; <span class="comment">// 如果正在播放最后一首歌，那么切换到第一首歌</span></span><br><span class="line">&#125;</span><br><span class="line">lastIndex = index;</span><br><span class="line"><span class="keyword">var</span> mID  = mList[index];</span><br><span class="line"><span class="keyword">var</span> mXML = <span class="string">&#x27;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=100% height=92 paddingwidth=&quot;0&quot; src=&quot;https://music.163.com/outchain/player?type=2&amp;id=&#123;&#123;id&#125;&#125;&amp;auto=&#123;&#123;auto&#125;&#125;&amp;height=66&quot;&gt;&lt;/iframe&gt;&#x27;</span>; <span class="comment">//定义iframe框架的代码</span></span><br><span class="line">mXML = mXML.<span class="title function_">replace</span>(<span class="string">&#x27;&#123;&#123;id&#125;&#125;&#x27;</span>,mID);</span><br><span class="line">mXML = mXML.<span class="title function_">replace</span>(<span class="string">&#x27;&#123;&#123;auto&#125;&#125;&#x27;</span>,auto);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mp-content&#x27;</span>).<span class="property">innerHTML</span> = mXML; <span class="comment">//将新iframe代码插入HTML</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">shuffle</span>(<span class="string">&#x27;0&#x27;</span>); <span class="comment">//加载页面时一并载入歌曲，但是自动播放设置为关闭</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>第三段是css样式表，可以帮我们把组件弄得好看一点</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"><span class="selector-id">#mp-shuffle-btn</span>&#123;</span><br><span class="line"> <span class="attribute">width</span>:<span class="number">84px</span>;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">42px</span>;</span><br><span class="line"> <span class="attribute">float</span>: right;</span><br><span class="line"> <span class="attribute">margin</span>: <span class="number">0px</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> ;</span><br><span class="line"> <span class="attribute">border</span>: <span class="number">0px</span>;</span><br><span class="line"> <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">0px</span> <span class="number">0</span> <span class="number">0px</span>;</span><br><span class="line"> <span class="attribute">background-color</span>: <span class="number">#046c99</span>;</span><br><span class="line"> <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line"> <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line"> <span class="attribute">font-weight</span>: bold;</span><br><span class="line"> <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">0px</span> <span class="number">4px</span> <span class="built_in">rgba</span>(<span class="number">127</span>,<span class="number">127</span>,<span class="number">198</span>,<span class="number">0.5</span>);</span><br><span class="line"> <span class="attribute">cursor</span>: pointer;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="selector-id">#mp-shuffle-btn</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">background-color</span>: <span class="number">#0587bf</span>;&#125; </span><br><span class="line"><span class="selector-id">#mp-shuffle-btn</span><span class="selector-pseudo">:active</span> &#123;<span class="attribute">background-color</span>: <span class="number">#0587bf</span>;&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p><strong>使用时把这三段代码放在一起，粘贴到网页内既可。</strong></p>
<p>实际使用效果：</p>
<html>
<!-- wp:html -->
<div id="MusicPlayer-2" style="width:100%;height:100%;display:block;">
    <div id="mp-content-2" style="width:100%;height:auto;">
        <!--replace this xml with netease iframe-->
    </div>
    <button id="mp-shuffle-btn-2" onclick="shuffle_2('1');">切歌</button>
</div>
<script>
    var lastIndex = -1;
    var mList=[
        '1492283139',    //疾如猛火
        '1392438000',    //Raindrop
        '1910966474',    //华灯星聚
        '5197160',    //Proud of you
        '1645112',    //For River(Johnny Version)
        '5284529',    //祝福-叶倩文
        '757757',    //朝(早晨)-ゴンチチ
        '28219176',    //虹之间
        '29097535',    //彩蝶舞夏
        '5188837',    //卡农-1
        '478507889',    //卡农-2
        '1439409941',    //Rainbow Mile
        '569214126',    //可能否
        '27946926',    //Positive Outlook
        '1645140'    //To the moon(Ending Version)
    ]
    function shuffle_2(auto){    
        var mlen  = mList.length;        // len of music array
        var index = Math.floor(Math.random()*100000%mlen); // random index
        if(index==lastIndex){
            if(index+1<mlen) index += 1;
            else index = 0;
        }
        lastIndex = index;
        var mID  = mList[index];
        var mXML = '<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=92 paddingwidth="0" src="https://music.163.com/outchain/player?type=2&id=250&auto=&height=66"></iframe>';
        mXML = mXML.replace('250',mID);
        mXML = mXML.replace('',auto);
        document.getElementById('mp-content-2').innerHTML = mXML;
    }
    shuffle_2('0'); //加载页面时一并载入歌曲，但是自动播放设置为关闭
</script>
<style>
#mp-shuffle-btn-2{
 width:84px;
 height: 42px;
 float: right;
 margin: 0px 0 0 0 ;
 border: 0px;
 padding: 0 0px 0 0px;
 /*background-color: rgb(11, 153, 122);*/
 background-color: #046c99;
 color: #fff;
 font-size: 16px;
 font-weight: bold;
 box-shadow: 0px 0px 4px rgba(127,127,198,0.5);
 cursor: pointer;
 }
#mp-shuffle-btn-2:hover {background-color: #0587bf;} 
#mp-shuffle-btn-2:active {background-color: #0587bf;}
</style>
<!-- /wp:html -->
</html>


<hr>
<p>（PS：另一个小组件，随机句子切换，可以查看我朋友Eamon的<a href="https://www.fanyiming.life/posts/b7af6d70.html">博客文章</a>）</p>
<p>（PPS：我发现如果把iframe里面的URL修改一下，把type设置为0，id设置为歌单id，height加高100px，变成 <code>https://music.163.com/outchain/player?type=0&amp;id=774883428&amp;auto=0&amp;height=166</code> 这个样子，则可以播放歌单里面的音乐，还能选歌，感觉好神奇😂）</p>
<hr>
<hr>
<blockquote>
<p>旧评论系统备份：</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">WarrenZhang(2022-09-08 19:56:49):</span><br><span class="line">	评论区放个链接：https://music.163.com/outchain/player?type=0&amp;id=2444388851&amp;auto=0&amp;height=166</span><br><span class="line">	这个歌单是我自己的，不过网易云音乐的外链好像只能展示前十首音乐qwq</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>网易云音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>考研日记day47</title>
    <url>/2021/11/04/%E8%80%83%E7%A0%94%E6%97%A5%E8%AE%B0day47/</url>
    <content><![CDATA[<p>记录考研期间的心路历程</p>
<span id="more"></span>

<p>接连一个星期的阴天，今天中午终于出了点太阳。</p>
<p>虽然天空依然有些阴霾，阳光也没有夏天那种明亮与温暖，但不管怎么说，至少再一次看到太阳了。</p>
<p>天津的纬度有点高，即使在中午，太阳也是斜斜地照在大地上，让我想到了萧瑟的冬季。</p>
<p>又有点想家了。</p>
<p>一个人复习的孤独感，担心考不上研和一些其他事情的焦虑感，让我的心态一直不太稳定。</p>
<p>我觉得自己需要一个break。</p>
<p>虽然上周末宣称给自己一个break，但那天的天气不太好，回到学校后心情也是压抑的。</p>
<p>不应该。</p>
<hr>
<p>今天下午去听考研经验分享会了，计划的学习任务没有全部完成。</p>
<p>关于考研经验分享会，其实我感觉没得到多少有用的东西。</p>
<p>考研这件事在我的印象里，依然保留有两个标签：1、概率事件（能不能上岸全凭概率，复习程度只不过让概率有所变化而已）。2、二值问题（要么第一志愿录取，要么考不上，考研没有六个平行志愿之说）</p>
<p>所以无论是陈佺院长的建议，还是南开研一新生的经验分享，其实都是在围绕第一个点，如何复习以提高概率。陈佺院长甚至举了当年自己同学的例子，告诉我们是否考上研究生对于人生道路的重要影响（有研究生读的现在基本都在高校研究所；没考上的去中学教书去了……）。</p>
<p>其他的，关于时间分配，关于心态调整，关于考前押题，关于肖四肖八，这都不重要。</p>
<p>我觉得分享会最多提醒了我一个点，就是专业课方面的问题，我可以问一问那些专业老师，帮助强化一下自己的专业课复习情况。</p>
<p>希望最后能得到一个好结果吧。</p>
<p>祝好。</p>
<p><img src="https://pic.imgdb.cn/item/6540f14ac458853aeffd615c.jpg" alt="sunlight in the late autumn"></p>
<p>图：晚秋的阳光</p>
]]></content>
      <categories>
        <category>杂思</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>考研复试</title>
    <url>/2022/03/29/%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95/</url>
    <content><![CDATA[<p>今天结束了考研复试。</p>
<p>晚上已经收到了拟录取通知。兜兜转转大半年，终于考研上岸了。</p>
<p>心情没有很激动。确实和wjz前几天所说的那样，很平静。</p>
<span id="more"></span>

<p>复盘从去年9月14日到今天的大半年时光，倒是可以总结出一些经验，例如规划很重要、语言学习需要坚持不懈。但是考研后半段在感情上的痛苦经历，使我常常不敢回忆太多。以及，从12月31号开始，我似乎就在一种摆烂的状态下度过了三个多月。</p>
<p>考研期间需要感谢的人有吗？当然有，很多。谢谢实验室的各位老师和师兄师姐在我备考前期提供的信息，谢谢何老师在推荐信方面的帮忙，谢谢研友们帮我找到的的院校分数线和考试科目信息，谢谢琳姐还有生科院一群可爱的学弟学妹的支持和鼓励。说实在的，考研期间真的很压抑，一些微小的关心却如春风般温暖过我的内心。考研分享会上收到的学弟学妹们亲手写下的祝福，初试前两天中航物业的哥哥姐姐送来的鼓励，这些都令我感动。</p>
<p>时至如今，确实有了一种拨开云雾见月明的感觉。至少上岸了，至少我的成绩还不差，不是吗？虽然确实，考研的学校和身边的很多同学相比，还是差了一点。</p>
<p>考研初试结束后，那个人和我说要开启新阶段了。不过在我看来，可能真正的新阶段应该从现在才能算起。过去的那些事就当他们都过去了，一切都还要朝前看。所以，皖豫兄，可否重拾当年的精气神，重新整装再出发？</p>
]]></content>
      <categories>
        <category>杂思</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>考研复试</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次手动安装perl模块的经历</title>
    <url>/2022/05/15/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85perl%E6%A8%A1%E5%9D%97%E7%9A%84%E7%BB%8F%E5%8E%86/</url>
    <content><![CDATA[<p>perl是一个较为常见的脚本执行程序，但是由于我之前用得比较少，对其了解不多。  </p>
<p>最近碰到了一个问题需要解决。是这样的，我想用C++写一个程序，实现百度开放API提供的翻译功能。在编译安装libcurl库以后，发现还有一个md5的函数需要openssl提供。由于我在网上找到的预编译的openssl库的lib文件有点问题，于是想着自己编译。</p>
<span id="more"></span>

<p>openssl提供的说明文档中指出，如果想用mingw编译，需要使用带有perl的msys2终端。我没有这个终端，于是用了git-bash代替。然而系统中安装的strawberry perl不能用（提示无法处理UNIX-Like的文件路径），而strawberry perl又与git-bash的perl冲突，因此手动修改了系统的环境变量$PATH，把strawberry perl的路径给删掉了。</p>
<p>这样以后，执行./Configure ming64依然不行，提示缺少几个perl的模块。于是有了本文的主题：手动安装perl模块。</p>
<p>要说一下，git-bash的perl很残废，连cpan运行都出错。因此，只能通过手动安装报错中提到的模块，一点一点解决问题。</p>
<p>例如下面这个报错：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ ./Configure mingw64</span><br><span class="line">Configuring OpenSSL version 3.0.2 for target mingw64</span><br><span class="line">Using os-specific seed configuration</span><br><span class="line">Creating configdata.pm</span><br><span class="line">Running configdata.pm</span><br><span class="line">Can&#x27;t locate Pod/Escapes.pm in @INC (you may need to install the Pod::Escapes module) (@INC contains: /usr/lib/perl5/site_perl /usr/share/perl5/site_perl /usr/lib/perl5/vendor_perl /usr/share/perl5/vendor_perl /usr/lib/perl5/core_perl /usr/share/perl5/core_perl) at /usr/lib/perl5/vendor_perl/Pod/Simple.pm line 8.</span><br><span class="line">BEGIN failed--compilation aborted at /usr/lib/perl5/vendor_perl/Pod/Simple.pm line 8.</span><br><span class="line">Compilation failed in require at /usr/lib/perl5/vendor_perl/Pod/Simple/Methody.pm line 5.</span><br><span class="line">BEGIN failed--compilation aborted at /usr/lib/perl5/vendor_perl/Pod/Simple/Methody.pm line 5.</span><br><span class="line">Compilation failed in require at /usr/lib/perl5/vendor_perl/Pod/Text.pm line 6.</span><br><span class="line">BEGIN failed--compilation aborted at /usr/lib/perl5/vendor_perl/Pod/Text.pm line 6.</span><br><span class="line">Compilation failed in require at (eval 8) line 1.</span><br><span class="line">BEGIN failed--compilation aborted at /usr/lib/perl5/vendor_perl/Pod/Usage.pm line 30.</span><br><span class="line">Compilation failed in require at configdata.pm line 30297.</span><br><span class="line">BEGIN failed--compilation aborted at configdata.pm line 30297.</span><br></pre></td></tr></table></figure>

<p>提示缺少<code>Pod::Escape</code>模块，同时指出了几个perl的library路径。我们选择将模块安装到<code>/usr/lib/perl5/vendor_perl</code>路径下面。  </p>
<p>在清华大学TUNA镜像站中找到CPAN，在这里寻找需要的模块。CPAN的所有模块列在了网页  <a href="https://mirrors.tuna.tsinghua.edu.cn/CPAN/modules/01modules.index.html">https://mirrors.tuna.tsinghua.edu.cn/CPAN/modules/01modules.index.html</a> 当中。由于页面太长，推荐在命令行中配合grep搜索指定模块的下载链接。</p>
<p>还是以上面这个模块为例，我们找到链接为  </p>
<p><a href="http://mirrors.tuna.tsinghua.edu.cn/CPAN/authors/id/N/NE/NEILB/Pod-Escapes-1.07.tar.gz">http://mirrors.tuna.tsinghua.edu.cn/CPAN/authors/id/N/NE/NEILB/Pod-Escapes-1.07.tar.gz</a></p>
<p>下载下来并解压，将压缩包里的<code>lib</code>下面的东西copy到<code>/usr/lib/perl5/vendor_perl</code>下面。</p>
<p>大部分缺失的perl模块可以通过这种方式得到安装。少部分模块可能直接搜索名字搜索不到，但是通过<code>cpan install</code>可以知道去下载哪个压缩包。</p>
<p>在编译libopenssl的过程中，perl主要用于configuration和复制一些文件，主要的编译工作依然是交给<code>gcc</code>完成。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>Windows系统使用技巧</tag>
        <tag>perl</tag>
      </tags>
  </entry>
  <entry>
    <title>设置vim代码编辑器的一键编译运行功能</title>
    <url>/2023/10/25/%E8%AE%BE%E7%BD%AEvim%E4%B8%80%E9%94%AE%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>对于计算生物学研究者来说，Vim编辑器是一个不可缺少的工具。特别是在Linux服务器上，由于缺乏必要的图形界面，代码编写工作需要借助终端完成，此时vim的重要性就体现出来了。</p>
<p>vim的下载安装不再赘述，vim的入门教程网上也都有（也可以通过 <code>vimtutor</code> 指令进入交互式vim学习教程）。此处介绍一点高级知识：为vim代码编辑器添加一键编译运行的功能。</p>
<span id="more"></span>

<p>具体来说，就是在vim编辑器内，按下键盘上的F5按键直接编译代码，按F6按键直接运行代码。添加这一功能可以方便程序的调试，省去了退出程序再运行代码的麻烦。</p>
<p>一个例子：</p>
<p><img src="https://pic.imgdb.cn/item/6541022bc458853aef3ed3d5.jpg" alt="vim compiler"></p>
<p>我们在编辑helloworld.py这个python文件。此时直接按下F6按钮，这个python文件就会直接执行，并输出对应的结果：</p>
<p><img src="https://pic.imgdb.cn/item/65410245c458853aef3f418f.jpg" alt="vim result"></p>
<p>如何才能实现这一效果呢？</p>
<h2 id="（一）-vim-script介绍"><a href="#（一）-vim-script介绍" class="headerlink" title="（一） vim script介绍"></a>（一） vim script介绍</h2><p>Vimscript是Vim编辑器自带的脚本语言，也被称为Vim脚本。它是一种动态命令式语言，具备大多数常见的语言特性，如变量、表达式、控制结构、内置函数和用户定义函数等。</p>
<p>Vimscript主要用于编 写Vim的配置文件和插件，用户可以通过编写Vim脚本来定制Vim的行为和功能，使其更加符合个人的使用习惯和需求。</p>
<p>我们将通过编写vim script函数，实现上述一键执行的功能</p>
<p>要想了解更多vim script的相关知识，可以参考vim的官方教程：</p>
<ul>
<li><a href="https://vimdoc.sourceforge.net/htmldoc/usr_41.html">https://vimdoc.sourceforge.net/htmldoc/usr_41.html</a></li>
</ul>
<p>以及各种中文教程：</p>
<ul>
<li><a href="https://www.w3cschool.cn/vim/ljkpbozt.html">https://www.w3cschool.cn/vim/ljkpbozt.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/37352209">https://zhuanlan.zhihu.com/p/37352209</a></li>
</ul>
<h2 id="（二）vimrc文件"><a href="#（二）vimrc文件" class="headerlink" title="（二）vimrc文件"></a>（二）vimrc文件</h2><p>有多种方法可以执行vim script的脚本，但是如果能让vim在每次启动时自动执行脚本，从而开启一键执行的函数，则会方便很多。包含vim程序初始化命令的文件称为“ vimrc”文件，我们可以将自定义的函数放在这里以实现自动加载。</p>
<p>vimrc文件的位置根据操作系统的不同而略有差异，但基本都是固定的。下面是官方文档给出的vimrc文件位置：</p>
<table>
<thead>
<tr>
<th>Operating system</th>
<th><code>vimrc</code> file path</th>
</tr>
</thead>
<tbody><tr>
<td>Linux和macOS</td>
<td><code>$HOME/.vimrc</code></td>
</tr>
<tr>
<td>MS-DOS和Windows</td>
<td><code>$HOME/_vimrc</code> 或 <code>$VIM/_vimrc</code></td>
</tr>
</tbody></table>
<p>其中，<code>$HOME</code>代表用户目录：</p>
<ul>
<li>在Linux上一般是<code>/home/&lt;username&gt;/</code>，</li>
<li>在macOS上一般是<code>/Users/&lt;username&gt;/</code> ，</li>
<li>在Windows上一般是<code>C:\Users\&lt;username&gt;\</code>，<br>（<code>&lt;username&gt;</code>代表用户名）</li>
</ul>
<p>有时候，vimrc文件可能预先并不存在，我们可以在上述位置新建一个同名的文本文件作为vimrc文件。</p>
<h2 id="（三）编写自动执行代码的函数"><a href="#（三）编写自动执行代码的函数" class="headerlink" title="（三）编写自动执行代码的函数"></a>（三）编写自动执行代码的函数</h2><p>下面直接给出vimscript代码。这些代码直接粘贴到vimrc文件中，即可实现我们想要的功能</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">func! CompileGcc()</span><br><span class="line">    exec <span class="string">&quot;w&quot;</span></span><br><span class="line">    <span class="keyword">let</span> compilecmd=<span class="string">&quot;!gcc &quot;</span></span><br><span class="line">    <span class="keyword">let</span> compileflag=<span class="string">&quot;-o %&lt; &quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">search</span>(<span class="string">&quot;mpi\.h&quot;</span>) != <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> compilecmd = <span class="string">&quot;!mpicc &quot;</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">search</span>(<span class="string">&quot;glut\.h&quot;</span>) != <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> compileflag .= <span class="string">&quot; -lglut -lGLU -lGL &quot;</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">search</span>(<span class="string">&quot;cv\.h&quot;</span>) != <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> compileflag .= <span class="string">&quot; -lcv -lhighgui -lcvaux &quot;</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">search</span>(<span class="string">&quot;omp\.h&quot;</span>) != <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> compileflag .= <span class="string">&quot; -fopenmp &quot;</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">search</span>(<span class="string">&quot;math\.h&quot;</span>) != <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> compileflag .= <span class="string">&quot; -lm &quot;</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    exec compilecmd.<span class="string">&quot; % &quot;</span>.compileflag</span><br><span class="line">endfunc</span><br><span class="line">func! CompileGpp()</span><br><span class="line">    exec <span class="string">&quot;w&quot;</span></span><br><span class="line">    <span class="keyword">let</span> compilecmd=<span class="string">&quot;!g++ &quot;</span></span><br><span class="line">    <span class="keyword">let</span> compileflag=<span class="string">&quot;-o %&lt; &quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">search</span>(<span class="string">&quot;mpi\.h&quot;</span>) != <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> compilecmd = <span class="string">&quot;!mpic++ &quot;</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">search</span>(<span class="string">&quot;glut\.h&quot;</span>) != <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> compileflag .= <span class="string">&quot; -lglut -lGLU -lGL &quot;</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">search</span>(<span class="string">&quot;cv\.h&quot;</span>) != <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> compileflag .= <span class="string">&quot; -lcv -lhighgui -lcvaux &quot;</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">search</span>(<span class="string">&quot;omp\.h&quot;</span>) != <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> compileflag .= <span class="string">&quot; -fopenmp &quot;</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">search</span>(<span class="string">&quot;math\.h&quot;</span>) != <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> compileflag .= <span class="string">&quot; -lm &quot;</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    exec compilecmd.<span class="string">&quot; % &quot;</span>.compileflag</span><br><span class="line">endfunc</span><br><span class="line"></span><br><span class="line">func! RunPython()</span><br><span class="line">        exec <span class="string">&quot;!python %&quot;</span></span><br><span class="line">endfunc</span><br><span class="line">func! CompileJava()</span><br><span class="line">    exec <span class="string">&quot;!javac %&quot;</span></span><br><span class="line">endfunc</span><br><span class="line"></span><br><span class="line">func! RunRscript()</span><br><span class="line">        exec <span class="string">&quot;!Rscript %&quot;</span></span><br><span class="line">endfunc</span><br><span class="line"></span><br><span class="line">func! RunBash()</span><br><span class="line">        exec <span class="string">&quot;!bash %&quot;</span></span><br><span class="line">endfunc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func! CompileCode()</span><br><span class="line">        exec <span class="string">&quot;w&quot;</span></span><br><span class="line">        <span class="keyword">if</span> &amp;<span class="keyword">filetype</span> == <span class="string">&quot;cpp&quot;</span></span><br><span class="line">                exec <span class="string">&quot;call CompileGpp()&quot;</span></span><br><span class="line">        <span class="keyword">elseif</span> &amp;<span class="keyword">filetype</span> == <span class="string">&quot;c&quot;</span></span><br><span class="line">                exec <span class="string">&quot;call CompileGcc()&quot;</span></span><br><span class="line">        <span class="keyword">elseif</span> &amp;<span class="keyword">filetype</span> == <span class="string">&quot;python&quot;</span></span><br><span class="line">                exec <span class="string">&quot;call RunPython()&quot;</span></span><br><span class="line">        <span class="keyword">elseif</span> &amp;<span class="keyword">filetype</span> == <span class="string">&quot;sh&quot;</span></span><br><span class="line">                exec <span class="string">&quot;call RunBash()&quot;</span></span><br><span class="line">        <span class="keyword">elseif</span> &amp;<span class="keyword">filetype</span> == <span class="string">&quot;r&quot;</span></span><br><span class="line">                exec <span class="string">&quot;call RunRscript()&quot;</span></span><br><span class="line">        <span class="keyword">elseif</span> &amp;<span class="keyword">filetype</span> == <span class="string">&quot;java&quot;</span></span><br><span class="line">                exec <span class="string">&quot;call CompileJava()&quot;</span></span><br><span class="line">        <span class="keyword">endif</span></span><br><span class="line">endfunc</span><br><span class="line"></span><br><span class="line">func! RunResult()</span><br><span class="line">        exec <span class="string">&quot;w&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">search</span>(<span class="string">&quot;mpi\.h&quot;</span>) != <span class="number">0</span></span><br><span class="line">            exec <span class="string">&quot;!mpirun -np 4 ./%&lt;&quot;</span></span><br><span class="line">        <span class="keyword">elseif</span> &amp;<span class="keyword">filetype</span> == <span class="string">&quot;cpp&quot;</span></span><br><span class="line">            exec <span class="string">&quot;! ./%&lt;&quot;</span></span><br><span class="line">        <span class="keyword">elseif</span> &amp;<span class="keyword">filetype</span> == <span class="string">&quot;c&quot;</span></span><br><span class="line">            exec <span class="string">&quot;! ./%&lt;&quot;</span></span><br><span class="line">        <span class="keyword">elseif</span> &amp;<span class="keyword">filetype</span> == <span class="string">&quot;python&quot;</span></span><br><span class="line">            exec <span class="string">&quot;call RunPython()&quot;</span></span><br><span class="line">        <span class="keyword">elseif</span> &amp;<span class="keyword">filetype</span> == <span class="string">&quot;sh&quot;</span></span><br><span class="line">            exec <span class="string">&quot;call RunBash()&quot;</span></span><br><span class="line">        <span class="keyword">elseif</span> &amp;<span class="keyword">filetype</span> == <span class="string">&quot;r&quot;</span></span><br><span class="line">            exec <span class="string">&quot;call RunRscript()&quot;</span></span><br><span class="line">        <span class="keyword">elseif</span> &amp;<span class="keyword">filetype</span> == <span class="string">&quot;java&quot;</span></span><br><span class="line">            exec <span class="string">&quot;!java %&lt;&quot;</span></span><br><span class="line">        <span class="keyword">endif</span></span><br><span class="line">endfunc</span><br><span class="line"></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;F5&gt;</span> :<span class="keyword">call</span> CompileCode()<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">imap</span> <span class="symbol">&lt;F5&gt;</span> <span class="symbol">&lt;ESC&gt;</span>:<span class="keyword">call</span> CompileCode()<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">vmap</span> <span class="symbol">&lt;F5&gt;</span> <span class="symbol">&lt;ESC&gt;</span>:<span class="keyword">call</span> CompileCode()<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;F6&gt;</span> :<span class="keyword">call</span> RunResult()<span class="symbol">&lt;CR&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="（四）一些知识点和补充说明"><a href="#（四）一些知识点和补充说明" class="headerlink" title="（四）一些知识点和补充说明"></a>（四）一些知识点和补充说明</h2><h3 id="1、按键绑定"><a href="#1、按键绑定" class="headerlink" title="1、按键绑定"></a>1、按键绑定</h3><p>参考： </p>
<ul>
<li><a href="https://vimdoc.sourceforge.net/htmldoc/usr_40.html#40.1">https://vimdoc.sourceforge.net/htmldoc</a></li>
</ul>
<p>上述代码最后四行的目的是完成按键绑定，map、imap、vmap是在vim的不同模式下绑定按键的意思。其中，map是一般模式下的按键绑定；imap是插入模式下的按键绑定；vmap是可视模式下的按键绑定。</p>
<p>按键绑定的格式如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">map &lt;键盘上按下的键&gt; &lt;要实现的组合键&gt;</span><br></pre></td></tr></table></figure>

<p>例如，<code>map &lt;F5&gt; :call CompileCode()&lt;CR&gt;</code> 的意思是，将 <code>&lt;F5&gt;</code> 按键绑定到下面的这一系列组合键：向vim命令行中输入指令<code>:call CompileCode()</code>，然后按下回车（就是执行<code>CompileCode()</code>这个函数）。</p>
<p>同样的， </p>
<p><code>imap &lt;F5&gt; &lt;ESC&gt;:call CompileCode()&lt;CR&gt;</code> 的意思是，在插入模式下，将<code>&lt;F5&gt;</code>按键绑定到下面的这一系列组合键：先按ESC键（退出插入模式），然后执行<code>CompileCode()</code>函数。</p>
<h3 id="2、函数"><a href="#2、函数" class="headerlink" title="2、函数"></a>2、函数</h3><pre><code>不论是CompileCode()还是RunResult()，
本质都是一样的，所以我们挑一个讲。
</code></pre>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">func! CompileCode()</span><br><span class="line">        exec <span class="string">&quot;w&quot;</span></span><br><span class="line">        <span class="keyword">if</span> &amp;<span class="keyword">filetype</span> == <span class="string">&quot;cpp&quot;</span></span><br><span class="line">                exec <span class="string">&quot;call CompileGpp()&quot;</span></span><br><span class="line">        <span class="keyword">elseif</span> &amp;<span class="keyword">filetype</span> == <span class="string">&quot;c&quot;</span></span><br><span class="line">                exec <span class="string">&quot;call CompileGcc()&quot;</span></span><br><span class="line">        <span class="keyword">elseif</span> &amp;<span class="keyword">filetype</span> == <span class="string">&quot;python&quot;</span></span><br><span class="line">                exec <span class="string">&quot;call RunPython()&quot;</span></span><br><span class="line">        <span class="keyword">elseif</span> &amp;<span class="keyword">filetype</span> == <span class="string">&quot;sh&quot;</span></span><br><span class="line">                exec <span class="string">&quot;call RunBash()&quot;</span></span><br><span class="line">        <span class="keyword">elseif</span> &amp;<span class="keyword">filetype</span> == <span class="string">&quot;r&quot;</span></span><br><span class="line">                exec <span class="string">&quot;call RunRscript()&quot;</span></span><br><span class="line">        <span class="keyword">elseif</span> &amp;<span class="keyword">filetype</span> == <span class="string">&quot;java&quot;</span></span><br><span class="line">                exec <span class="string">&quot;call CompileJava()&quot;</span></span><br><span class="line">        <span class="keyword">endif</span></span><br><span class="line">endfunc</span><br></pre></td></tr></table></figure>
<p>首先，<code>exec &quot;w&quot;</code> 就是保存当前文件的意思。先保存文件，然后运行，保证所有修改都能被存下来。</p>
<p>然后根据<code>filetype</code>选择不同的执行函数。</p>
<p><code>filetype</code>是vim中的一个运行时变量，用于标明当前文件的文件类型，详情可以参考 <a href="https://vimdoc.sourceforge.net/htmldoc/usr_43.html">https://vimdoc.sourceforge.net/htmldoc/usr_43.html</a></p>
<p>在vim安装目录的<code>filetype.vim</code>文件中预定义了所有可被vim识别的文件类型。要想知道一个文件在vim中被定义为何种类型的话，可以使用vim打开该文件，然后在命令模式下输入指令</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">set</span> <span class="keyword">filetype</span></span><br></pre></td></tr></table></figure>

<p>然后就可以得到文件类型</p>
<h3 id="3、执行文件"><a href="#3、执行文件" class="headerlink" title="3、执行文件"></a>3、执行文件</h3><p>主要讲一点东西：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">exec <span class="string">&quot;!python %&quot;</span></span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">exec <span class="string">&quot;!java %&lt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>的区别</p>
<p>首先，exec是vimscript里面执行指令的函数，如果指令以英文感叹号”!”开头，则表明这是个shell指令。<br>（ 参考 <a href="https://vimdoc.sourceforge.net/htmldoc/usr_21.html#21.2">https://vimdoc.sourceforge.net/htmldoc/usr_21.html#21.2</a> ）</p>
<p>所以，上面这两行脚本都是执行shell指令的意思，一个是执行python，一个是执行java。</p>
<p>python和java后面跟着的百分比符号 <code>%</code> 则代表当前文件的文件名，不过也有所区别。<code>%</code> 代表文件名，包含文件后缀；而 <code>%&lt;</code> 则仅仅有文件名，不包含文件后缀（如.java或.exe）。这种区分是有用的。例如，在执行java程序时，编译后的java字节码文件一般以<code>&lt;classname&gt;.class</code>命名，但要执行字节码中的程序，使用的指令是<code>java &lt;classname&gt;</code>（没有.class后缀）。去除文件后缀可以方便的实现文件的运行。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>vim</tag>
        <tag>一键编译执行</tag>
      </tags>
  </entry>
  <entry>
    <title>早春游香山：一些记录和一些思索</title>
    <url>/2022/02/26/%E6%97%A9%E6%98%A5%E6%B8%B8%E9%A6%99%E5%B1%B1%EF%BC%9A%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95%E5%92%8C%E4%B8%80%E4%BA%9B%E6%80%9D%E7%B4%A2/</url>
    <content><![CDATA[<p>今天和Csh还有Shy一起去了北京香山（之前在生物物理所11楼看到的“北京西山”），算是完成了来IBP以后的一个小心愿。</p>
<p>虽然有点累，但挺快乐的，不是吗？</p>
<p>只不过，在山顶看到的祈福小木牌，让我想起了曾经的很多事情。</p>
<span id="more"></span>

<p>就如去年7月2日在798艺术区里看到的许愿墙一样，很多人希望在新的一年脱单，或者和伴侣幸福长久；当然，也有祈求考研上岸或者事业顺利的小木牌。只不过，当我看到一枚署名是“张帅”的许愿牌，并和朋友说了高中和张帅相爱相杀的故事[1]后，突然觉得，我好像一直都有点问题。</p>
<p>我很想脱单。一直如此，包括现在。然而伴侣对我来说更多的是一个“情绪垃圾桶”的存在，我并没有能力在相互的理解和支持中汲取力量，并用更大的力量支持和保护自己的伴侣。这点已经通过去年年底那段痛苦的经历所验证过了。</p>
<p>当然，在身材方面我好像也没啥吸引力，一直有人说让我减肥，可惜一直没有付诸行动。</p>
<p>回到张帅的问题上。抛开前面的问题不谈，在学习成绩上很明显高中阶段我更占据优势。然而我并没有利用好这方面的优势，去发展人际关系，结交更多志同道合的人。用知识装逼并不是一种好的方式，那只会让你的人际联系越来越糟。保持低调，保持宽厚待人，这样做或许会好点。怎么把握好这个度，我还有点不太会。但至少我发现，身边很多很受欢迎的大佬都具有这样的品格。</p>
<p>另外，如果在生活中我们对一个人产生了好感，我们应该怎么做？反正我之前会选择主动躲避，以避免接触。不过现在我很疑惑一个点：为什么要这样呢？你害怕什么呢？如果没什么可以怕的，那就保持日常接触不就行了吗？感觉自己还是有些问题。</p>
<p>今天在景区和地铁上看到了很多情侣，估计大部分是出来玩的。其实我挺羡慕他们。但是想了想，我好像并没有能力去维持一段稳定的关系。是不是还得再潜心修炼一段时间才行啊。那算了，或许不该继续想这件事了。</p>
<p>以上。</p>
<hr>
<p>**注[1]**：张帅是我的高中同学，他和我在一个竞赛小组，一起准备生物竞赛。只不过那时候，我可能对他并不服气，虽然目标一致，但常常争执，互不服输，是为“相爱相杀”。只可惜没有珍惜这段友谊了。</p>
<hr>
<p>附：一些照片</p>
<p><img src="https://pic.imgdb.cn/item/6540f5f8c458853aef0cdc09.jpg" alt="北京香山"></p>
<p><img src="https://pic.imgdb.cn/item/6540f5d4c458853aef0c65b0.jpg" alt="北五环"></p>
]]></content>
      <categories>
        <category>杂思</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>鸟类胚胎发育阶段序列</title>
    <url>/2022/07/13/%E9%B8%9F%E7%B1%BB%E8%83%9A%E8%83%8E%E5%8F%91%E8%82%B2%E7%9A%84hamburger-hamilton%E5%8F%91%E8%82%B2%E9%98%B6%E6%AE%B5%E5%BA%8F%E5%88%97%EF%BC%88hamburger-hamilton-staging-series%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>一种定义胚胎发育阶段的方法：Hamburger-Hamilton发育阶段序列（Hamburger-Hamilton Staging Series）</p>
</blockquote>
<span id="more"></span>
<p>1951年Viktor Hamburger和Howard Hamilton基于其他研究者的拍照和绘图，将鸡的胚胎发育的过程用一系列胚胎阶段表示，创造出了一个胚胎发育序列（embryonic staging series），即所谓Hamburger-Hamilton Stages。其由46个时间上连续的阶段组成，从受精卵开始，到发育完整的鸡结束。提出这个发育阶段序列的目的是为了取代1900年提出的旧发育阶段序列——这个早期版本缺乏很多细节，并且对发育阶段的分类仅着眼于形态学特征。由于鸡是一种重要的模式动物，创造一个精确的可以用于描述发育阶段的序列是有必要的。<br>Hamburger和Hamilton在创建Hamburger-Hamilton Staging Series时参考了Ross Granville Harrison对摩尔蝾螈（mole salamanders）发育阶段的分级。Harrison在对摩尔蝾螈的发育阶段进行分级时，不是基于胚胎发育的实际时间，而是根据胚胎发育过程中出现的一些特征。Hamburger和Hamilton也想这么做。鸡的发育时间很难测量，因为鸡是体内受精动物，在产卵前鸡胚的发育已经开始，而在产卵后孵化前，鸡胚的发育过程会短暂停滞。鸡蛋的孵化可能在发育的不同阶段开始，而鸡的品种差异、孵育过程中的温度差异都可能对发育时间有影响。</p>
<p>Hamburger和Hamilton没有自己拍摄照片或绘图，他们对其他研究者的照片或绘本进行了汇编，之后在每个发育阶段添加了一小段描述。发育阶段由体节数（number of somites）确定，相邻阶段之间间隔三个体节。体节是一系列中胚层的区块，在脊椎发育过程中按次序萌发，因此可用作发育过程的里程碑。在鸡的品种方面，一共有三种鸡的照片被用于创建这个发育阶段序列： white leghorns, barred Plymouth Rock, 以及Rhode Island reds。然而，在阶段14到阶段35中，仅white leghorns的胚胎照片被使用。</p>
<p>在鸡胚发育的第一阶段，原条（primitive streak）仍未可见，但是已经能看到胚板（embryonic shield）。到了第二阶段，通常是在孵化后的六到七个小时，原条开始出现。第三阶段，大约是发育的第12-13小时，此时原条可见，而原沟（primitive groove）仍未可见。第四阶段，原条完全伸展，原沟、原窝（primitive pit）、亨氏结（Hensen’s node）可见。第五阶段大约是在发育的19-22小时，此时脊索（notochord）在亨氏结下方可见。在这个阶段，头部开始形成。在第六阶段，头部褶皱存在，但没有体节。</p>
<p>第一对体节在第七阶段可见，位于头部附近的神经褶皱旁边。到第8阶段，有四对体节出现，血岛（blood island）出现在胚盘的底部。在第9阶段可见七对体节和视囊（optic vesicles）。在第10阶段，可以看到十对体节，一丝颅屈曲（cranial flexure）和三个主要的脑泡。在第11阶段，大约是在孵化后40-45小时后，在后脑（hindbrain）中可见五个神经粒（neuromere）或发育中的大脑段（segments）。在那个阶段，当视囊收缩时，神经孔（neuropore）开始闭合。第12阶段在发育的第45-49个小时，此时已出现16对体节，并且前神经孔（anterior neuropore）已关闭。发育的头开始向左旋转，初级视囊（primary optic vesicles）变得不同。心脏呈现S形，前脑（forebrain）完全被羊膜的头折（headfold）覆盖，直到下一阶段。在第13阶段中有19对体节，头几乎完全转向左侧， 尾脑（telencephalon）是独特的和扩大的。那时，羊膜的头折完全覆盖了前脑、中脑和后脑的前部[19]。</p>
<p>第14阶段是最后一个具有明确数量体节的阶段，有22对体节。在此阶段之后，体节变得难以区分。这一阶段大约是在孵化后的第50到53个小时。鳃弓和鳃裂开始形成，在此阶段，羊膜覆盖体节7到10。孵化50-55小时后，第15阶段开始，羊膜覆盖多达14对体节。到那个阶段，眼睛的视杯（optic cup），第三鳃弓和裂缝完全形成。</p>
<p>第16阶段，大约是在孵化后的51-56个小时，可以看到翅膀和尾芽，羊膜覆盖到18对体节。在第17阶段，即孵化后约52-64小时，可以看到肢芽。羊膜除了在体节28-36上之外，完全沿着胚胎延伸。在那个阶段，鼻孔形成。发育后65-69小时，即第18阶段，尿囊（allantois）开始形成。腿芽看起来比翅膀芽大，羊膜完全闭合。</p>
<p>在第19阶段，即孵化后68至72小时，体节伸入尾部。在此阶段，眼睛没有色素，尾芽向头部弯曲。尿囊在第20阶段变为水泡状，此时在孵化的第70-72小时，与此同时，眼睛中也有轻微的色素沉着，第二鳃弓延伸超过三分之一。在第21阶段，大约是孵化后72-84小时，尿囊开始扩大并延伸到头部，不对称的肢芽差异变得更明显。第22阶段是发育大约84小时后的胚胎，具有明显的眼睛色素，体节已完全延伸到尾部。大约96个小时后，即第23阶段，肢芽的长度与宽度相等，第四对鳃裂中有一个裂缝。</p>
<p>大约在发育开始4天半之后，鸡胚达到了第24阶段，此时肢芽的长度超过宽度，趾板开始形成。在第25阶段，即发育的第四天半到第五天，雏鸡的肘部和膝盖已经形成。在翅膀里面有一个digital plate，而第三和第四个鳃裂已经开始缩小。经过五整天的孵化，即第26阶段，胚胎已经具有三个脚趾，肢体继续拉长，第三个和第四个裂缝已经消失了。</p>
<p>在第27阶段，孵化的第5天到5天半，可以看到早期喙的形成，以及脚趾之间的沟槽痕迹。第28阶段，也就是发育的第5天半到第6天，胚胎的喙开始生长，脚趾变得更加突出。在第29阶段，即孵化6到6天半后，翅膀在肘部弯曲，脚趾开始结网。第30阶段，也就是发育后第6天半到7天，独特的卵齿（egg tooth）伸出小鸡，四肢的主要部分几乎塑形完成，羽毛萌发。第31-39阶段，羽胚逐渐可见。第40-45阶段包括增加喙大小和脚趾长度。在21天的发育完成后，来到了阶段46，孵化完成。</p>
<p>Hamburger-Hamilton发育阶段序列的46个阶段中，每个阶段中有一张照片。一些照片结合说明，以阐明一些形态学特征。每个阶段都有关于发展的描述，将其与之前和之后的阶段区分开的事件。尽管这个发育序列在1951年提出，但截至2011年，该系列仍被使用在生物学教科书中，以及确定鸡的发育阶段。</p>
<blockquote>
<p><a href="https://embryo.asu.edu/pages/hamburger-hamilton-staging-series-1951">https://embryo.asu.edu/pages/hamburger-hamilton-staging-series-1951</a></p>
</blockquote>
]]></content>
      <categories>
        <category>生物</category>
      </categories>
      <tags>
        <tag>发育生物学</tag>
        <tag>胚胎发育</tag>
      </tags>
  </entry>
  <entry>
    <title>学术英语570</title>
    <url>/2022/12/04/%E5%AD%A6%E6%9C%AF%E8%8B%B1%E8%AF%AD570/</url>
    <content><![CDATA[<p>看到群里有人说这玩意考试有用，于是浅浅整理了一下。</p>
<span id="more"></span>

<p>单词表来自新东方，释义来自有道词典。所有词汇的释义都是用一个python脚本爬取到，因此有些词组可能没有释义（所谓“not find meaning”），遇到这样的词汇就手动查询释义吧 ：）</p>
<p>下面是单词表：</p>
<table>
<thead>
<tr>
<th>word</th>
<th>meaning</th>
<th>derived words</th>
</tr>
</thead>
<tbody><tr>
<td>abandon</td>
<td>v.抛弃，遗弃；（因危险）离开，舍弃；中止，不再有；放弃（信念、信仰或看法）；陷入，沉湎于（某种情感）<br/>n.放任，放纵</td>
<td></td>
</tr>
<tr>
<td>abstract</td>
<td>adj.抽象的，纯概念的；（艺术）抽象派的；理论上的，不切实际的<br/>n.摘要，梗概；抽象画，抽象派艺术作品；抽象的概念<br/>v.抽象化，从理论上（或孤立地）考虑；提取，使分离；写……的摘要；偷走，窃取；退出</td>
<td>复数abstracts<br/>第三人称单数abstracts<br/>现在分词abstracting<br/>过去式abstracted<br/>过去分词abstracted<br/>比较级more abstract<br/>最高级most abstract</td>
</tr>
<tr>
<td>academic</td>
<td>adj.学业的，学术的；学校的，学院的；学业（成绩）优秀的，善于学习的；不切实际的，空谈的<br/>n.大学教师，学者；（学校或学院的）课程；大学生</td>
<td>复数academics<br/>比较级more academic<br/>最高级most academic</td>
</tr>
<tr>
<td>access</td>
<td>n.入口，通道；获得的机会，使用权；（对计算机存储器的）访问，存取；（情感）爆发，发作；探视权<br/>v.接近，进入；获取，访问（计算机信息）<br/>adj.&lt;美&gt;（电视节目或时间等）对外公开的</td>
<td>复数accesses<br/>第三人称单数accesses<br/>现在分词accessing<br/>过去式accessed<br/>过去分词accessed</td>
</tr>
<tr>
<td>accommodation</td>
<td>n.&lt;美&gt;住宿，膳宿；&lt;英&gt;住处，办公处，停留处；（楼房或交通工具内的）空间，座位；和解，调和；（通过改变眼球晶状体形状）自动调焦</td>
<td>复数accommodations</td>
</tr>
<tr>
<td>accompanied</td>
<td>v.陪伴，伴随；伴奏（accompany 的过去分词）<br/>adj.伴随的；相伴的</td>
<td></td>
</tr>
<tr>
<td>accumulation</td>
<td>n.积累，堆积；堆积物，堆积量</td>
<td></td>
</tr>
<tr>
<td>accurate</td>
<td>adj.准确的，精确的；（工具，方法）精密的；正确无误的；（武器、投掷）精准的</td>
<td>比较级more accurate<br/>最高级most accurate</td>
</tr>
<tr>
<td>achieve</td>
<td>v.（经努力）达到，取得，实现；获得成功</td>
<td>第三人称单数achieves<br/>现在分词achieving<br/>过去式achieved<br/>过去分词achieved</td>
</tr>
<tr>
<td>acknowledged</td>
<td>adj.公认的；被普遍认可的<br/>v.承认；答谢；告知已收到；搭理（acknowledge 的过去式和过去分词）</td>
<td></td>
</tr>
<tr>
<td>acquisition</td>
<td>n.学得，习得；（金钱、财物等的）获取；购买，添置，增添物；收购，购置的产业</td>
<td>复数acquisitions</td>
</tr>
<tr>
<td>adaptation</td>
<td>n.改编本，改写本；适应，改变；适应（性），适应力；适应性变化</td>
<td>复数adaptations</td>
</tr>
<tr>
<td>adequate</td>
<td>adj.足够的，适当的，合乎需要的；（品质）足够好的，令人满意的；（质量）达到要求的，勉强过关的</td>
<td></td>
</tr>
<tr>
<td>adjacent</td>
<td>adj.邻近的，毗连的；（几何）（两个角）相邻的</td>
<td></td>
</tr>
<tr>
<td>adjustment</td>
<td>n.调整，校正；（行为、思想的）调节，适应；调节器</td>
<td>复数adjustments</td>
</tr>
<tr>
<td>administration</td>
<td>n.管理，行政；管理部门，行政部门；（某一任期的）政府；执行，监管；（药的）服用，配给；遗产管理，（债务人、其他个人或破产公司的）资产管理</td>
<td>复数administrations</td>
</tr>
<tr>
<td>adults</td>
<td>n.成年人（adult 的复数形式）</td>
<td></td>
</tr>
<tr>
<td>advocate</td>
<td>v.拥护，提倡<br/>n.拥护者，提倡者；辩护律师；（为某一类人）谋利益者；（一项事业或个组织的）工作者</td>
<td>复数advocates<br/>第三人称单数advocates<br/>现在分词advocating<br/>过去式advocated<br/>过去分词advocated</td>
</tr>
<tr>
<td>affect</td>
<td>v.影响；（疾病）侵袭，感染；（在感情上）深深打动，震撼；&lt;正式&gt; 假装，佯装<br/>n.（尤指影响行为或行动的）情感，感情</td>
<td>复数affects<br/>第三人称单数affects<br/>现在分词affecting<br/>过去式affected<br/>过去分词affected</td>
</tr>
<tr>
<td>aggregate</td>
<td>n.总数，合计；骨料，混凝料<br/>adj.总计的，合计的；（种群）聚生的<br/>v.集合，聚集；总计达到；合计</td>
<td>复数aggregates<br/>第三人称单数aggregates<br/>现在分词aggregating<br/>过去式aggregated<br/>过去分词aggregated</td>
</tr>
<tr>
<td>aid</td>
<td>n.帮助；援助，救助；辅助物，辅助设施；助手；特别津贴，国库税<br/>v.帮助，援助；促进，有助于<br/>【名】 （Aid）（英、阿拉伯、印）艾德（人名）</td>
<td></td>
</tr>
<tr>
<td>albeit</td>
<td>conj.虽然，尽管<br/>【名】 （Albeit）（美、英、马）艾乐贝特（人名）</td>
<td></td>
</tr>
<tr>
<td>allocation</td>
<td>n.配给量，划拨款，份额；分配，分派</td>
<td>复数allocations</td>
</tr>
<tr>
<td>alter</td>
<td>v.改变，改动；（使）变化；改（服装）；改建（某建筑）；&lt;美&gt;阉割<br/>【名】 （Alter）（美、德、俄、以色列）阿尔特（人名）</td>
<td>第三人称单数alters<br/>现在分词altering<br/>过去式altered<br/>过去分词altered</td>
</tr>
<tr>
<td>alternate</td>
<td>v.（使）交替，（使）轮流<br/>adj.轮流的，交替的；间隔的；供选择的，备用的；（叶，芽）互生的；另类的<br/>n.替补者，候补者</td>
<td>复数alternates<br/>第三人称单数alternates<br/>现在分词alternating<br/>过去式alternated<br/>过去分词alternated</td>
</tr>
<tr>
<td>alternative</td>
<td>n.可供选择的事物，替代物<br/>adj.可替代的，备选的；非传统的，另类的；（两者）互不相容的，非此即彼的</td>
<td>复数alternatives</td>
</tr>
<tr>
<td>ambiguous</td>
<td>adj.模棱两可的，有歧义的；不明朗的，不确定的</td>
<td></td>
</tr>
<tr>
<td>amendment</td>
<td>n.修正，修订之处；美国宪法修正案（Amendment）；（土壤结构或肥力的）改善；（对文件或计划的）修改</td>
<td>复数amendments</td>
</tr>
<tr>
<td>analogous</td>
<td>adj.相似的，类似的；（器官）同功的</td>
<td></td>
</tr>
<tr>
<td>analysis</td>
<td>n.分析；化验分析；心理分析，精神分析；分析报告</td>
<td>复数analyses</td>
</tr>
<tr>
<td>annual</td>
<td>adj.一年一度的；年度的；（植物）一年生的<br/>n.一年生植物；年刊，年鉴</td>
<td>复数annuals</td>
</tr>
<tr>
<td>anticipated</td>
<td>adj.受期待的，让人期盼的<br/>v.预期，预料；期待，盼望；先于…做，抢先…做（anticipate 的过去式和过去分词）</td>
<td></td>
</tr>
<tr>
<td>apparent</td>
<td>adj.显而易见的，易懂的；貌似的，表面上的</td>
<td></td>
</tr>
<tr>
<td>appendix</td>
<td>n.阑尾；附录</td>
<td>复数appendixes或appendices</td>
</tr>
<tr>
<td>appreciation</td>
<td>n.欣赏，鉴赏；感激，感谢；理解，领会；升值，增值；（赞赏性的）演讲，文字</td>
<td>复数appreciations</td>
</tr>
<tr>
<td>approach</td>
<td>v.靠近，临近；接洽，交谈；对付，处理；近似，接近于<br/>n.方法，态度；靠近，接近；接洽，要求；通道，路径；进场着陆；近似物</td>
<td>复数approaches<br/>第三人称单数approaches<br/>现在分词approaching<br/>过去式approached<br/>过去分词approached</td>
</tr>
<tr>
<td>appropriate</td>
<td>adj.合适的，相称的<br/>v.拨出（款项）；私占，挪用</td>
<td>第三人称单数appropriates<br/>现在分词appropriating<br/>过去式appropriated<br/>过去分词appropriated<br/>比较级more appropriate<br/>最高级most appropriate</td>
</tr>
<tr>
<td>approximated</td>
<td>adj.接近的；估计的<br/>v.接近；约等于（approximate 的过去式和过去分词）</td>
<td></td>
</tr>
<tr>
<td>arbitrary</td>
<td>adj.任意的，随心所欲的；专横的，武断的</td>
<td></td>
</tr>
<tr>
<td>area</td>
<td>n.地区，区域；场地，地方；领域；面积；部位；罚球区<br/>【名】 （Area）（西）阿雷亚（人名）</td>
<td>复数areas</td>
</tr>
<tr>
<td>aspects</td>
<td>n.方面；方位；面貌（aspect 的复数）</td>
<td></td>
</tr>
<tr>
<td>assembly</td>
<td>n.议会，代表大会；集会，集会者；装配，组装；（计算机）汇编</td>
<td>复数assemblies</td>
</tr>
<tr>
<td>assessment</td>
<td>n.评估，评价；估价，估计</td>
<td>复数assessments</td>
</tr>
<tr>
<td>assigned</td>
<td>adj.指定的；已分配的<br/>v.分配（assign 的过去分词）；指定；委派</td>
<td></td>
</tr>
<tr>
<td>assistance</td>
<td>n.帮助，援助</td>
<td></td>
</tr>
<tr>
<td>assume</td>
<td>v.假定，假设，认为；装出，做出；承担，就职；呈现，具有；夺取，篡夺</td>
<td>第三人称单数assumes<br/>现在分词assuming<br/>过去式assumed<br/>过去分词assumed</td>
</tr>
<tr>
<td>assurance</td>
<td>n.自信，把握；（人寿）保险；保证，确保</td>
<td>复数assurances</td>
</tr>
<tr>
<td>attached</td>
<td>adj.非常喜欢……的，热爱……的；为……工作的；隶属于……，附属的；连接的，附加的<br/>v.系上，贴上；赋予，认为……具有（attach 的过去式和过去分词形式）</td>
<td></td>
</tr>
<tr>
<td>attained</td>
<td>vt.取得，得到，获得（attain 的过去式）</td>
<td></td>
</tr>
<tr>
<td>attitudes</td>
<td>n.态度，看法（attitude 复数）</td>
<td></td>
</tr>
<tr>
<td>attributed</td>
<td>v.归于（attribute 的过去式，过去分词）；属性化</td>
<td></td>
</tr>
<tr>
<td>author</td>
<td>n.作者，著者；作家；发起者，创始人；作品<br/>v.撰写，写作；发起，创造</td>
<td>复数authors<br/>第三人称单数authors<br/>现在分词authoring<br/>过去式authored<br/>过去分词authored</td>
</tr>
<tr>
<td>authority</td>
<td>n.专家，权威人士；行政管理机构；权利，权限；权威，威信；许可，授权；当局，官方</td>
<td>复数authorities</td>
</tr>
<tr>
<td>automatically</td>
<td>adv.自然地，必然地；不假思索地，无意识地；自动地</td>
<td></td>
</tr>
<tr>
<td>available</td>
<td>adj.可用的，可获得的；有空的，有闲暇的；未婚的，单身的</td>
<td></td>
</tr>
<tr>
<td>aware</td>
<td>adj.知道的，明白的；察觉到的，意识到的；有……意识的，有……知识的<br/>【名】 （Aware）（阿拉伯、索）阿瓦雷（人名）</td>
<td></td>
</tr>
<tr>
<td>behalf</td>
<td>n.代表（on behalf of）；因为，为了……的利益（in/on behalf of）；就……而言，在……一方（on behalf of）</td>
<td>复数behalves</td>
</tr>
<tr>
<td>benefit</td>
<td>n.好处，益处；救济金，补助金；额外奖励，保险金；慈善活动<br/>v.对（某人）有用，使受益；得益于，得利于</td>
<td>复数benefits<br/>第三人称单数benefits<br/>现在分词benefiting或benefitting<br/>过去式benefited或benefitted<br/>过去分词benefited或benefitted</td>
</tr>
<tr>
<td>bias</td>
<td>n.偏见，成见；偏好，天赋；倾向，趋势；斜纹；（统计）偏差，偏倚；偏重心球形；偏压，偏统<br/>v.使有偏见，使偏心；加偏压（或偏流）于<br/>adj.偏斜的<br/>adv.偏斜地<br/>【名】 （Bias）（英）拜厄斯，（法、德、葡、喀）比亚斯（人名）</td>
<td>复数biases<br/>第三人称单数biases或biasses<br/>现在分词biasing或biassing<br/>过去式biased或biassed<br/>过去分词biased或biassed</td>
</tr>
<tr>
<td>bond</td>
<td>n.纽带，联系；公债，债券；结合，黏合；承诺，契约；枷锁，桎梏<br/>v.（使）建立亲密关系；与……黏合（或连接）<br/>【名】 （Bond）（英、德、西、瑞典）邦德（人名）</td>
<td>复数bonds<br/>第三人称单数bonds<br/>现在分词bonding<br/>过去式bonded<br/>过去分词bonded</td>
</tr>
<tr>
<td>brief</td>
<td>adj.短暂的；简短的；（衣服）很短的<br/>v.给……指示，向……介绍情况；&lt;英&gt;向（辩护律师）提供案情摘要<br/>n.指示，任务简介；摘要，概要；短内裤（briefs）；辩护状；辩护律师；&lt;英&gt;委托辩护<br/>【名】 （Brief）（英）布里夫（人名）</td>
<td>复数briefs<br/>第三人称单数briefs<br/>现在分词briefing<br/>过去式briefed<br/>过去分词briefed<br/>比较级briefer<br/>最高级briefest</td>
</tr>
<tr>
<td>bulk</td>
<td>n.主体，大部分；庞大的身躯，肥硕的体形；（巨大的）容积，体积<br/>adj.大批的，大宗的<br/>v.使（产品）数量显得很大；结合（待售的股票或商品）<br/>【名】 （Bulk）（土）布尔克（人名）</td>
<td>复数bulks<br/>第三人称单数bulks<br/>现在分词bulking<br/>过去式bulked<br/>过去分词bulked</td>
</tr>
<tr>
<td>capable</td>
<td>adj.有能力的；有本领的，能干的；可以……的，容许……的</td>
<td></td>
</tr>
<tr>
<td>capacity</td>
<td>n.能力，才能；容积，容纳能力；职位，职责；功率，容积；生产量，生产能力<br/>adj.无虚席的，满场的</td>
<td>复数capacities</td>
</tr>
<tr>
<td>categories</td>
<td>n.种类，分类； 范畴（category 的复数）</td>
<td></td>
</tr>
<tr>
<td>ceases</td>
<td>n.停止（cease 的复数形式）<br/>v.停止（cease 的第三人称单数）；终了</td>
<td></td>
</tr>
<tr>
<td>challenge</td>
<td>n.挑战，难题；挑战书，比赛邀请；质疑，质询；喝停盘查<br/>v.挑战，向……下战书；质疑，拒绝接受；盘问，查问；考验</td>
<td>复数challenges<br/>第三人称单数challenges<br/>现在分词challenging<br/>过去式challenged<br/>过去分词challenged</td>
</tr>
<tr>
<td>channel</td>
<td>n.频道，电视频道；管道，通道，航道；渠道，手段；沟渠，沟槽；河床；海峡；信道；电子沟道；输液道<br/>v.引导，把……用于；输送，传送；通灵；努力赶上，受启发；形成凹槽<br/>【名】 （Channel）（美）沙内乐（人名）</td>
<td>复数channels<br/>第三人称单数channels<br/>现在分词channelling或channeling<br/>过去式channelled或channeled<br/>过去分词channelled或channeled</td>
</tr>
<tr>
<td>chapter</td>
<td>n.章，回，篇；阶段，时期；分会，分部；议会法案；一系列，一连串（a chapter of）；全体教士；宗教团体理事会<br/>v.把……分成章节</td>
<td>复数chapters<br/>第三人称单数chapters<br/>现在分词chaptering<br/>过去式chaptered<br/>过去分词chaptered</td>
</tr>
<tr>
<td>chart</td>
<td>n.图表，曲线图；海图，星位图；排行榜<br/>v.绘制；记录，跟踪；制定（行动计划）；进榜，上榜<br/>【名】 （Chart）（泰）察（人名）</td>
<td>复数charts<br/>第三人称单数charts<br/>现在分词charting<br/>过去式charted<br/>过去分词charted</td>
</tr>
<tr>
<td>chemical</td>
<td>adj.化学的，与化学有关的<br/>n.化学品，化学制品；成瘾的药物</td>
<td>复数chemicals</td>
</tr>
<tr>
<td>circumstances</td>
<td>n.环境，状况；（尤指经济上的）境况；原委（circumstance 的复数）</td>
<td></td>
</tr>
<tr>
<td>cited</td>
<td>v.引用（cite 的过去分词）</td>
<td></td>
</tr>
<tr>
<td>civil</td>
<td>adj.公民的，国民的，国内的；平民的，民用的；文明的，有礼貌的；民法的（非刑法的），民事的；习俗规定的，历法规定的<br/>【名】 （Civil）（土）吉维尔，（法）西维尔（人名）</td>
<td></td>
</tr>
<tr>
<td>clarity</td>
<td>n.清晰易懂；思路清晰；（画面或声音的）清晰，清楚；清澈，明净<br/>【名】 （Clarity）（英）克拉里蒂（人名）</td>
<td></td>
</tr>
<tr>
<td>classical</td>
<td>adj.经典的，传统的；和古希腊与古罗马文化相关的；（音乐）古典的；文科的，人文科学的；典型的，有代表性的；相对论和量子力学理论前的概念、理论的，古典力学的</td>
<td></td>
</tr>
<tr>
<td>clause</td>
<td>n.从句，分句；（法律文件的）条款<br/>【名】 （Clause）（法）克洛斯（人名）</td>
<td>复数clauses</td>
</tr>
<tr>
<td>code</td>
<td>n.密码，暗码；（邮政）编码，（电话）区号；（计算机）编码；道德准则，行为规范；法典，法规<br/>v.把……编码（或编号）；把……译成密码；（给计算机）编写指令<br/>【名】 （Code）（英、法、西）科德（人名）</td>
<td>复数codes<br/>第三人称单数codes<br/>现在分词coding<br/>过去式coded<br/>过去分词coded</td>
</tr>
<tr>
<td>coherence</td>
<td>n.连贯性，条理性；凝聚，凝聚力</td>
<td></td>
</tr>
<tr>
<td>coincide</td>
<td>v.巧合，同时发生；一致，相符；相交，重叠</td>
<td>第三人称单数coincides<br/>现在分词coinciding<br/>过去式coincided<br/>过去分词coincided</td>
</tr>
<tr>
<td>collapse</td>
<td>v.倒塌，塌下；崩溃，瓦解；突然倒下，昏倒；瘫倒；突然贬值，暴跌；萎陷，瘪掉；折叠<br/>n.倒塌，塌陷；突然失败，崩溃；病倒，垮掉；突然贬值，暴跌</td>
<td>复数collapses<br/>第三人称单数collapses<br/>现在分词collapsing<br/>过去式collapsed<br/>过去分词collapsed</td>
</tr>
<tr>
<td>colleagues</td>
<td>n.同事；同行（colleague 的复数）</td>
<td></td>
</tr>
<tr>
<td>commenced</td>
<td>v.开始（commence 的过去分词）</td>
<td></td>
</tr>
<tr>
<td>comments</td>
<td>n.评论；注解（comment 的复数）<br/>v.评论；解释（comment 的第三人称单数）</td>
<td></td>
</tr>
<tr>
<td>commission</td>
<td>n.考察团，委员会；佣金，回扣；犯罪；委托，命令；（军队中的）官职，军衔；（尤指艺术品）委托制作；&lt;古&gt;所授之权，代办权<br/>v.委托撰写，委托制作；委任，任命……为军官；（使军舰）正式使用，服现役</td>
<td>复数commissions<br/>第三人称单数commissions<br/>现在分词commissioning<br/>过去式commissioned<br/>过去分词commissioned</td>
</tr>
<tr>
<td>commitment</td>
<td>n.忠诚，献身；承诺，保证；奉献，投入；热情，决心；义务，责任；花费，使用（资金、时间、人力）；需要定期支付的款项</td>
<td>复数commitments</td>
</tr>
<tr>
<td>commodity</td>
<td>n.商品，货物；有用的东西，必需品</td>
<td>复数commodities</td>
</tr>
<tr>
<td>communication</td>
<td>n.表达，交流，交际；信息，书信，电话；通讯，交通联系；传播学</td>
<td>复数communications</td>
</tr>
<tr>
<td>community</td>
<td>n.社区，社会；（由同国籍、同宗教等构成的）群体，界；（多个国家的）共同体；归属感；（动植物的）群落</td>
<td>复数communities</td>
</tr>
<tr>
<td>compensation</td>
<td>n.赔偿金，补偿金；弥补，抵消；报酬，薪水</td>
<td></td>
</tr>
<tr>
<td>compiled</td>
<td>adj.编译的<br/>v.编辑（compile 的过去分词）</td>
<td></td>
</tr>
<tr>
<td>complement</td>
<td>v.补充，补足<br/>n.补足物，衬托物；足数，足额；补语；余角；补体，防御素</td>
<td>复数complements<br/>第三人称单数complements<br/>现在分词complementing<br/>过去式complemented<br/>过去分词complemented</td>
</tr>
<tr>
<td>complex</td>
<td>adj.复杂的，难懂的；组合的，合成的；（句子）复合的；复数的，复的；配合的，络合的<br/>n.综合大楼，建筑群；复合体，综合体；情结；强烈（或过度）的关心（或忧虑）；配合物，络合物</td>
<td>复数complexes<br/>第三人称单数complexes<br/>现在分词complexing<br/>过去式complexed<br/>过去分词complexed<br/>比较级more complex<br/>最高级most complex</td>
</tr>
<tr>
<td>components</td>
<td>n.部件；组件；成分；分力（component 的复数）</td>
<td></td>
</tr>
<tr>
<td>compounds</td>
<td>n.混合物，化合物；大院（compound的复数形式）</td>
<td></td>
</tr>
<tr>
<td>comprehensive</td>
<td>adj.综合性的，全面的；有理解力的<br/>n.综合中学；专业综合测验</td>
<td>复数comprehensives<br/>比较级more comprehensive<br/>最高级most comprehensive</td>
</tr>
<tr>
<td>comprise</td>
<td>v.包括，包含；构成，组成</td>
<td>第三人称单数comprises<br/>现在分词comprising<br/>过去式comprised<br/>过去分词comprised</td>
</tr>
<tr>
<td>computer</td>
<td>n.计算机；电脑；电子计算机</td>
<td>复数computers</td>
</tr>
<tr>
<td>conceived</td>
<td>v.构思；设想；怀孕（conceive 的过去式和过去分词）</td>
<td></td>
</tr>
<tr>
<td>concentration</td>
<td>n.专心，专注；关注，重视；集中，聚集；含量，浓度</td>
<td>复数concentrations</td>
</tr>
<tr>
<td>concept</td>
<td>n.概念，观念<br/>adj.（围绕）某主题的；为表达一种想法而创造的<br/>v.&lt;非正式&gt;想象，设想</td>
<td>复数concepts<br/>第三人称单数concepts<br/>现在分词concepting<br/>过去式concepted<br/>过去分词concepted</td>
</tr>
<tr>
<td>conclusion</td>
<td>n.结论，推论；结局，结尾；缔结，商定；（根据所给前提得出的）命题</td>
<td>复数conclusions</td>
</tr>
<tr>
<td>concurrent</td>
<td>adj.并存的，同时发生的；同意的，一致的；（两个或两个以上徒刑判决）同时执行的；（三条或三条以上线）共点的，会合的<br/>n.共点；同时发生的事件</td>
<td></td>
</tr>
<tr>
<td>conduct</td>
<td>v.实施，进行；指挥；带领，引导；举止，表现；传导<br/>n.行为，举止；经营方式，管理方法</td>
<td>第三人称单数conducts<br/>现在分词conducting<br/>过去式conducted<br/>过去分词conducted</td>
</tr>
<tr>
<td>conference</td>
<td>n.（大型、正式的）会议，研讨会；（小型正式的）商讨，讨论；体育协会（或联合会）</td>
<td>复数conferences<br/>第三人称单数conferences<br/>现在分词conferencing<br/>过去式conferenced<br/>过去分词conferenced</td>
</tr>
<tr>
<td>confined</td>
<td>adj.（空间或面积）有限的，狭窄的；受限制的，被限定的；（因残疾或生病）受困于……的；幽禁的；在分娩中的<br/>v.限制，使局限；关押，监禁；使离不开（或受困于床、轮椅等）（confine 的过去式和过去分词）</td>
<td></td>
</tr>
<tr>
<td>confirmed</td>
<td>adj.坚定的，根深蒂固的；已被证实的<br/>v.确定；证实；使确信（confirm 的过去式和过去分词形式）</td>
<td></td>
</tr>
<tr>
<td>conflict</td>
<td>n.争执，争论，分歧；战斗，战争；抵触，矛盾<br/>v.冲突，抵触</td>
<td>复数conflicts<br/>第三人称单数conflicts<br/>现在分词conflicting<br/>过去式conflicted<br/>过去分词conflicted</td>
</tr>
<tr>
<td>conformity</td>
<td>n.遵守，依照；随大流，循规蹈矩；符合，一致；信奉英国国教</td>
<td>复数conformities</td>
</tr>
<tr>
<td>consent</td>
<td>n.许可，允许；同意，赞同；正式批准文件，批文<br/>v.赞同，准许，同意<br/>【名】 （Consent）（美、法、荷）孔桑（人名）</td>
<td>复数consents<br/>第三人称单数consents<br/>现在分词consenting<br/>过去式consented<br/>过去分词consented</td>
</tr>
<tr>
<td>consequences</td>
<td>n.后果，结果；影响（consequence 的复数）</td>
<td></td>
</tr>
<tr>
<td>considerable</td>
<td>adj.相当大的，相当重要的；（人）显要的，值得尊敬的</td>
<td>比较级more considerable<br/>最高级most considerable</td>
</tr>
<tr>
<td>consistent</td>
<td>adj.始终如一的，一贯的；持续的，连续的；固守的，坚持的；一致的，吻合的</td>
<td>比较级more consistent<br/>最高级most consistent</td>
</tr>
<tr>
<td>constant</td>
<td>adj.持续不断的，经常发生的；恒定的，不变的；忠诚的，忠实的<br/>n.常数，恒量；不变的事物<br/>【名】 （Constant） （德）康斯坦特（人名）</td>
<td>复数constants<br/>比较级more constant<br/>最高级most constant</td>
</tr>
<tr>
<td>constitutional</td>
<td>adj.宪法的；宪法规定的，合乎宪法的；体质的，体格的；本性的，天性的<br/>n.&lt;旧&gt;保健散步</td>
<td>复数constitutionals</td>
</tr>
<tr>
<td>constraints</td>
<td>n.[数]约束；限制；约束条件（constraint 的复数形式）</td>
<td></td>
</tr>
<tr>
<td>construction</td>
<td>n.建造，建筑；创立，构建；构造，结构；建筑物；语法结构；解释，理解</td>
<td>复数constructions</td>
</tr>
<tr>
<td>consultation</td>
<td>n.商讨，磋商，磋商会议；咨询，就诊；查找，查阅</td>
<td>复数consultations</td>
</tr>
<tr>
<td>consumer</td>
<td>n.消费者，顾客，用户；食用者，使用者，消耗者</td>
<td>复数consumers</td>
</tr>
<tr>
<td>contact</td>
<td>n.联系，联络；接触，触摸；联络人，熟人，社会关系；会见，往来，接触；传染病接触者；隐形眼镜；接通电，触点，接头；（无线电）通信<br/>v.联系，联络；接触<br/>adj.供联络的；接触性的，通过接触而起作用的</td>
<td>复数contacts<br/>第三人称单数contacts<br/>现在分词contacting<br/>过去式contacted<br/>过去分词contacted</td>
</tr>
<tr>
<td>contemporary</td>
<td>adj.当代的，现代的；同时期的，同时代的<br/>n.同时代的人；同龄人，同辈</td>
<td>复数contemporaries<br/>比较级more contemporary<br/>最高级most contemporary</td>
</tr>
<tr>
<td>context</td>
<td>n.背景，环境；上下文，语境</td>
<td>复数contexts</td>
</tr>
<tr>
<td>contract</td>
<td>n.合同，契约；&lt;非正式&gt;暗杀协议；（桥牌）定约墩数；婚约，订婚<br/>v.（使）收缩，缩小；签合同，订立契约；患上，感染；订立婚约（或盟约）；欠负（债）</td>
<td>复数contracts<br/>第三人称单数contracts<br/>现在分词contracting<br/>过去式contracted<br/>过去分词contracted</td>
</tr>
<tr>
<td>contradiction</td>
<td>n.矛盾，不一致；反驳，驳斥</td>
<td>复数contradictions</td>
</tr>
<tr>
<td>contrary</td>
<td>adj.相反的，相对的；乖戾的，好与人作对的；逆向的，逆行的<br/>n.相反的事实（或事情、情况）；对立命题，反对命题<br/>adv.相反地</td>
<td>复数contraries</td>
</tr>
<tr>
<td>contrast</td>
<td>n.差异，对比；对照物，明显不同的事物；（摄影或绘画中的）颜色反差，明暗对比；（电视屏幕的）图像明暗对比度，反差<br/>v.对比，对照；显出明显的差异，形成对比</td>
<td>复数contrasts<br/>第三人称单数contrasts<br/>现在分词contrasting<br/>过去式contrasted<br/>过去分词contrasted</td>
</tr>
<tr>
<td>contribution</td>
<td>n.贡献，促成作用；捐款，捐助；（保险金、养老金等的）定期缴款；稿件，投稿</td>
<td>复数contributions</td>
</tr>
<tr>
<td>controversy</td>
<td>n.争论，争议</td>
<td>复数controversies</td>
</tr>
<tr>
<td>convention</td>
<td>n.习俗，惯例；大会，集会；公约，协定；（文学、艺术上的）传统手法，传统风格</td>
<td>复数conventions</td>
</tr>
<tr>
<td>conversely</td>
<td>adv.相反地，反过来说</td>
<td></td>
</tr>
<tr>
<td>converted</td>
<td>adj.修改的；改变信仰的<br/>v.转变；改变信仰（convert 的过去式和过去分词形式）</td>
<td></td>
</tr>
<tr>
<td>convinced</td>
<td>adj.确信的，信服的；坚信不疑的，有坚定信仰的<br/>v.使确信，使信服；说服，劝服（convince 的过去式和过去分词形式）</td>
<td></td>
</tr>
<tr>
<td>cooperative</td>
<td>adj.合作的，协作的；乐于配合的；（企业或其他组织）合作性的<br/>n.合作性组织</td>
<td>复数cooperatives<br/>比较级more cooperative<br/>最高级most cooperative</td>
</tr>
<tr>
<td>coordination</td>
<td>n.协调，配合；身体的协调性；配位；同一等级（或类别）</td>
<td></td>
</tr>
<tr>
<td>core</td>
<td>n.果核；中心部分；核心，要点；骨干，核心成员；地核，天体的核心；核反应堆堆芯；芯体<br/>v.给……去核<br/>adj.核心的，最重要的；基础的，必修的<br/>【名】 （Core）（英）科尔，（西、意）科雷（人名）</td>
<td>复数cores<br/>第三人称单数cores<br/>现在分词coring<br/>过去式cored<br/>过去分词cored</td>
</tr>
<tr>
<td>corporate</td>
<td>adj.公司的；法人的；共同的，全体的<br/>n.公司，集团</td>
<td></td>
</tr>
<tr>
<td>corresponding</td>
<td>adj.相应的，相关的<br/>v.类似于，相当于；通信；相一致，符合（correspond 的现在分词形式）</td>
<td></td>
</tr>
<tr>
<td>couple</td>
<td>n.两个，几个；一对夫妇，一对情侣<br/>v.加上，结合；（把设备等）连接；形成一双，配成一对；&lt;旧&gt;交配，交媾；（用电磁感应，静电荷或光学通信线路）将（电路元件）耦合<br/>【名】 （Couple）（法）库普勒（人名）</td>
<td>复数couples<br/>第三人称单数couples<br/>现在分词coupling<br/>过去式coupled<br/>过去分词coupled</td>
</tr>
<tr>
<td>create</td>
<td>v.创造，创建；设计，创作；造成，引起；授予，册封；&lt;英，非正式&gt;大惊小怪，抱怨</td>
<td>第三人称单数creates<br/>现在分词creating<br/>过去式created<br/>过去分词created</td>
</tr>
<tr>
<td>credit</td>
<td>n.信用，信贷，赊购；赞扬，信誉，声望；存款金额，余额；补助；退税，抵免；学分；带来荣耀的人（或事）；作品（指影片、电视节目、戏剧等）；信任，相信<br/>v.把（钱）记入总账，把钱存入（账户）；相信，信任；认为是……的功劳，给予承认；认为……有特定品质（或效果）</td>
<td>复数credits<br/>第三人称单数credits<br/>现在分词crediting<br/>过去式credited<br/>过去分词credited</td>
</tr>
<tr>
<td>criteria</td>
<td>n.（评判或做决定的）标准，准则，尺度 （criterion 的复数）</td>
<td></td>
</tr>
<tr>
<td>crucial</td>
<td>adj.至关重要的，决定性的；&lt;非正式&gt;极好的</td>
<td>比较级more crucial<br/>最高级most crucial</td>
</tr>
<tr>
<td>cultural</td>
<td>adj.文化的，与文化有关的；艺术的，文艺的</td>
<td></td>
</tr>
<tr>
<td>currency</td>
<td>n.通货，货币；通用，流行；现时性</td>
<td>复数currencies</td>
</tr>
<tr>
<td>cycle</td>
<td>n.自行车，摩托车；循环，周期；组诗，组歌；整套，系列；自行车骑行；一段时间<br/>v.骑自行车；循环</td>
<td>复数cycles<br/>第三人称单数cycles<br/>现在分词cycling<br/>过去式cycled<br/>过去分词cycled</td>
</tr>
<tr>
<td>data</td>
<td>n.数据，资料；（储存在计算机中的）数据资料<br/>【名】 （Data）（日）驮太，（印、葡）达塔（人名）</td>
<td></td>
</tr>
<tr>
<td>debate</td>
<td>n.讨论，辩论<br/>v.反复思考，斟酌；讨论，辩论</td>
<td>复数debates<br/>第三人称单数debates<br/>现在分词debating<br/>过去式debated<br/>过去分词debated</td>
</tr>
<tr>
<td>decades</td>
<td>n.数十年（decade 的复数）</td>
<td></td>
</tr>
<tr>
<td>decline</td>
<td>v.下降，衰退；拒绝，谢绝；变格，词形变化<br/>n.减少，衰退</td>
<td>复数declines<br/>第三人称单数declines<br/>现在分词declining<br/>过去式declined<br/>过去分词declined</td>
</tr>
<tr>
<td>deduction</td>
<td>n.演绎，推论；扣除，扣除额</td>
<td>复数deductions</td>
</tr>
<tr>
<td>definite</td>
<td>adj.清晰的，明晰的；确定的，不会改变的；肯定的，一定的<br/>n.确定之事</td>
<td></td>
</tr>
<tr>
<td>definition</td>
<td>n.定义，释义；榜样，典范；清晰，清晰度，鲜明度</td>
<td>复数definitions</td>
</tr>
<tr>
<td>demonstrate</td>
<td>v.证明；示范，演示；表露；游行，示威</td>
<td>第三人称单数demonstrates<br/>现在分词demonstrating<br/>过去式demonstrated<br/>过去分词demonstrated</td>
</tr>
<tr>
<td>denote</td>
<td>v.标志，预示；表示，意指</td>
<td>第三人称单数denotes<br/>现在分词denoting<br/>过去式denoted<br/>过去分词denoted</td>
</tr>
<tr>
<td>deny</td>
<td>v.否认；拒绝承认；拒绝给予</td>
<td>第三人称单数denies<br/>现在分词denying<br/>过去式denied<br/>过去分词denied</td>
</tr>
<tr>
<td>depression</td>
<td>n.抑郁，沮丧；萧条（期），不景气；低气压；凹陷，浅坑；俯角，俯视角</td>
<td>复数depressions</td>
</tr>
<tr>
<td>derived</td>
<td>adj.导出的；衍生的，派生的<br/>v.从……衍生出，源于；（从……中）得到，提取；导出（derive 的过去式和过去分词）</td>
<td></td>
</tr>
<tr>
<td>design</td>
<td>n.设计，布局，安排；设计艺术，构思；设计图，图纸；图案，花纹；计划，意图<br/>v.设计，制图，构思；筹划，制订；预定，指定<br/>【名】 （Design）（俄、巴、印）迪赛（人名）</td>
<td>复数designs<br/>第三人称单数designs<br/>现在分词designing<br/>过去式designed<br/>过去分词designed</td>
</tr>
<tr>
<td>despite</td>
<td>prep.尽管，即使；不由自主地，忍不住地<br/>n.&lt;古&gt;亵渎；&lt;古&gt;轻蔑，鄙视<br/>v.&lt;古&gt;蔑视；&lt;古&gt;激怒</td>
<td>第三人称单数despites<br/>现在分词despiting<br/>过去式despited<br/>过去分词despited</td>
</tr>
<tr>
<td>detected</td>
<td>adj.检测到的<br/>v.（尤指用特殊方法）发现，识别；（通常指用特殊设备）探测，检测；查明，调查（罪犯，罪行）；察觉（细微或不易察觉的东西）（detect 的过去式和过去分词）</td>
<td></td>
</tr>
<tr>
<td>deviation</td>
<td>n.偏离，违背；离差，偏差</td>
<td>复数deviations</td>
</tr>
<tr>
<td>device</td>
<td>n.装置，设备；手段，方法；花招，诡计；炸弹，爆炸装置；图画，设计；&lt;古&gt;（某物的）样式，外表</td>
<td>复数devices</td>
</tr>
<tr>
<td>devoted</td>
<td>adj.挚爱的，忠诚的；热衷的；专用于……的<br/>v.献身，致力；用于（devote 的过去式和过去分词形式）</td>
<td></td>
</tr>
<tr>
<td>differentiation</td>
<td>n.区分，差异化</td>
<td></td>
</tr>
<tr>
<td>dimensions</td>
<td>n.方面；空间，大小；维度，层面（dimension 的复数）<br/>v.将……做成特定尺寸；（在图表上）标出尺寸（dimension 的第三人称单数）</td>
<td></td>
</tr>
<tr>
<td>diminished</td>
<td>adj.减弱的；减退了的<br/>v.减少；削弱（diminish 的过去分词）</td>
<td></td>
</tr>
<tr>
<td>discretion</td>
<td>n.自行决定权，判断力；谨慎，慎重</td>
<td></td>
</tr>
<tr>
<td>discrimination</td>
<td>n.歧视，区别对待；区分，辨别；辨别力，鉴赏力</td>
<td>复数discriminations</td>
</tr>
<tr>
<td>displacement</td>
<td>n.被迫迁徙，流亡；取代，代替； 排水量；情感转移；电位移</td>
<td>复数displacements</td>
</tr>
<tr>
<td>display</td>
<td>v.展示，陈列；显露，表现；（计算机）显示；（为求偶）作炫耀行为<br/>n.展览，陈列；表演；（计算机屏幕上的）显示，显示器；流露，表现；炫耀行为</td>
<td>复数displays<br/>第三人称单数displays<br/>现在分词displaying<br/>过去式displayed<br/>过去分词displayed</td>
</tr>
<tr>
<td>disposal</td>
<td>n.处理，清除；（土地、财产等的）变卖，转让；&lt;文&gt;安排，安置；&lt;美&gt;污物碾碎器</td>
<td>复数disposals</td>
</tr>
<tr>
<td>distinction</td>
<td>n.差别，区分；杰出，卓越；特点；荣誉</td>
<td>复数distinctions</td>
</tr>
<tr>
<td>distortion</td>
<td>n.歪曲，曲解；变形，失真</td>
<td>复数distortions</td>
</tr>
<tr>
<td>distribution economic</td>
<td>(not find meaning.)</td>
<td></td>
</tr>
<tr>
<td>diversity</td>
<td>n.多样性，多样化；不同，差异</td>
<td>复数diversities</td>
</tr>
<tr>
<td>document</td>
<td>n.文件，公文，文献；证件，单据；（计算机）文件，文档<br/>v.记录，记载（详情）</td>
<td>复数documents<br/>第三人称单数documents<br/>现在分词documenting<br/>过去式documented<br/>过去分词documented</td>
</tr>
<tr>
<td>domain</td>
<td>n.领域，范围；领土，势力范围；（因特网上的）域；（函数的）定义域；地产<br/>【名】 （Domain）（英、法）多曼（人名）</td>
<td>复数domains</td>
</tr>
<tr>
<td>domestic</td>
<td>adj.国内的，本国的；家用的，家庭的；喜爱家庭生活的，乐于操持家务的；非野生的，驯养的<br/>n.家庭纠纷，家庭矛盾；佣人，家仆；&lt;美&gt;国货，本地产品</td>
<td>复数domestics<br/>比较级more domestic<br/>最高级most domestic</td>
</tr>
<tr>
<td>dominant</td>
<td>adj.占支配地位的，占优势的；（基因）显性的<br/>n.显性（性状），显性基因</td>
<td>复数dominants<br/>比较级more dominant<br/>最高级most dominant</td>
</tr>
<tr>
<td>draft</td>
<td>n.草稿，草案；汇票；&lt;美&gt;通风气流，穿堂风（=draught）；征兵；&lt;美&gt;（职业球队的）选拔队员制<br/>v.起草，草拟；选派，派遣；&lt;美&gt;征召，征召……入伍；&lt;美&gt;挑选，选拔（运动员）；作草图，绘样<br/>adj.（动物）驮重物的，负重的；（啤酒）散装的；草拟的</td>
<td>复数drafts<br/>第三人称单数drafts<br/>现在分词drafting<br/>过去式drafted<br/>过去分词drafted</td>
</tr>
<tr>
<td>dramatic</td>
<td>adj.巨大而突然的，急剧的；激动人心的，引人注目的，给人深刻印象的；有关戏剧的，戏剧表演的；夸张的</td>
<td></td>
</tr>
<tr>
<td>duration</td>
<td>n.持续，持续时间</td>
<td>复数durations</td>
</tr>
<tr>
<td>dynamic</td>
<td>adj.充满活力的，精力充沛的；动态的，发展变化的；力的，动力的<br/>n.动力，活力；相互作用，动态；动力学</td>
<td>复数dynamics<br/>比较级more dynamic<br/>最高级most dynamic</td>
</tr>
<tr>
<td>edition</td>
<td>n.版本，版次；一集，一期</td>
<td>复数editions</td>
</tr>
<tr>
<td>elements</td>
<td>n.要素；元素；（群体或社会中的）一伙；（恶劣的）天气；基本原理（element 的复数）</td>
<td></td>
</tr>
<tr>
<td>eliminate</td>
<td>v.剔除，根除；对……不予考虑，把……排除在外；（比赛中）淘汰；铲除，杀害；（生理）排除，排泄；消去</td>
<td>第三人称单数eliminates<br/>现在分词eliminating<br/>过去式eliminated<br/>过去分词eliminated</td>
</tr>
<tr>
<td>emerged</td>
<td>vt.出现，浮现；暴露；显现，显露（emerge 的过去式和过去分词）</td>
<td></td>
</tr>
<tr>
<td>emphasis</td>
<td>n.重要性，重点强调；重读，强调；（表达的）强有力</td>
<td>复数emphases</td>
</tr>
<tr>
<td>empirical</td>
<td>adj.经验主义的，以经验为依据的</td>
<td></td>
</tr>
<tr>
<td>enable</td>
<td>v.使能够，使可能；激活，启动；准许，授权</td>
<td>第三人称单数enables<br/>现在分词enabling<br/>过去式enabled<br/>过去分词enabled</td>
</tr>
<tr>
<td>encountered</td>
<td>v.遇到；曾遭遇（encounter 的过去式）</td>
<td></td>
</tr>
<tr>
<td>energy</td>
<td>n.能力，力气；精力，活力；能源；能，能量</td>
<td>复数energies</td>
</tr>
<tr>
<td>enforcement</td>
<td>n.执行，实施</td>
<td></td>
</tr>
<tr>
<td>enhanced</td>
<td>v.提高，增强（enhance 的过去式及过去分词）<br/>adj.提高的，增强的</td>
<td>比较级more enhanced<br/>最高级most enhanced</td>
</tr>
<tr>
<td>enormous</td>
<td>adj.巨大的，极大的；&lt;古&gt;凶暴的，极恶的</td>
<td></td>
</tr>
<tr>
<td>ensure</td>
<td>v.确保，保证；保护，使安全</td>
<td>第三人称单数ensures<br/>现在分词ensuring<br/>过去式ensured<br/>过去分词ensured</td>
</tr>
<tr>
<td>entities</td>
<td>n.实体；存在（entity 的复数形式）；字符实体</td>
<td></td>
</tr>
<tr>
<td>environment established</td>
<td>(not find meaning.)</td>
<td></td>
</tr>
<tr>
<td>equation</td>
<td>n.等式，方程（式）；等同（看待）；（必须考虑多种因素的）复杂局面（或问题）</td>
<td>复数equations</td>
</tr>
<tr>
<td>equipment</td>
<td>n.设备，用具；（对某人或某物的）装备过程；（做某事应具备的）素质，才能</td>
<td></td>
</tr>
<tr>
<td>equivalent</td>
<td>adj.等同的，等效的<br/>n.对等的人（或事物），对应的人（或事物）；当量（equivalent weight）</td>
<td>复数equivalents</td>
</tr>
<tr>
<td>erosion</td>
<td>n.侵蚀，腐蚀；削弱，降低；糜烂，溃疡</td>
<td></td>
</tr>
<tr>
<td>error</td>
<td>n.错误，差错；（棒球、网球等运动中的）失误</td>
<td>复数errors</td>
</tr>
<tr>
<td>estate</td>
<td>n.财产，遗产；大片私有土地，庄园；&lt;英&gt;住宅区，工业区；&lt;旧&gt;社会阶层；（生活）状况，条件</td>
<td>复数estates</td>
</tr>
<tr>
<td>estimate</td>
<td>v.估计；判断，评价<br/>n.估计，估价；估价单；看法，判断</td>
<td>复数estimates<br/>第三人称单数estimates<br/>现在分词estimating<br/>过去式estimated<br/>过去分词estimated</td>
</tr>
<tr>
<td>ethical</td>
<td>adj.道德的，伦理的；合乎道德的；有益于人（类）的，环保的；（药品）凭处方出售的</td>
<td></td>
</tr>
<tr>
<td>ethnic</td>
<td>adj.（有关）种族的，民族的；少数民族的；具有民族特色的，异国风味的；既非基督教亦非犹太教的，异教徒的<br/>n.少数民族成员，某民族群体的人</td>
<td>复数ethnics</td>
</tr>
<tr>
<td>evaluation</td>
<td>n.评价，评估</td>
<td>复数evaluations</td>
</tr>
<tr>
<td>eventually</td>
<td>adv.最终，结果</td>
<td></td>
</tr>
<tr>
<td>evidence</td>
<td>n.根据，证明；（呈上法庭的）证据，证词；迹象，痕迹<br/>v.证实，证明</td>
<td>第三人称单数evidences<br/>现在分词evidencing<br/>过去式evidenced<br/>过去分词evidenced</td>
</tr>
<tr>
<td>evolution</td>
<td>n.进化（论）；演变，发展；（气体的）释放，（热量的）散发；队形变换，位置变换；&lt;旧&gt;开方</td>
<td>复数evolutions</td>
</tr>
<tr>
<td>exceed</td>
<td>v.超过，超出；超越（限制）；优于，胜过</td>
<td>第三人称单数exceeds<br/>现在分词exceeding<br/>过去式exceeded<br/>过去分词exceeded</td>
</tr>
<tr>
<td>excluded</td>
<td>adj.排除的<br/>v.排除（exclude 的过去式和过去分词）；驱逐；拒绝接纳</td>
<td></td>
</tr>
<tr>
<td>exhibit</td>
<td>v.表现出；卖弄，炫耀；提出（证据等）；展览，展出<br/>n.展品；（法庭上出示的）证物；&lt;美&gt;展览，展出</td>
<td>复数exhibits<br/>第三人称单数exhibits<br/>现在分词exhibiting<br/>过去式exhibited<br/>过去分词exhibited</td>
</tr>
<tr>
<td>expansion</td>
<td>n.扩大，扩张；扩充，展开；扩张物；膨胀</td>
<td>复数expansions</td>
</tr>
<tr>
<td>expert</td>
<td>n.专家，能手，权威<br/>adj.专业的，熟练的<br/>v.当专家<br/>【名】 （Expert）（法、印、俄、罗、巴、荷）埃克斯佩（人名）</td>
<td>复数experts<br/>第三人称单数experts<br/>现在分词experting<br/>过去式experted<br/>过去分词experted<br/>比较级more expert<br/>最高级most expert</td>
</tr>
<tr>
<td>explicit</td>
<td>adj.清楚明白的，明确的，详述的；直截了当的，坦率的；赤裸裸表现性爱（或暴力）的，露骨的<br/>n.（手稿、早期印刷品或礼拜仪式上唱诗的）结束语</td>
<td></td>
</tr>
<tr>
<td>exploitation</td>
<td>n.剥削，压榨；开发，开采；（出于私利、不公正的）利用</td>
<td></td>
</tr>
<tr>
<td>export</td>
<td>v.出口；传播，输出；（在计算机中）导出，输出<br/>n.出口，输出；出口物，输出品；出口量，出口收入<br/>adj.出口的</td>
<td>复数exports<br/>第三人称单数exports<br/>现在分词exporting<br/>过去式exported<br/>过去分词exported</td>
</tr>
<tr>
<td>exposure</td>
<td>n.暴露，接触；曝光，揭发；报道，宣传；单张胶片；曝光时间，曝光量；受冻；朝向</td>
<td>复数exposures</td>
</tr>
<tr>
<td>external</td>
<td>adj.外部的，外面的；对外的，与外国有关的；外来的，外聘的；（药品等类似物质）外用的<br/>n.外表，外部特征</td>
<td>复数externals</td>
</tr>
<tr>
<td>extract</td>
<td>n.选段，引文；提取物，汁<br/>v.提取，提炼；取出，拔出；摘录；索取，设法得到；开（方），求（根）</td>
<td>复数extracts<br/>第三人称单数extracts<br/>现在分词extracting<br/>过去式extracted<br/>过去分词extracted</td>
</tr>
<tr>
<td>facilitate</td>
<td>v.使更容易，使便利；促进，推动</td>
<td>第三人称单数facilitates<br/>现在分词facilitating<br/>过去式facilitated<br/>过去分词facilitated</td>
</tr>
<tr>
<td>factors</td>
<td>n.因素（factor 的复数）<br/>v.做代理商；分解……的因子；把……作为因素考虑（factor 的第三人称单数）</td>
<td></td>
</tr>
<tr>
<td>features</td>
<td>n.产品特点，特征；容貌；嘴脸（feature 的复数）<br/>v.是……的特色，使突出（feature 的第三人称单数）</td>
<td></td>
</tr>
<tr>
<td>federal</td>
<td>adj.联邦（制）的；（与）联邦政府（有关的）的；中央集权式的；（美国内战时期）北部联邦政府的<br/>n.联邦探员，联邦政府官员；（美国南北战争时期）北部联邦政府支持者<br/>【名】  （Federal）（英）费德勒尔（人名）</td>
<td>复数federals</td>
</tr>
<tr>
<td>fees</td>
<td>n.[会计]费用（fee 的复数）；规费<br/>n.（Fees）人名；（德、法）费斯</td>
<td></td>
</tr>
<tr>
<td>file</td>
<td>n.文件夹（或箱、柜等）；（计算机的）文档；档案；纵列；锉刀；（与某政策领域相关的）议题，职责<br/>v.（把文件等）归档，存档；提起（诉讼），提出（申请）；发送（消息或报道）给报社；列队行进；锉平<br/>【名】 （File）（匈、塞）菲莱（人名）</td>
<td>复数files<br/>第三人称单数files<br/>现在分词filing<br/>过去式filed<br/>过去分词filed</td>
</tr>
<tr>
<td>final</td>
<td>adj.最终的，结束的；(出现次序)最后的，末尾的；决定性的，不可变更的；无比的，极度的<br/>n.决赛；期末考试，课程终结考试；主调音；当日报纸的末版；（飞机进入着陆跑道的）最终边，第五边</td>
<td>复数finals</td>
</tr>
<tr>
<td>financial</td>
<td>adj.财政的，金融的；&lt;澳新，非正式&gt;有钱的；&lt;澳新&gt;（俱乐部或社团成员）已缴费的<br/>n.（组织或个人的）财务状况；金融公司股票</td>
<td></td>
</tr>
<tr>
<td>finite</td>
<td>adj.有限的，有限制的；限定的<br/>n.有限之物</td>
<td></td>
</tr>
<tr>
<td>flexibility</td>
<td>n.灵活性；弹性，柔性</td>
<td></td>
</tr>
<tr>
<td>fluctuations</td>
<td>n.[物]波动（fluctuation 的复数）；变动；起伏现象</td>
<td></td>
</tr>
<tr>
<td>focus</td>
<td>n.重点，中心点；关注，注意；震源；目的，意图；焦距；病灶；调焦装置；目的明确，专注；（椭圆、抛物线等曲线的）焦点<br/>v.集中，关注；聚焦，调焦；&lt;语言学&gt;以（句子的一部分）为焦点（或重心）<br/>【名】 （Focus）（瑞典）福库斯 (人名)</td>
<td>复数focuses或foci<br/>第三人称单数focuses或focusses<br/>现在分词focusing或focussing<br/>过去式focused或focussed<br/>过去分词focused或focussed</td>
</tr>
<tr>
<td>format</td>
<td>n.总体安排，计划，设计；（书或杂志的）开本，版式；（录像、激光唱片、磁带等的）格式<br/>v.为……编排格式；格式化</td>
<td>复数formats<br/>第三人称单数formats<br/>现在分词formatting<br/>过去式formatted<br/>过去分词formatted</td>
</tr>
<tr>
<td>formula</td>
<td>n.计划，方案；配方，处方；公式，方程式；分子式，结构式；配方奶，代乳品；（特定场合的）惯用词语，套话；（影片、书籍等的）套路</td>
<td>复数formulas或formulae</td>
</tr>
<tr>
<td>forthcoming</td>
<td>adj.即将发生的；乐于提供信息的，愿意提供帮助的；现成的，可得到的<br/>n.来临</td>
<td></td>
</tr>
<tr>
<td>foundation</td>
<td>n.地基，基础；基本原理，根据；基金会；建立，创办；（化妆打底用的）粉底霜</td>
<td>复数foundations</td>
</tr>
<tr>
<td>founded</td>
<td>adj.有基础的<br/>v.建立；创立（found 的过去式和过去分词）</td>
<td></td>
</tr>
<tr>
<td>framework</td>
<td>n.(建筑物或物体的）构架，结构；参照标准，准则；(社会、法律、政治等）框架</td>
<td>复数frameworks</td>
</tr>
<tr>
<td>function</td>
<td>n.功能，职责；宴会，典礼；函数，应变量；由其他事情造成的结果；子例行程序，子例程；官能团，功能团<br/>v.工作，运转；行使职责，发挥功能</td>
<td>复数functions<br/>第三人称单数functions<br/>现在分词functioning<br/>过去式functioned<br/>过去分词functioned</td>
</tr>
<tr>
<td>fundamental</td>
<td>adj.根本的，基本的；必需的，必不可少的；不能再分的<br/>n.基本原理；基音，基频</td>
<td>复数fundamentals<br/>比较级more fundamental<br/>最高级most fundamental</td>
</tr>
<tr>
<td>funds</td>
<td>n.[会计]资金，现金（fund 的复数）；基金<br/>v.资助（fund 的三单形式）；提供资金</td>
<td></td>
</tr>
<tr>
<td>furthermore</td>
<td>adv.此外，而且</td>
<td></td>
</tr>
<tr>
<td>gender</td>
<td>n.性别；（语法中的）性；（总称）男性，女性</td>
<td>复数genders<br/>第三人称单数genders<br/>现在分词gendering<br/>过去式gendered<br/>过去分词gendered</td>
</tr>
<tr>
<td>generated</td>
<td>v.产生；引发；生成（generate 的过去式及过去分词）</td>
<td></td>
</tr>
<tr>
<td>generation</td>
<td>n.一代（人）；一代人的时间；（产品发展的）代；产生</td>
<td>复数generations</td>
</tr>
<tr>
<td>global</td>
<td>adj.全球的，全世界的；全面的，整体的；（计算机）全局的；球形的</td>
<td></td>
</tr>
<tr>
<td>goals</td>
<td>n.目标，[心理] 目的；进球，射中次数</td>
<td></td>
</tr>
<tr>
<td>grade</td>
<td>n.等级，品级；（工作岗位，官衔等的）级别，职别；成绩，分数；（美国学制）年级；斜坡，坡度；（疾病的）程度，阶段；与纯种杂交改良的牛<br/>v.按照级别安排或分配，分类；给……评分；设定（路面）坡度；（尤指色彩）从一个等级逐渐进入另一个等级；（家畜）与优良品种杂交<br/>【名】 （Grade）（英）格雷德，（法、德、西、葡、塞、瑞典）格拉德（人名）</td>
<td>复数grades<br/>第三人称单数grades<br/>现在分词grading<br/>过去式graded<br/>过去分词graded</td>
</tr>
<tr>
<td>granted</td>
<td>adv.的确，诚然<br/>conj.因为（granted that）<br/>v.授予，给予；承认（grant 的过去式和过去分词形式）</td>
<td></td>
</tr>
<tr>
<td>guarantee</td>
<td>v.确保，保证；担保，为……作保；保修，包换<br/>n.保证，担保；保修单，质量保证书；担保金，抵押品</td>
<td>复数guarantees<br/>第三人称单数guarantees<br/>现在分词guaranteeing<br/>过去式guaranteed<br/>过去分词guaranteed</td>
</tr>
<tr>
<td>guidelines</td>
<td>n.指导方针<br/>参考</td>
<td></td>
</tr>
<tr>
<td>hence</td>
<td>adv.因此；之后</td>
<td></td>
</tr>
<tr>
<td>hierarchical</td>
<td>adj.分等级的，等级制度的</td>
<td></td>
</tr>
<tr>
<td>highlighted</td>
<td>v.突出，强调；使显著，醒目；用荧光笔标记；挑染（highlight 的过去式和过去分词）</td>
<td></td>
</tr>
<tr>
<td>hypothesis</td>
<td>n.假说，假设；（凭空的）猜想，猜测；前提</td>
<td>复数hypotheses</td>
</tr>
<tr>
<td>identical</td>
<td>adj.完全相同的；同一的；（双胞胎）同卵的；恒等的</td>
<td></td>
</tr>
<tr>
<td>identified</td>
<td>adj.被识别的；经鉴定的；被认同的<br/>v.鉴定；辨认（identify 的过去式和过去分词）</td>
<td></td>
</tr>
<tr>
<td>ideology</td>
<td>n.意识形态，思想体系；&lt;古&gt;观念学；&lt;古&gt;空想</td>
<td>复数ideologies</td>
</tr>
<tr>
<td>ignored</td>
<td>v.忽略；不顾；不理会（ignore 的过去式和过去分词）</td>
<td></td>
</tr>
<tr>
<td>illustrated</td>
<td>v.加插图于……；（用示例、图画等）说明；表明……的真实（或存在）；为……例证（illustrate 的过去式及过去分词）<br/>adj.有插图的</td>
<td></td>
</tr>
<tr>
<td>image</td>
<td>n.形象，印象；影像，映像，图像；比喻，意象；画像，塑像，雕像；酷似另一个人的人；（人或事物）外形，外表；像点；硬盘备份；（圣经）偶像<br/>v.作……的像，描绘……的形象；（以探测器或电磁束）扫描出……的直观图；幻想，想像<br/>【名】 （Image）（法）伊马热（人名）</td>
<td>复数images<br/>第三人称单数images<br/>现在分词imaging<br/>过去式imaged<br/>过去分词imaged</td>
</tr>
<tr>
<td>immigration</td>
<td>n.移民（入境）；移民人数；移民局入境检查，移民局入境检查处</td>
<td></td>
</tr>
<tr>
<td>impact</td>
<td>n.撞击，冲击力；巨大影响，强大作用<br/>v.冲击，撞击；挤入，压紧；（对……）产生影响</td>
<td></td>
</tr>
<tr>
<td>implementation</td>
<td>n.实施，执行</td>
<td></td>
</tr>
<tr>
<td>implications</td>
<td>n.暗指，暗示；蕴含，含义；（可能带来的）影响（implication 的复数）</td>
<td></td>
</tr>
<tr>
<td>implicit</td>
<td>adj.含蓄的，未言明的；内含的，固有的；无疑问的，无保留的；（函数）隐式的，隐的</td>
<td></td>
</tr>
<tr>
<td>implies</td>
<td>v.意味着；蕴含；暗指（imply 的第三人称单数）</td>
<td></td>
</tr>
<tr>
<td>imposed</td>
<td>v.欺骗；把……强加于（impose 的过去式和过去分词）</td>
<td></td>
</tr>
<tr>
<td>incentive</td>
<td>n.激励，刺激</td>
<td>复数incentives</td>
</tr>
<tr>
<td>incidence</td>
<td>n.发生率；入射</td>
<td>复数incidences</td>
</tr>
<tr>
<td>inclination</td>
<td>n.倾向，意愿；趋向，趋势；斜坡，斜度；轻微向下的动作；轨道交角</td>
<td>复数inclinations</td>
</tr>
<tr>
<td>income</td>
<td>n.收入，收益</td>
<td>复数incomes</td>
</tr>
<tr>
<td>incompatible</td>
<td>adj.不相容的，不能共存的；不能和谐相处的，合不来的；不兼容的，互斥的<br/>n.互不相容的人或事物</td>
<td></td>
</tr>
<tr>
<td>incorporated</td>
<td>adj.组成公司的，股份有限的；合并的<br/>v.包含，合并；组成公司；掺和，混合（成分）（incorporate 的过去式和过去分词）</td>
<td></td>
</tr>
<tr>
<td>index</td>
<td>n.索引；（物价和工资等）指数；指标，量度；幂，根指数；指针<br/>v.为……编索引，将……编入索引；使指数化，将（工资）等与（物价水平等）挂钩；（机器，部件）转位</td>
<td>复数indexes或indices<br/>第三人称单数indexes<br/>现在分词indexing<br/>过去式indexed<br/>过去分词indexed</td>
</tr>
<tr>
<td>indicate</td>
<td>v.表明，标示；象征，暗示；间接提及，示意；指示，指出；&lt;英&gt;（用灯光或手臂）打行车转向信号；有必要，被建议</td>
<td>第三人称单数indicates<br/>现在分词indicating<br/>过去式indicated<br/>过去分词indicated</td>
</tr>
<tr>
<td>individual</td>
<td>adj.单独的，个别的；个人的；独特的，与众不同的<br/>n.个人，个体；与众不同的人，有个性的人；某种类型的人</td>
<td>复数individuals<br/>比较级more individual<br/>最高级most individual</td>
</tr>
<tr>
<td>induced</td>
<td>adj.感应的；诱发型<br/>v.引诱；说服（induce 的过去分词）</td>
<td></td>
</tr>
<tr>
<td>inevitably</td>
<td>adv.不可避免地，必然地；意料之中</td>
<td></td>
</tr>
<tr>
<td>inferred</td>
<td>adj.推论的；推测出的<br/>v.推测（infer 的过去式和过去分词）</td>
<td></td>
</tr>
<tr>
<td>infrastructure</td>
<td>n.下面结构；永久性军事设施；基础设施，基础建设</td>
<td>复数infrastructures</td>
</tr>
<tr>
<td>inherent</td>
<td>adj.内在的，固有的；&lt;法律&gt;（权利，特权）固定属于（某人）的；（形容词）作定语和表语时意义相同的</td>
<td></td>
</tr>
<tr>
<td>inhibition</td>
<td>n.拘谨，拘束感；阻止，抑制；&lt;法律&gt;（尤指对处理指明土地或财产的）禁令</td>
<td>复数inhibitions</td>
</tr>
<tr>
<td>initial</td>
<td>adj.开始的，最初的；（字母）位于词首的<br/>n.（姓名的）首字母<br/>v.用姓名的首字母作标记（或签名）于</td>
<td>复数initials<br/>第三人称单数initials<br/>现在分词initialling或initialing<br/>过去式initialled或initialed<br/>过去分词initialled或initialed</td>
</tr>
<tr>
<td>initiatives</td>
<td>n.积极性；主动权（initiative 的复数）；创始</td>
<td></td>
</tr>
<tr>
<td>injury</td>
<td>n.（身体上的）伤，损害；&lt;法律&gt;（对感情的）伤害，挫伤</td>
<td>复数injuries</td>
</tr>
<tr>
<td>innovation</td>
<td>n.新事物，新方法；革新，创新</td>
<td>复数innovations</td>
</tr>
<tr>
<td>input</td>
<td>n.投入，输进；输入的信息；（为帮助某人做出决定而提供的）建议，意见；讯息输入端；（输入机器供其使用的）电力；输入框<br/>v.输入（信息）</td>
<td>复数inputs<br/>第三人称单数inputs<br/>现在分词inputting<br/>过去式input或inputted<br/>过去分词input或inputted</td>
</tr>
<tr>
<td>insert</td>
<td>v.插入，嵌入；（在文章中）添加，加插；使参与（活动）；（肌肉或其他器官）附着于（尤指移动部分）<br/>n.插入物；（尤指）插页，附加页；（电影等的）插入镜头</td>
<td>复数inserts<br/>第三人称单数inserts<br/>现在分词inserting<br/>过去式inserted<br/>过去分词inserted</td>
</tr>
<tr>
<td>insights</td>
<td>n.洞察力；眼力；深刻见解（insight 的复数）</td>
<td></td>
</tr>
<tr>
<td>inspection</td>
<td>n.视察；检查，审视</td>
<td>复数inspections</td>
</tr>
<tr>
<td>instance</td>
<td>n.例子，实例<br/>v.举……为例</td>
<td>复数instances<br/>第三人称单数instances<br/>现在分词instancing<br/>过去式instanced<br/>过去分词instanced</td>
</tr>
<tr>
<td>institute</td>
<td>n.研究所，学院，协会；（尤指与法律相关的）注释，论述<br/>v.制定（制度、规则等）；提出（诉讼）；任命，授予……职位（尤指圣职）</td>
<td>复数institutes<br/>第三人称单数institutes<br/>现在分词instituting<br/>过去式instituted<br/>过去分词instituted</td>
</tr>
<tr>
<td>instructions</td>
<td>n.指令；说明（instruction 的复数形式）</td>
<td></td>
</tr>
<tr>
<td>integral</td>
<td>adj.必需的，必要的；作为组成部分的；完整的；整的，积分的<br/>n.积分；完整</td>
<td>复数integrals<br/>比较级more integral<br/>最高级most integral</td>
</tr>
<tr>
<td>integration</td>
<td>n.结合，融合；取消种族隔离；（数）积分法，求积分；（心理分析）整合</td>
<td></td>
</tr>
<tr>
<td>integrity</td>
<td>n.正直，诚实；完整，完全；职业操守；（电子数据的）集成度</td>
<td>复数integrities</td>
</tr>
<tr>
<td>intelligence</td>
<td>n.智力，才智；智能；情报，谍报；情报机构</td>
<td></td>
</tr>
<tr>
<td>intensity</td>
<td>n.强烈，剧烈；（光、声音等的）强度</td>
<td>复数intensities</td>
</tr>
<tr>
<td>interaction</td>
<td>n.互动，交流；相互影响，相互作用</td>
<td>复数interactions</td>
</tr>
<tr>
<td>intermediate</td>
<td>adj.居中的，中间的；中等程度的，中级的<br/>n.中级水平者，中级学生；中间事物；（化合物）中间体<br/>v.充当调解人，斡旋</td>
<td>复数intermediates<br/>第三人称单数intermediates<br/>现在分词intermediating<br/>过去式intermediated<br/>过去分词intermediated</td>
</tr>
<tr>
<td>internal</td>
<td>adj.内部的，体内的；内政的，国内的；本身的，本质的；内心的；&lt;英&gt;（大学生）本校生的<br/>n.内部部件，内部特征；内脏</td>
<td></td>
</tr>
<tr>
<td>interpretation</td>
<td>n.解释，理解；表演，演奏，艺术处理；口译</td>
<td>复数interpretations</td>
</tr>
<tr>
<td>interval</td>
<td>n.间隔，间隙；幕间休息，中场休息；音程</td>
<td>复数intervals</td>
</tr>
<tr>
<td>intervention</td>
<td>n.干预，介入；调停，斡旋；（为改善情况尤指病痛采取的）措施，做法</td>
<td>复数interventions</td>
</tr>
<tr>
<td>intrinsic</td>
<td>adj.内在的，固有的</td>
<td></td>
</tr>
<tr>
<td>investigation</td>
<td>n.调查，审查；科学研究，学术研究</td>
<td>复数investigations</td>
</tr>
<tr>
<td>investment</td>
<td>n.投资；值得买的东西；（时间、精力的）投入；&lt;旧&gt;包围，封锁</td>
<td>复数investments</td>
</tr>
<tr>
<td>invoked</td>
<td>v.叫唤（invoke 的过去式，过去分词）</td>
<td></td>
</tr>
<tr>
<td>involved</td>
<td>adj.复杂的；与……关系密切的；专心于……的，忙于……的；卷入的，参与的<br/>v.牵涉，包含（involve 的过去式和过去分词形式）</td>
<td></td>
</tr>
<tr>
<td>isolated</td>
<td>adj.遥远的，偏僻的；与世隔绝的，孤寂的；单独的，只出现一次的<br/>v.使……孤立；使……分离；将……剔出（isolate 的过去式和过去分词）</td>
<td></td>
</tr>
<tr>
<td>issues</td>
<td>n.议题，问题；债券；争点（issue 的复数）<br/>v.发行；分发；流出（issue 的第三人称单数）</td>
<td></td>
</tr>
<tr>
<td>items</td>
<td>n.项目；条目；（电视、广播或报纸上的一条）新闻（item 的复数）<br/>v.&lt;古&gt;估算；逐条记载（item 的第三人称单数）</td>
<td></td>
</tr>
<tr>
<td>job</td>
<td>n.工作，职业；零工，任务；职责，责任；&lt;非正式&gt;罪行，（尤指）盗窃；&lt;非正式&gt; 东西，物件；费力的事；幸运的事；刺，捅；&lt;非正式&gt;东西，物件<br/>v.刺，捅；（尤指经纪人小规模操作）买卖股票；&lt;非正式&gt;欺骗，出卖；假公济私，营私舞弊<br/>【名】 （Job）（英）乔布，（法、葡）若布，(?-1605)约伯&lt;俄&gt;俄罗斯正教会莫斯科牧首，（德、塞、捷、荷、意）约布（人名)</td>
<td>复数jobs<br/>第三人称单数jobs<br/>现在分词jobbing<br/>过去式jobbed<br/>过去分词jobbed</td>
</tr>
<tr>
<td>journal</td>
<td>n.杂志，期刊，报纸；日记，日志；（会计）日记账</td>
<td>复数journals<br/>第三人称单数journals<br/>现在分词journaling<br/>过去式journaled<br/>过去分词journaled</td>
</tr>
<tr>
<td>justification</td>
<td>n.正当理由，合理解释；证明为正当，辩护；齐行，整版；（上帝眼中的）称义</td>
<td>复数justifications</td>
</tr>
<tr>
<td>label</td>
<td>n.标签，标牌；称号，绰号；商标，品牌；唱片公司；（计算机）标记；示踪剂；带垂饰的横带<br/>v.贴标签；把……不公正地称为；用示踪剂使（物质等）示踪<br/>【名】 （Label）（美、法、巴）拉贝尔（人名）</td>
<td>复数labels<br/>第三人称单数labels<br/>现在分词labelling或labeling<br/>过去式labelled或labeled<br/>过去分词labelled或labeled</td>
</tr>
<tr>
<td>labour</td>
<td>n.劳动；任务，（一段时间的）工作；劳工，工人，劳动力；分娩，临盆；工会；（英国）工党<br/>v.劳动，劳作；努力做（困难的事）；费力地行进；误以为，为……所蒙蔽；一再重申，反复说明；&lt;古&gt;耕（地）<br/>adj.工党的，支持工党的</td>
<td>复数labours<br/>第三人称单数labours<br/>现在分词labouring<br/>过去式laboured<br/>过去分词laboured</td>
</tr>
<tr>
<td>layer</td>
<td>n.层；层次，等级；摆放者，铺设者，产卵者；压条<br/>v.分层放置；把（头发）分层剪短；用压条培育（植物）</td>
<td>复数layers<br/>第三人称单数layers<br/>现在分词layering<br/>过去式layered<br/>过去分词layered</td>
</tr>
<tr>
<td>lecture</td>
<td>n.讲座，讲课，演讲；训斥，告诫<br/>v.（尤指在大学里）开讲座，讲课；训斥，告诫</td>
<td>复数lectures<br/>第三人称单数lectures<br/>现在分词lecturing<br/>过去式lectured<br/>过去分词lectured</td>
</tr>
<tr>
<td>legal</td>
<td>adj.法律允许的，合法的；与法律有关的，法律的；（与衡平法相对）普通法或成文法确认的；神学律法的，与神学律法有关的；&lt;美&gt;（纸张）标准大小的<br/>【名】 （Legal）（法）勒加尔（人名）</td>
<td></td>
</tr>
<tr>
<td>legislation</td>
<td>n.法规，法律；立法，制订法律</td>
<td></td>
</tr>
<tr>
<td>levy</td>
<td>v.征收（罚款、税款等）；扣押财产（以执行判决）；&lt;古&gt;征兵；发动（战争）<br/>n.征收额，税款；（为执行判决而进行的）财产扣押；征兵<br/>【名】 （Levy）（英、以）利维，（西、意、葡、芬、法、瑞典）莱维（人名）</td>
<td>复数levies<br/>第三人称单数levies<br/>现在分词levying<br/>过去式levied<br/>过去分词levied</td>
</tr>
<tr>
<td>liberal</td>
<td>adj.思想开明的；自由主义的，支持变革的；（加拿大、英国等国）自由党的；慷慨的，大量给予的；通识（教育）的，文科的；不确切的，不拘泥字面的；自由主义神学的<br/>n.思想开明的人；自由主义者，支持变革的人；（加拿大、英国等国的）自由党党员，自由党支持者<br/>【名】 （Liberal）（葡）利贝拉尔（人名）</td>
<td>复数liberals<br/>比较级more liberal<br/>最高级most liberal</td>
</tr>
<tr>
<td>licence</td>
<td>n.许可证，执照；许可，准许；（言论或行动的）自由，不受拘束；（做错事的）诱因，借口<br/>v.给……发许可证，批准；就……发许可证；按协议特许，授权</td>
<td>复数licences<br/>第三人称单数licences<br/>现在分词licencing<br/>过去式licenced<br/>过去分词licenced</td>
</tr>
<tr>
<td>likewise</td>
<td>adv.同样地，类似地；（表示感觉相同）我也是，我有同感；也，还</td>
<td></td>
</tr>
<tr>
<td>link</td>
<td>v.连接；与……有关联；挽住，钩住<br/>n.（事物间的）联系，关系；（交通上的）联系；（链状物的）环，节；（超文本）链接；&lt;美&gt;一节香肠；令（长度单位，1令等于1测链的百分之一，即7.92英寸）；（行路时照明用）沥青和麻屑火把<br/>【名】 （Link）（英、德、塞、捷、匈、瑞典）林克（人名）</td>
<td>复数links<br/>第三人称单数links<br/>现在分词linking<br/>过去式linked<br/>过去分词linked</td>
</tr>
<tr>
<td>location</td>
<td>n.地点，位置；（电影的）外景拍摄地；定位；（计算机内存里的）地址</td>
<td>复数locations</td>
</tr>
<tr>
<td>logic</td>
<td>n.逻辑，（做某事的）道理；推理方法，逻辑学；（事实或事件的）规律，相互联系；（计算机或电器的）逻辑操作</td>
<td>复数logics</td>
</tr>
<tr>
<td>maintenance</td>
<td>n.维护，保养；保持，维持；（依法应负担的）生活费，抚养费；包揽诉讼罪，非法资助诉讼罪</td>
<td></td>
</tr>
<tr>
<td>major</td>
<td>adj.重大的，主要的；严重的；大调的，大音阶的； &lt;旧&gt;（公立学校中置于学生姓氏后，表示两兄弟中）大的，年长的；主修的；大（项）的<br/>n.主修科目，专业；陆军少校，（美国）空军少校；（某专业的）主修学生；&lt;美，非正式&gt;职业棒球大联盟；大型公司，重要企业；成年人，已达到法定年龄者；（军乐队中主管某一乐器部的）乐器长；大调，大音程； 大项，大前提；主要世界性组织（或公司、比赛）<br/>v.（在美国大学）主修，专攻<br/>【名】  (Major) （英）梅杰，（西）马霍尔，（法）马若尔，（捷、德、塞、瑞典）马约尔（人名）</td>
<td>复数majors<br/>第三人称单数majors<br/>现在分词majoring<br/>过去式majored<br/>过去分词majored</td>
</tr>
<tr>
<td>manipulation</td>
<td>n.操纵；推拿；（熟练的）控制，使用；（对账目等的）伪造，篡改；（对储存在计算机上的信息的）操作，处理</td>
<td></td>
</tr>
<tr>
<td>manual</td>
<td>adj.手工的，体力的；手动的，用手操作的<br/>n.使用手册，说明书；手动换挡的车辆；风琴键盘；（牧师主持圣礼时用）礼仪书</td>
<td>复数manuals</td>
</tr>
<tr>
<td>marginal</td>
<td>adj.小的，微不足道的；（活动、花费、税项等）边际的；非主流的，边缘的；以相差无几的票数获胜（或失败）的；写在页边空白的；贫瘠的<br/>n.岸边水生植物；边缘席位</td>
<td>复数marginals<br/>比较级more marginal<br/>最高级most marginal</td>
</tr>
<tr>
<td>mature</td>
<td>adj.成熟的，理智的；成年的，发育完全的；发酵成熟的，酿成的；中老年的；技艺精湛的，技巧娴熟的；审慎考虑的，深思熟虑的；到期（应该支付）的；（某些食品或饮料）可立即食用的；（经济，行业，市场）成熟的，发展余地不大的<br/>v.（使）成熟，（使）长成；变理智，（举止）变成熟；酿成，制成；到期</td>
<td>第三人称单数matures<br/>现在分词maturing<br/>过去式matured<br/>过去分词matured<br/>比较级maturer或more mature<br/>最高级maturest或most mature</td>
</tr>
<tr>
<td>maximum</td>
<td>adj.最大限度的；（数量）极大的，极多的<br/>n.最大量，最大限度<br/>adv.最多，充其量</td>
<td>复数maxima或maximums</td>
</tr>
<tr>
<td>mechanism</td>
<td>n.机械装置，机件；途径，方法；（生物体内的）机制，构造；机械论；（产生自然现象等的）物理过程</td>
<td>复数mechanisms</td>
</tr>
<tr>
<td>media</td>
<td>n.新闻媒体，传媒（medium的复数形式）；媒体工作者；（尤指血管壁的）中间层（复数mediae）；浊塞音；中脉</td>
<td></td>
</tr>
<tr>
<td>mediation</td>
<td>n.调解，仲裁</td>
<td></td>
</tr>
<tr>
<td>medical</td>
<td>adj.医学的，医疗的；内科的<br/>n.体格检查，健康检查</td>
<td>复数medicals</td>
</tr>
<tr>
<td>medium</td>
<td>n.媒介，媒体；方法，手段；（艺术创作）材料，素材；灵媒，巫师；培养基；环境；中等，中号；存储（或打印）介质；（颜料）溶剂（如油或水）；（品质、状态）中等，中庸<br/>adj.中等的，中间的，适中的；五分熟的，半熟的；（程度、强度或数量）平均的；（颜色）不深不浅的，适中的；（投球，投球手）中速的</td>
<td>复数media或mediums</td>
</tr>
<tr>
<td>mental</td>
<td>adj.存在于大脑中的，思考的；精神的，思想的，智力的；精神病治疗的，精神健康的；&lt;非正式&gt;疯癫的，不正常的</td>
<td></td>
</tr>
<tr>
<td>migration</td>
<td>n.移民，迁徙；（计算机系统的）改变，（程序或硬件的）迁移，转移</td>
<td>复数migrations</td>
</tr>
<tr>
<td>military</td>
<td>adj.军事的，军队的；陆军的；军人般的，军人作风的<br/>n.军人，军方</td>
<td>复数militaries或military</td>
</tr>
<tr>
<td>minimal</td>
<td>adj.极小的，极少的；极简抽象艺术的；简朴的，朴实无华的；极简的（指短小乐句不断重复并逐渐变化）；最小差别的</td>
<td></td>
</tr>
<tr>
<td>minimised</td>
<td>vt.使缩到最小；成极小；求最小值</td>
<td></td>
</tr>
<tr>
<td>minimum</td>
<td>adj.最小的，最低限度的<br/>n.最小值，最低限度<br/>adv.最低，至少</td>
<td>复数minima或minimums</td>
</tr>
<tr>
<td>ministry</td>
<td>n.（政府的）部，部办公楼；（全体）牧师；神职，神职任期；一任首相的执政期；照料，服务</td>
<td>复数ministries</td>
</tr>
<tr>
<td>minorities</td>
<td>n.少数（minority 的复数形式）；少数民族；少数族裔</td>
<td></td>
</tr>
<tr>
<td>mode</td>
<td>n.方式，做法；（机器、设备的）运行方式，状态；（衣着、艺术等的）形式，风格；&lt;非正式&gt;（思想、情感或行为的）状态，状况；（音乐的）调式；众数（一组数字中出现次数最多的数）；（逻）（模态命题的）式，形式；（物理）模（式），波型；（模态命题的）式，形式<br/>【名】 （Mode）（英、德、法、乍、瑞典）莫德（人名）</td>
<td>复数modes</td>
</tr>
<tr>
<td>modified</td>
<td>adj.改进的，修改的；改良的<br/>v.修改；缓和（modify 的过去式和过去分词）</td>
<td></td>
</tr>
<tr>
<td>monitoring</td>
<td>n.监视，[自]监控；检验，检查<br/>v.监视，[通信][军]监听，监督（monitor 的 ing 形式）</td>
<td></td>
</tr>
<tr>
<td>motivation</td>
<td>n.动力，诱因；积极性，干劲；&lt;南非&gt;（支持请求或倡议的）事实与理由</td>
<td>复数motivations</td>
</tr>
<tr>
<td>mutual</td>
<td>adj.相互的，彼此的；共同的，共有的；（保险公司、建筑协会等）互助的<br/>n.互助公司</td>
<td></td>
</tr>
<tr>
<td>negative</td>
<td>adj.否定的，拒绝的；有害的，不良的；悲观的，消极的；否定形式的，否定词的；（实验或测试的结果）阴性的；阴极的，负极的；负电的（电子比质子多）；负的，小于零的；&lt;美&gt;根本不；亏损的；（常用于军事语境）不，没有；（照片）负像的，底片的；（天文）负的；&lt;英&gt;（议会）（立法）自动生效的；Rh阴性的<br/>n.底片，负片；否定词，否定句；坏处，害处；（化验或科学试验中的）阴性结果；（语法）否定语，否定词缀；（逻）（对命题的）否定；负电；负数<br/>v.否绝，拒绝；否定，推翻（一种理论或说法）；消除，抵消</td>
<td>复数negatives<br/>第三人称单数negatives<br/>现在分词negativing<br/>过去式negatived<br/>过去分词negatived<br/>比较级more negative<br/>最高级most negative</td>
</tr>
<tr>
<td>network</td>
<td>n.网络，网状系统；人际关系网，联络网；计算机网络，互联网；广播网，电视网<br/>v.使（计算机）联网；（尤指工作中）建立关系网，建立人脉；对（电视或广播节目）进行联播</td>
<td></td>
</tr>
<tr>
<td>neutral</td>
<td>adj.中立的，不偏不倚的；中性的，不带感情色彩的；暗淡的，素净的；（化学中）中性的，非酸非碱的；不带电的<br/>n.（车辆排挡的）空挡；中立者，中立国；素净色，中和色；不活动，停滞；不带电的接触点</td>
<td>复数neutrals<br/>比较级more neutral<br/>最高级most neutral</td>
</tr>
<tr>
<td>nevertheless</td>
<td>adv.然而，不过</td>
<td></td>
</tr>
<tr>
<td>nonetheless</td>
<td>adv.然而，尽管如此</td>
<td></td>
</tr>
<tr>
<td>normal</td>
<td>adj.正常的，标准的；（身心）健康的，（人）普通的；（线或线性特征）正交的，垂直的；（盐溶液）与血液的盐浓度相同的；正（断层）的；平常的，通常的<br/>n.常态，通常标准；&lt;非正式&gt;正常人，循规蹈矩者；法线，正交<br/>【名】 （Normal）（德）诺马尔（人名）</td>
<td>复数normals<br/>比较级more normal<br/>最高级most normal</td>
</tr>
<tr>
<td>norms</td>
<td>n.[标准]标准，规范；基准（norm 复数形式）</td>
<td></td>
</tr>
<tr>
<td>notion</td>
<td>n.概念，想法；缝纫用品；一时的念头，突发的奇想</td>
<td>复数notions</td>
</tr>
<tr>
<td>notwithstanding</td>
<td>prep.虽然，尽管<br/>adv.尽管如此<br/>conj.虽然，尽管</td>
<td></td>
</tr>
<tr>
<td>nuclear</td>
<td>adj.核子的，原子核的；核武器的；原子能的，核能的；核心的，中心的；细胞核的，构成细胞核的</td>
<td></td>
</tr>
<tr>
<td>objective</td>
<td>n.目的，目标；出击目标（尤指在军事攻击中)；（望远镜或显微镜中的）物镜；出击目标（尤指在军事攻击中）；宾格<br/>adj.客观的，不带个人情感的；客观存在的；宾格的；目标的</td>
<td>复数objectives<br/>比较级more objective<br/>最高级most objective</td>
</tr>
<tr>
<td>obtained</td>
<td>v.获得（obtain 的过去分词）</td>
<td></td>
</tr>
<tr>
<td>obvious</td>
<td>adj.明显的，显然的；明确表示的，毫不掩饰的；平淡无奇的，缺乏想象力的；合情合理的，当然的</td>
<td></td>
</tr>
<tr>
<td>occupational</td>
<td>adj.职业的，由职业引起的；占领的</td>
<td></td>
</tr>
<tr>
<td>occur</td>
<td>v.（尤指意外地）发生；存在，出现；（想法）产生</td>
<td>第三人称单数occurs<br/>现在分词occurring<br/>过去式occurred<br/>过去分词occurred</td>
</tr>
<tr>
<td>odd</td>
<td>adj.奇怪的，反常的；偶然出现的，偶尔发生的；奇形怪状的，各种各样的；不成对的，不同类的；奇数的；可得到的，可用的；少量的，不重要的；（尤指在双方至少各进一球的情况下）一球险胜的<br/>adv.（用于数字后）大约，左右<br/>【名】 （Odd）（英、西、挪、瑞典）奥德（人名）</td>
<td></td>
</tr>
<tr>
<td>offset</td>
<td>v.补偿，抵销；衬托出；使偏离直线方向，使与…不在一条直线上；（墨水，刚印好的页面）转印下一页<br/>n.抵消物，补偿；偏离量，偏离距离；（测绘）支距；（电压或电流的）偏离；侧枝，短匐茎；（山的）支脉；（建筑）壁阶；胶印法<br/>adj.胶印的，平版印刷的；偏离中心的，偏置的</td>
<td>复数offsets<br/>第三人称单数offsets<br/>现在分词offsetting<br/>过去式offset<br/>过去分词offset</td>
</tr>
<tr>
<td>ongoing</td>
<td>adj.持续存在的，仍在进行的，不断发展的</td>
<td></td>
</tr>
<tr>
<td>option</td>
<td>n.可选择的事物；选择，选择权；（将来的）买卖选择权利，期权；（计算机程序中的）选项；&lt;英&gt;选修课；（购买新设备，尤其是汽车时提供的）附件，配件<br/>v.买卖（某物的）期权</td>
<td>复数options<br/>第三人称单数options<br/>现在分词optioning<br/>过去式optioned<br/>过去分词optioned</td>
</tr>
<tr>
<td>orientation</td>
<td>n.目标，定位；方向，朝向；（基本的）态度，倾向；（岗前、学前、课前等的）情况介绍，培训；适应，熟悉</td>
<td>复数orientations</td>
</tr>
<tr>
<td>outcomes</td>
<td>n.产出，结局；效果（outcome 的复数）</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>n.产量，作品；产生，生产过程；输出功率；（计算机的）输出信息；输出端<br/>v.输出</td>
<td>复数outputs<br/>第三人称单数outputs<br/>现在分词outputting<br/>过去式outputted或output<br/>过去分词outputted或output</td>
</tr>
<tr>
<td>overall</td>
<td>adj.总的，全面的；所有的，包括一切的<br/>adv.全部，总共； 总的说来，大体上<br/>n.&lt;英&gt;（工作时穿的）罩衣；&lt;英&gt;（上下连身的）工作服，防护服（overalls）；&lt;美&gt;背带工装裤（overalls）；&lt;英&gt;骑马裤，紧身制服裤（overalls）</td>
<td>复数overalls</td>
</tr>
<tr>
<td>overlap</td>
<td>v.（与……）互搭，（与……）复叠；（在关注的问题、承担的责任等方面）部分地重叠，部分相同；（与……）同时发生<br/>n.（物体的）重叠部分，重叠量；（范围方面的）重叠部分；（两事发生的）重叠时间，交接时期</td>
<td>复数overlaps<br/>第三人称单数overlaps<br/>现在分词overlapping<br/>过去式overlapped<br/>过去分词overlapped</td>
</tr>
<tr>
<td>overseas</td>
<td>adj.外国的，海外的<br/>adv.在国外，在海外</td>
<td></td>
</tr>
<tr>
<td>panel</td>
<td>n.专家咨询组，专题讨论小组；（门等的）镶板，嵌板；控制板，仪表盘；（车身的）金属板；（衣服上的）镶条，饰片；画板；&lt;美&gt;陪审团；&lt;英&gt;国民保健制度（原国民健康保险）医师名单；&lt;苏格兰，法律&gt;被告<br/>v.用（木板、金属板等）覆盖，镶<br/>【名】 （Panel）帕内尔（人名）</td>
<td>复数panels<br/>第三人称单数panels<br/>现在分词panelling或paneling<br/>过去式panelled或paneled<br/>过去分词panelled或paneled</td>
</tr>
<tr>
<td>paradigm</td>
<td>n.典范，范例；样板，范式；词形变化表；纵聚合关系语言项</td>
<td>复数paradigms</td>
</tr>
<tr>
<td>paragraph</td>
<td>n.（文章的）段，段落；段落符号；短评<br/>v.把（文章）分段</td>
<td>复数paragraphs<br/>第三人称单数paragraphs<br/>现在分词paragraphing<br/>过去式paragraphed<br/>过去分词paragraphed</td>
</tr>
<tr>
<td>parallel</td>
<td>adj.平行的；相似的，同时发生的；（计算机）并行的；并联的<br/>n.（人或事物的）相似的手法，共同点；相似的人（或物）；（地球的）纬线，纬圈；（印刷）平行符号<br/>v.与……相似；与……同时发生；与……并行；与……相当，比得上<br/>adv.与……平行</td>
<td>复数parallels<br/>第三人称单数parallels<br/>现在分词paralleling或parallelling<br/>过去式paralleled或parallelled<br/>过去分词paralleled或parallelled</td>
</tr>
<tr>
<td>parameters</td>
<td>n.决定因素，规范；参数；人口参数；界限（parameter 的复数）</td>
<td></td>
</tr>
<tr>
<td>participation</td>
<td>n.参加，参与</td>
<td></td>
</tr>
<tr>
<td>partnership</td>
<td>n.合伙（关系），合股；合伙企业；合伙人；（两个人、组织或国家之间的）合作关系，伙伴关系；合伙契约；（板球）（回合结束前或其中一人被迫退场前）一对击球手的跑动得分数</td>
<td>复数partnerships</td>
</tr>
<tr>
<td>passive</td>
<td>adj.消极的，被动的；被动语态的；（抵抗）非暴力的；（电路，装置）无源的；（金属）经表面钝化处理的，钝化的<br/>n.（动词的）被动语态形式；被动语态（the passive）</td>
<td>复数passives<br/>比较级more passive<br/>最高级most passive</td>
</tr>
<tr>
<td>perceived</td>
<td>adj.感知到的；感观的<br/>v.感知；认为；领会（perceive 的过去式和过去分词）</td>
<td></td>
</tr>
<tr>
<td>percent</td>
<td>n.百分之……；部分<br/>adj.百分之……的<br/>adv.以百分之……地，每一百中有……地</td>
<td>复数percent或percents</td>
</tr>
<tr>
<td>period</td>
<td>n.一段时间，时期；（人生或国家历史的）阶段，时代；（地质年代划分的）纪；课时，节；（练习、训练或学习的）时段；（妇女的）月经，经期；（体育比赛的）局；&lt;美&gt;句号，句点；（物理）（振动或循环的）周期；（天文）自转（或公转）周期；（数学）（周期函数的）周期；（化学）周期元素；（修辞）完整句；（乐）乐段，乐节<br/>adj.具有某个时代特征的<br/>adv.&lt;美&gt;到此为止，不再说了</td>
<td>复数periods</td>
</tr>
<tr>
<td>persistent</td>
<td>adj.执意的，坚持不懈的；持续的，反复出现的；（化学品，放射性）作用持久的，挥发慢的；（动植物某部位，如角、叶等）宿存的，不落的</td>
<td>比较级more persistent<br/>最高级most persistent</td>
</tr>
<tr>
<td>perspective</td>
<td>n.（观察问题的）视角，观点；透视（画）法；（几何）透视关系，投影比例；洞察力，判断力；景观，远景；角度；（声音）立体效果<br/>adj.透视的</td>
<td>复数perspectives</td>
</tr>
<tr>
<td>phase</td>
<td>n.（发展或变化的）阶段，时期；做出某种行为的短时期；（动物生活周期或年周期的）阶段，期；（月亮的）位相，盈亏；同步，协调；（化）相；（动）（由遗传或季节引起的）动物颜色变化（期）；（物理）相位，相角；（线圈的）匝，（多相电机或电路的）连接；（语言学）（系统语法用语）相（指链接动词与后续动词的关系）；相结构（含有链接动词和后续动词的结构）<br/>v.分阶段进行；（物理）使相位同步，使定相</td>
<td>复数phases<br/>第三人称单数phases<br/>现在分词phasing<br/>过去式phased<br/>过去分词phased</td>
</tr>
<tr>
<td>phenomenon</td>
<td>n.现象；杰出的人，非凡的人（或事物）；（哲学）现象</td>
<td>复数phenomena或phenomenons</td>
</tr>
<tr>
<td>philosophy</td>
<td>n.哲学；哲学体系，思想体系；人生哲学，生活（工作）准则；（某一知识或经验领域的）理论基础研究，基本原理</td>
<td>复数philosophies</td>
</tr>
<tr>
<td>physical</td>
<td>adj.身体的，肉体的；物质的，有形的；外形的，外在的；物理的，物理学的；根据自然规律的，符合自然法则的；粗暴的，粗野的；性欲的，肉欲的；（人）喜欢动手动脚的；肢体活动的<br/>n.体格检查；（股票）（与期货相对的）现货股票</td>
<td>复数physicals<br/>比较级more physical<br/>最高级most physical</td>
</tr>
<tr>
<td>plus</td>
<td>prep.加；外加，而且；（温度）零上<br/>adj.（在数字后）多，余；略高于标准的；零上的，正的；有利的；正电的<br/>n.加号，正号；（数字的）加法；好处<br/>conj.而且；加上<br/>【名】 （Plus）（印、巴、法）普卢斯（人名）</td>
<td>复数pluses或plusses</td>
</tr>
<tr>
<td>policy</td>
<td>n.政策，方针；(处事) 原则，策略；保险单</td>
<td>复数policies</td>
</tr>
<tr>
<td>portion</td>
<td>n.（某物的）一部分；（尤指餐馆中食物的）一份，一客；（责任、过失、职责等的）一份，一部分；&lt;法律&gt;（根据法律赠与或遗留给继承人的）一份财产；&lt;古&gt; 命运，天数<br/>v.分配；&lt;古&gt; 给（新娘）嫁妆</td>
<td></td>
</tr>
<tr>
<td>posed</td>
<td>v.形成（pose 的过去分词）；摆姿势；主张；装模作样</td>
<td></td>
</tr>
<tr>
<td>positive</td>
<td>adj.乐观的，有信心的；积极的，建设性的；赞成的，支持的；确信的，肯定的；&lt;非正式&gt;完全的，绝对的；证据确凿的，明确的；阳性的；良好的，有助益的；正数的，大于零的；正电的，正极的；（摄影）正片的，正像的；赢利的；（语法）（形容词，副词）原级的；（主哲）实证的，实在的；（占星）（风宫，火宫）积极的<br/>n.优势，优点；正片；阳性结果；正数；（语法）原级形容词，原级副词</td>
<td>复数positives<br/>比较级more positive<br/>最高级most positive</td>
</tr>
<tr>
<td>potential</td>
<td>adj.潜在的，可能的<br/>n.（事物的）潜力，可能性；（人的）潜能，潜力；电势，电位，电压</td>
<td>复数potentials</td>
</tr>
<tr>
<td>practitioners</td>
<td>n.实践者；开业者；实习者（practitioner 的复数）</td>
<td></td>
</tr>
<tr>
<td>preceding</td>
<td>adj.先前的，前面的<br/>v.在……之前发生（或出现）；走在……前面（precede 的现在分词形式）</td>
<td></td>
</tr>
<tr>
<td>precise</td>
<td>adj.精确的，准确的；恰好的，确切的；（人）严格的，一丝不苟的</td>
<td>比较级more precise<br/>最高级most precise</td>
</tr>
<tr>
<td>predicted</td>
<td>v.预测，预言，预报（predict 的过去式和过去分词）</td>
<td></td>
</tr>
<tr>
<td>predominantly</td>
<td>adv.绝大多数，主要地</td>
<td></td>
</tr>
<tr>
<td>preliminary</td>
<td>adj.初步的，预备的<br/>n.初步行动，准备工作；预赛，预试</td>
<td>复数preliminaries</td>
</tr>
<tr>
<td>presumption</td>
<td>n.推测，设想；（法律上的）假定，推定；放肆，冒昧</td>
<td>复数presumptions</td>
</tr>
<tr>
<td>previous</td>
<td>adj.以前的，先前的；（时间或顺序上）稍前的；&lt;非正式&gt;过早的，过急的<br/>n.&lt;英，非正式&gt;前科，犯罪记录</td>
<td></td>
</tr>
<tr>
<td>primary</td>
<td>adj.主要的，首要的；&lt;英&gt;小学教育的，初级教育的；初级的，原发性的；最基本的，最根本的；第一手的，直接的；（有机化合物）连上一个碳原子的；（多指胺）（氨基酸顺序）一级的<br/>n.（选举过程中的党内）初选（=primary election）；原色；初级飞羽；主星；初级线圈，原线圈</td>
<td>复数primaries</td>
</tr>
<tr>
<td>prime</td>
<td>adj.主要的，首要的；优质的，第一流的；最可能的，最适合的；最理想的，最典型的；最初的，原始的；素（或质）数的（如2，3，5，7，11）；互为素或质数的<br/>v.事先指点，使（某人）做好准备；把（某事物）准备好，使备用；给（表面）涂上底色<br/>n.盛年，壮年时期；质数，素数；上标符号（’），（数字后）分钟（或英尺）符号；（八个防御姿势的）第一姿势；（自行车比赛中设特别奖的）特设行程；&lt;古&gt;起始，原初；晨经，晨祷（传统上于白天中的第一个小时即早晨六点所做的祈祷，现罕用）<br/>【名】 （Prime）（英）普赖姆，（德）普里梅（人名）</td>
<td>复数primes<br/>第三人称单数primes<br/>现在分词priming<br/>过去式primed<br/>过去分词primed</td>
</tr>
<tr>
<td>principal</td>
<td>adj.最重要的，首要的；本金的，母金的<br/>n.&lt;美&gt;（美国公立中小学的）校长；&lt;英&gt;（英国的）大学校长，学院院长；（企业或机构的）负责人；（音乐会、戏剧、芭蕾舞剧、歌剧中的）主角演员；（管弦乐队每一乐器组的）首席演奏者；（有利息的）本金，资金；（法律和商业事务中的）当事人，委托人；关键人物；（某些行业）完全合格的开业者；&lt;英&gt;（负责某一部门的）高级公务员；主犯，首犯；&lt;史&gt;决斗者；（支撑檩的）主椽；（管风琴的）主音栓</td>
<td>复数principals</td>
</tr>
<tr>
<td>principle</td>
<td>n.（行为）准则，（道德）原则；道义，正直；基本原则，基本法则；（机器等或自然界的）原理，定律；（宗教或政治的）主义，信条；起源，本原；本质，实质；（化）成分，要素</td>
<td>复数principles</td>
</tr>
<tr>
<td>prior</td>
<td>adj.先前的，事先的；&lt;正式&gt;优先的，更重要的；&lt;正式&gt;在前面的（prior to）<br/>n.&lt;美，非正式&gt;犯罪前科；小修道院院长；大修道院副院长；托钵会会长<br/>【名】 （Prior）（美）普廖尔（人名）</td>
<td>复数priors</td>
</tr>
<tr>
<td>priority</td>
<td>n.优先事项，最重要的事；优先，优先权，重点；&lt;英&gt;优先通行权<br/>adj.优先的</td>
<td>复数priorities</td>
</tr>
<tr>
<td>procedure</td>
<td>n.手续，步骤；（商业、法律或政治上的）程序；外科手术；（电脑的）应用程式</td>
<td>复数procedures</td>
</tr>
<tr>
<td>process</td>
<td>n.步骤，程序；（自然或偶然的）变化过程；（为达到某目标的）过程，进程；制作方法，加工方法；&lt;法律&gt;传票；（生，剖）端突，突起<br/>adj.（印刷）三原色的，三色版的； 经过特殊加工的；照相板的<br/>v.（用化学物品或机器）处理，加工；审核，受理（正式文件或请求）；（计算机）处理（数据）；冲洗（照片）；加工（食品）；&lt;正式&gt;列队行进；把（头发）弄成直发</td>
<td>复数processes<br/>第三人称单数processes<br/>现在分词processing<br/>过去式processed<br/>过去分词processed</td>
</tr>
<tr>
<td>professional</td>
<td>adj.职业的，专业的；非常内行的，极为称职的；（人）职业性的，非业余的；由职业人员参加的；&lt;非正式，贬&gt;（人）坚持某种活动特征（或特点）的<br/>n.专业人员，专业人士；内行，专家；职业选手；（受雇于高尔夫或网球协会的）职业教练</td>
<td>复数professionals<br/>比较级more professional<br/>最高级most professional</td>
</tr>
<tr>
<td>prohibited</td>
<td>v.禁止（prohibit的过去分词形式）<br/>adj.被禁止的</td>
<td></td>
</tr>
<tr>
<td>project</td>
<td>n.项目，计划；（学校的）课题，研究项目；&lt;美&gt;廉租房区，公共房屋区<br/>v.预计，推算；计划，规划；伸出，突出；投掷，喷射；投射，投影；展现，表现；使（声音，尤指嗓音）扩及远处；传播；想像（自己、场景等）在另一地点或时间；（尤指无意地把情感、愿望）投射转移（给别人）；使（某人）迅速成功，让（某人）获得更好的工作；作（曲线）的射影图；把（地球，天空等）投影在平面上</td>
<td>复数projects<br/>第三人称单数projects<br/>现在分词projecting<br/>过去式projected<br/>过去分词projected</td>
</tr>
<tr>
<td>promote</td>
<td>v.促进，提倡；升职，晋升；促销，推广； 将（运动队）晋级；使（学生）升年级；负责筹办，主办（大型活动，如音乐会或体育比赛）；促使（议会私法议案）通过；使（卒）升格为（尤指后等）；&lt;英&gt;（先打大牌）使（小牌）赢得一墩；使（催化剂）更活泼</td>
<td>第三人称单数promotes<br/>现在分词promoting<br/>过去式promoted<br/>过去分词promoted</td>
</tr>
<tr>
<td>proportion</td>
<td>n.部分，份额；比例；正确的比例，均衡；大小，程度（proportions）；（事情的）重要性，严重性；等比关系<br/>v.&lt;正式&gt; 使（某物）成比例，使相称；分摊</td>
<td>复数proportions<br/>第三人称单数proportions<br/>现在分词proportioning<br/>过去式proportioned<br/>过去分词proportioned</td>
</tr>
<tr>
<td>prospect</td>
<td>n.可能性，希望；预期，展望；（尤指事业的）成功机会，前景；有望成功的人，有前途的人；可能的顾客，潜在的主顾；&lt;正式&gt;（尤指从高处看到的）景象，景色；潜在矿藏或矿床<br/>v.勘探，勘察；寻找（商业机会）</td>
<td>复数prospects<br/>第三人称单数prospects<br/>现在分词prospecting<br/>过去式prospected<br/>过去分词prospected</td>
</tr>
<tr>
<td>protocol</td>
<td>n.礼仪，礼节；国际议定书，协议；条约草案，（协议或条约的）附件；（协定，公约）修正案（或增补）；（数据传递的）协议，规约；科学实验计划，医疗方案；（科学实验结果的）官方记录<br/>v.以协议形式发布；拟定</td>
<td>复数protocols<br/>第三人称单数protocols<br/>现在分词protocolling或protocoling<br/>过去式protocolled或protocoled<br/>过去分词protocolled或protocoled</td>
</tr>
<tr>
<td>psychology</td>
<td>n.心理学；心理特点，心理状态；心理影响；心计，善解人意</td>
<td>复数psychologies</td>
</tr>
<tr>
<td>publication</td>
<td>n.出版，发行；出版物，发行物；（信息的） 刊登，公布</td>
<td>复数publications</td>
</tr>
<tr>
<td>published</td>
<td>adj.已发布的<br/>v.出版；发行（publish 的过去式和过去分词）</td>
<td></td>
</tr>
<tr>
<td>purchase</td>
<td>n.&lt;正式&gt;购买，采购；&lt;正式&gt;购买的东西；&lt;法律&gt;（非继承性的）财产置得；&lt;正式&gt;紧握，牢牢抓住；（移动重物的）滑轮（或类似装置）<br/>v.&lt;正式&gt; 购买，采购；&lt;古&gt;（努力或艰难地）获得，得到；（航海）（用滑轮或杠杆）升起，举起（绳，索，锚）</td>
<td>复数purchases<br/>第三人称单数purchases<br/>现在分词purchasing<br/>过去式purchased<br/>过去分词purchased</td>
</tr>
<tr>
<td>pursue</td>
<td>v.追求，致力于，执行；继续探讨（或追究、从事）；追逐，跟踪，追赶；沿着……前行；追求（某人）；力劝（某人）接受聘用</td>
<td>第三人称单数pursues<br/>现在分词pursuing<br/>过去式pursued<br/>过去分词pursued</td>
</tr>
<tr>
<td>qualitative</td>
<td>adj.质量的，定性的，性质的</td>
<td></td>
</tr>
<tr>
<td>quotation</td>
<td>n.引语，引文；音乐（或艺术品）片段的引用；引用，引述；报价单，估价；（股票）报价，牌价；（股票）上市许可登记</td>
<td>复数quotations</td>
</tr>
<tr>
<td>radical</td>
<td>adj.根本的，彻底的；激进的，极端的；&lt;美，非正式&gt; 顶呱呱的；全新的，不同凡响的；（增减）急剧的，大幅度的；（人，物）原本的，与生俱来的；（外科，医疗）根治的；&lt;英，史&gt;（19世纪）自由党激进派的；（数）根式的，根号的；词根的；（植）根生的<br/>n.激进分子； 游离基，自由基；词根；（汉字）偏旁，部首；（数）根式；根号</td>
<td>复数radicals<br/>比较级more radical<br/>最高级most radical</td>
</tr>
<tr>
<td>random</td>
<td>adj.任意的，随机的，胡乱的；（砖石建筑）石头大小不一的；&lt;非正式&gt;奇怪的，不同寻常的<br/>n.随意，随机；&lt;非正式&gt;不认识的人，陌生人<br/>adv.随机地，胡乱地</td>
<td></td>
</tr>
<tr>
<td>range</td>
<td>n.（变动或浮动的）范围，界限；视觉（或听觉）范围；射程，射击距离；一系列；成套产品，系列商品；山脉；牧场，牧区；靶场，射击场，炸弹试验场；（尤指旧时的）炉灶；一排建筑物；&lt;古&gt;方向，走向；（飞机等交通工具的）续航距离<br/>v.（在一定的范围内）变化，变动；（按一定位置或顺序）排列，排序；徘徊，四处移动；（文章或讲话）涉及，包括 ；（枪、炮、射击后校准）测距，（用雷达或激光）测距；支持，反对；自然生长，分布；与……联合起来，加入……行列<br/>adj.&lt;文&gt;（生活方式）有秩序的，安定的</td>
<td>复数ranges<br/>第三人称单数ranges<br/>现在分词ranging<br/>过去式ranged<br/>过去分词ranged</td>
</tr>
<tr>
<td>ratio</td>
<td>n.比率，比例</td>
<td>复数ratios</td>
</tr>
<tr>
<td>rational</td>
<td>adj.（想法、决定等）合理的，基于理性的；（人）理性的，理智的；富有理性的；（数）有理的，有理数的<br/>n.有理数</td>
<td>复数rationals<br/>比较级more rational<br/>最高级most rational</td>
</tr>
<tr>
<td>reaction</td>
<td>n.反应，回应；反应能力（reactions）；（药物或食物引起的）不良反应；化学反应；反作用力；（对旧观念等的）抗拒；反动，守旧</td>
<td>复数reactions</td>
</tr>
<tr>
<td>recovery</td>
<td>n.康复，痊愈；戒除；恢复，复苏；（供刚做完手术的病人使用的）监护室；（被拿走或失去的东西的）复得，找回；收回的物品（资金）；（破损车辆或坠毁飞机）回收修理；（高尔夫）挽回败局之击，复原之击（击回球道或球穴区）；（美橄）重新获球；（划船，自行车赛，游泳）还原至预备姿势（如回桨等）；回收利用（能源、化工品等）</td>
<td>复数recoveries</td>
</tr>
<tr>
<td>refine</td>
<td>v.精炼，提纯；改进，改善；使……文雅</td>
<td>第三人称单数refines<br/>现在分词refining<br/>过去式refined<br/>过去分词refined</td>
</tr>
<tr>
<td>regime</td>
<td>n.（尤指独裁的）政府，政权；（机构、公司、经济等的）管理制度，组织方法；饮食起居制度，养生法</td>
<td>复数regimes</td>
</tr>
<tr>
<td>region</td>
<td>n.地区，区域；行政区；&lt;英&gt;（首都以外的）地方（the regions）；身体部位；领域，界</td>
<td>复数regions</td>
</tr>
<tr>
<td>registered</td>
<td>adj.已登记的，已注册的；（信或包裹）挂号的；（家畜等）附有血统证明的<br/>v.登记，注册；（仪器上）显出，显示；表示，表达（意见或情感）（register 的过去式和过去分词形式）</td>
<td></td>
</tr>
<tr>
<td>regulations</td>
<td>n.规则，规章，条例，法规（regulation 的复数）</td>
<td></td>
</tr>
<tr>
<td>reinforced</td>
<td>v.加强；巩固；（使）更结实；增援，（使）更强大；增进，加深（reinforce 的过去式及过去分词）<br/>adj.加固的；增强的</td>
<td></td>
</tr>
<tr>
<td>rejected</td>
<td>v.拒绝，驳回；不同意；不录用；不用，不出版；嫌弃，厌弃；排斥（移植器官）；不够关心，慢待（reject 的过去式和过去分词）<br/>adj.被拒绝的</td>
<td></td>
</tr>
<tr>
<td>relaxed</td>
<td>adj.放松的，轻松的；舒适的，自在的；不加以拘束的，随便的；（肌肉或其他身体部位）放松的；（头发）拉直的；（衣服）宽松的，肥大的<br/>v.休息，（使）放松；放心，镇定；松开，（使）松弛（relax 的过去式和过去分词）</td>
<td></td>
</tr>
<tr>
<td>release</td>
<td>v.释放，放走；使出院；把（动物）放生；解救；放开；拉开，松开（装置）；发射，投（弹）；公布，发布；发行，上映；表达，发泄；释放，排放（物质）； 解除（职务或工作），解雇；放弃，让予；使不紧张；开放，解禁<br/>n.（人或动物的）释放，放出；排放，泄漏；（设备的）松开，拉开；释放装置（如按、拉的装置）；表达，宣泄；解脱，轻松感；放松的机会；新发行的东西；公开，发布；公映；（责任等的）免除，解除；免责书；&lt;法律&gt; 放弃，让予；放弃文书；&lt;美&gt; 传球</td>
<td>复数releases<br/>第三人称单数releases<br/>现在分词releasing<br/>过去式released<br/>过去分词released</td>
</tr>
<tr>
<td>relevant</td>
<td>adj.有关的，切题的；正确的，适宜的；有价值的，有意义的</td>
<td>比较级more relevant<br/>最高级most relevant</td>
</tr>
<tr>
<td>reliance</td>
<td>n.依靠，信任；&lt;古&gt;被依赖的人（或物）</td>
<td></td>
</tr>
<tr>
<td>reluctant</td>
<td>adj.勉强的，不情愿的</td>
<td>比较级more reluctant<br/>最高级most reluctant</td>
</tr>
<tr>
<td>removed</td>
<td>adj.（亲属关系）隔代的，隔辈的；不同的；（时间或空间上）遥远的；（对某一课题、问题、情况等）知之甚少的<br/>v.移开，拿开；除去，废除；把……免职，开除（remove 的过去式和过去分词）</td>
<td></td>
</tr>
<tr>
<td>required</td>
<td>adj.必需的，规定的；理想的<br/>v.需要；要求做（某事），规定（require 的过去式和过去分词形式）；要求做（某事），规定（require 的过去式和过去分词）</td>
<td></td>
</tr>
<tr>
<td>research</td>
<td>n.（尤指大学或科研机构进行的）研究，探讨；研究工作，调查工作<br/>v.研究，探索；为……收集资料，调查</td>
<td>复数researches<br/>第三人称单数researches<br/>现在分词researching<br/>过去式researched<br/>过去分词researched</td>
</tr>
<tr>
<td>resident</td>
<td>n.居民，住户；（旅馆的）住宿者；&lt;美&gt;住院医生；&lt;美&gt; 寄宿制学校学生；&lt;史&gt;（英国政府派驻半独立国家的） 特派代表；驻外特工；留鸟，无迁徙习性的蝴蝶（或其他动物）<br/>adj.（在某地）居住的，居留的；常驻的；属于（某个群体）的；（鸟、蝴蝶等）非迁徙性的；（计算机程序、文件等在存储器中）驻留的</td>
<td>复数residents</td>
</tr>
<tr>
<td>resolution</td>
<td>n.决议，正式决定；（冲突、问题等的）解决，解决办法；决心，决定；坚决，果断；（电视、照相机、显微镜等的）清晰度，分辨率；（故事中主要矛盾的）冲突解开；（乐）解决（指和声中不协和音向协和音的进行）；（医）（炎症或其他症状的）消散，消退；（化）分解；（物理）（力或其他矢量的）分解</td>
<td>复数resolutions</td>
</tr>
<tr>
<td>resources</td>
<td>n.[计][环境] 资源；物力（resource 的复数）<br/>v.向……提供资金（resource 的第三人称单数）</td>
<td></td>
</tr>
<tr>
<td>responserole</td>
<td>(not find meaning.)</td>
<td></td>
</tr>
<tr>
<td>restore</td>
<td>v.恢复（某种情况或感受）；使复原，使复位；修复，整修；重新采用，恢复使用；归还</td>
<td>第三人称单数restores<br/>现在分词restoring<br/>过去式restored<br/>过去分词restored</td>
</tr>
<tr>
<td>restraints</td>
<td>n.限制，禁止（restraint 的复数）</td>
<td></td>
</tr>
<tr>
<td>restricted</td>
<td>adj.（大小或数量）有限的，很小的；（指能做的事）有限的，受限制的；受（法规）制约的，受控制的；不对公众开放的；（文件）保密的，限于内部传阅的；（病毒繁殖速率）被限制的；（DNA）因限制酶酶切的<br/>v.限制，限定（数量、范围等）；约束，限制（行动或活动）；（以法规）限制（restrict 的过去式和过去分词）</td>
<td></td>
</tr>
<tr>
<td>retained</td>
<td>adj.保留的<br/>v.保留；保存（retain 的过去式形式）</td>
<td></td>
</tr>
<tr>
<td>revealed</td>
<td>v.揭露，透露；显示（reveal 的过去式和过去分词）</td>
<td></td>
</tr>
<tr>
<td>revenue</td>
<td>n.（企业、组织的）收入，收益；（政府的）税收；税务局，税务署（the revenue）</td>
<td>复数revenues</td>
</tr>
<tr>
<td>reverse</td>
<td>v.逆转，彻底改变（决定、政策、趋势等）；撤销，推翻（法庭判决）；颠倒，反转；交换，互换（位置、功能）；&lt;美&gt;承认错误，放弃（立场）；倒（车）；（发动机）反向运转；&lt;英&gt;打对方付费的电话；使（铅字，图案）印成白或浅色<br/>n.相对，相反（the reverse）；逆向，逆转；倒车挡；&lt;正式&gt;失败，挫折；反面，背面；（翻开的书）左手页，（活页文件的）背面；（硬币或奖牌）反面图案（或刻字）；（美式橄榄球）反向传球，变位传球<br/>adj.相反的，反向的；背面的，反面的；（半导体结的外加电压）反向的；（地层）逆断的，冲断的；反身的</td>
<td>复数reverses<br/>第三人称单数reverses<br/>现在分词reversing<br/>过去式reversed<br/>过去分词reversed</td>
</tr>
<tr>
<td>revision</td>
<td>n.修改，修订；修订本，订正版；复习，温习</td>
<td>复数revisions</td>
</tr>
<tr>
<td>revolution</td>
<td>n.（思想、工作方式等的）彻底变革；（使用武力、暴力的）革命；旋转；旋转一周；（马克思主义）共产主义革命（The Revolution）；循环</td>
<td>复数revolutions</td>
</tr>
<tr>
<td>rigid</td>
<td>adj.（方法、体制等）严格死板的，僵化的；（人）顽固的，不通融的；刚硬的，不易弯曲的；（因强烈的感情而）僵硬的，僵直的；精确的<br/>n.未铰接的货车</td>
<td>复数rigids<br/>比较级more rigid<br/>最高级most rigid</td>
</tr>
<tr>
<td>route</td>
<td>n.路线，航线；道路，路途；常规路线，固定路线；&lt;美&gt;（尤指作为送货工作的）例行拜访，递送路线；途径，方法；（用于美国城市间干线公路编号前）公路（Route）<br/>v.按特定路线发送（车辆、货物或乘客）；以……线路发送（电话或其他电子信号）</td>
<td>复数routes<br/>第三人称单数routes<br/>现在分词routing或routeing<br/>过去式routed<br/>过去分词routed</td>
</tr>
<tr>
<td>scenario</td>
<td>n.设想，可能发生的情况 ；（电影、戏剧等的）剧情梗概；（艺术或文学作品中的）场景</td>
<td>复数scenarios</td>
</tr>
<tr>
<td>schedule</td>
<td>n.计划（表），进度表；&lt;美&gt;（公共汽车、火车等的）时间表；（价目、费用等的）清单，一览表；（电视或电台的）节目表；&lt;美&gt;（学校的）课程表；&lt;法律&gt; 附件（尤指表格、单据等）；（英国所得税制的）报税单<br/>v.安排，预定；列入，收进（正式目录、清单等中）；&lt;英&gt; 把（建筑物）列为文物保护单位</td>
<td>复数schedules<br/>第三人称单数schedules<br/>现在分词scheduling<br/>过去式scheduled<br/>过去分词scheduled</td>
</tr>
<tr>
<td>scheme</td>
<td>n.&lt;英&gt;（政府或其他组织的）计划，方案；（用于组织或整理信息的）系统，体系；组合，布局；阴谋，诡计；&lt;苏格兰，非正式&gt;社会住宅区<br/>v.密谋，策划；&lt;南非，非正式&gt;认为，猜想；按色调布置<br/>【名】 （Scheme）（瑞典）谢默（人名）</td>
<td>复数schemes<br/>第三人称单数schemes<br/>现在分词scheming<br/>过去式schemed<br/>过去分词schemed</td>
</tr>
<tr>
<td>scope</td>
<td>n.范围，领域；（发挥能力的）机会，施展余地；视野，眼界；观测仪器（如望远镜、显微镜等）；（船抛锚时的）缆绳长度；特定论点的数量<br/>v.评估，调查（scope sth. out）；确定（规划项目）的范围；&lt;非正式&gt;仔细看，彻底检查</td>
<td>复数scopes<br/>第三人称单数scopes<br/>现在分词scoping<br/>过去式scoped<br/>过去分词scoped</td>
</tr>
<tr>
<td>section</td>
<td>n.段，部分；散件，部件；（书、报等的）节，栏；一部分人；（乐队的）组；断面图，剖面图；（数学中的）截面；（手术中的）开刀，切开；（供研究用的动物或植物的）切片；&lt;美&gt; 一平方英里的土地；&lt;美&gt;（柑橘类水果的）一瓣；（法律文件的）款，项；路段；区域；部门，科；&lt;新西兰&gt; 建房用地；（军队的）特定单位；分排，小队；（生物）组（尤指亚属）<br/>v.&lt;英&gt; 把……关进精神病院；（手术中）把……切开；将……制成切片；切开，切断；被切割成片，被分成部分</td>
<td>复数sections<br/>第三人称单数sections<br/>现在分词sectioning<br/>过去式sectioned<br/>过去分词sectioned</td>
</tr>
<tr>
<td>sector</td>
<td>n.区域，部分；（尤指商业、贸易等的）部门，行业；小群体；（尤指军队控制的）分区，防区；（磁盘上的）扇区； 扇形，扇形面；函数尺，象限仪<br/>v.把……分成扇形</td>
<td>复数sectors<br/>第三人称单数sectors<br/>现在分词sectoring<br/>过去式sectored<br/>过去分词sectored</td>
</tr>
<tr>
<td>security</td>
<td>n.保护措施，安全工作；保安部门；安检处；保障，保证；安全，安全感；抵押品，保证金；证券，债券</td>
<td>复数securities</td>
</tr>
<tr>
<td>select</td>
<td>v.选择，挑选；（在计算机屏幕上）选定；（进化）决定（特征，生物）是否继续存在<br/>adj.精选的，优等的；高级的，奢华的<br/>【名】 （Select）（美、印）塞阿克特（人名）</td>
<td>第三人称单数selects<br/>现在分词selecting<br/>过去式selected<br/>过去分词selected<br/>比较级more select<br/>最高级most select</td>
</tr>
<tr>
<td>sequence</td>
<td>n.顺序，次序；连续事件（或动作、事物）；（电影中表现同一主题或场面的）一组镜头；（生物学中分子或基因的排列）顺序；模进；（纸牌的）同花顺；序列；（天主教弥撒中圣歌与福音之间的）继续经<br/>v.按顺序排列；测定（整套基因或分子成分的）序列；用音序器播放（或录制）音乐</td>
<td>复数sequences<br/>第三人称单数sequences<br/>现在分词sequencing<br/>过去式sequenced<br/>过去分词sequenced</td>
</tr>
<tr>
<td>series</td>
<td>n.连续，一系列（事件）；（电视、广播等的）系列片，系列节目；丛书，系列出版物；（两队之间的）系列比赛；（电路的）串联；（同时发行的）一套邮票（或货币、硬币）；（由某一公司推出的）系列产品，（尤指）汽车系列；（年代地层学用语）统；（元素的）系；级数，序列项的总和；有共同特征的一组语音，系列（音）；音列</td>
<td>复数series</td>
</tr>
<tr>
<td>sex</td>
<td>n.性行为，性交；性，性别；雄性，雌性；性器官（用于小说中避免更粗俗或更露骨的措词）<br/>v.辨别……的性别，辨识……的雌雄；&lt;非正式&gt; 引起……的性欲</td>
<td>复数sexes<br/>第三人称单数sexes<br/>现在分词sexing<br/>过去式sexed<br/>过去分词sexed</td>
</tr>
<tr>
<td>shift</td>
<td>v.（使）移动，（使）转移；（使）转换到（另一个人或另一事物）；（使）改变意见（或信仰等）；&lt;英，非正式&gt;赶快；&lt;美&gt;换（挡）；（计算机）移位；按（计算机键盘上的）Shift 键；&lt;英，非正式&gt;摆脱，消除；&lt;英，非正式&gt;（尤指大量）销售，出售；&lt;英，非正式&gt;狼吞虎咽地吃；&lt;古&gt;含糊其辞，拐弯抹角<br/>n.改变，转变；轮班工作时间；轮班工作的人；（计算机键盘上的）Shift 键；（计算机）移位；&lt;美&gt;（机动车的）换挡装置；宽松直筒连衣裙（=shift dress）；&lt;史&gt;长而宽松的内衣；（建筑）错位；（美橄）（开赛前）球员位置的变换；（天文）（光谱线的）偏移；语音演变（sound shift 的简称）；&lt;古&gt;计谋，诡计</td>
<td>复数shifts<br/>第三人称单数shifts<br/>现在分词shifting<br/>过去式shifted<br/>过去分词shifted</td>
</tr>
<tr>
<td>significant source</td>
<td>重要的来源</td>
<td></td>
</tr>
<tr>
<td>simulation</td>
<td>n.模拟，仿造物；假装，冒充</td>
<td></td>
</tr>
<tr>
<td>site</td>
<td>n.（建筑的）工地，用地；（某事发生的）地点，现场；（作某种用途的）场所，场地；网站，站点（=website）；（身体的某个）部位；（城镇、建筑物或纪念碑的）地基，选址；遗址，原址；（帐篷或大篷车内）歇脚的地方<br/>v.使坐落在，为……选址</td>
<td>复数sites<br/>第三人称单数sites<br/>现在分词siting<br/>过去式sited<br/>过去分词sited</td>
</tr>
<tr>
<td>so-called</td>
<td>adj.（表示不认同）所谓的；叫做……的，号称……的</td>
<td></td>
</tr>
<tr>
<td>solely</td>
<td>adv.单独地，仅有地</td>
<td></td>
</tr>
<tr>
<td>somewhat</td>
<td>adv.稍微，有点<br/>pron.几分；某物</td>
<td></td>
</tr>
<tr>
<td>sought</td>
<td>v.寻找（seek 的过去式和过去分词）</td>
<td></td>
</tr>
<tr>
<td>specific</td>
<td>adj.明确的，具体的；特定的；特有的，独特的；有特殊功能的，有特效的；（生物）种的；（关税，税）按数量（根据固定税率）征取而非按货价征取的；（物理）（与参照物同一性质成）比率的<br/>n.细节，详情；特效药</td>
<td>复数specifics<br/>比较级more specific<br/>最高级most specific</td>
</tr>
<tr>
<td>specified</td>
<td>adj.规定的；详细说明的<br/>v.指定；详细说明（specify 的过去分词）</td>
<td></td>
</tr>
<tr>
<td>sphere</td>
<td>n.（活动、兴趣、专业知识的）范围，领域；球体，球，球形；社会阶层；势力范围；&lt;文&gt;苍穹，天，天空；&lt;文&gt;天体；天体外壳；地球仪<br/>vt.使……成球形；包围；放入球内</td>
<td>复数spheres<br/>第三人称单数spheres<br/>现在分词sphering<br/>过去式sphered<br/>过去分词sphered</td>
</tr>
<tr>
<td>stability</td>
<td>n.稳定（性），稳固（性）；坚定，恒心</td>
<td>复数stabilities</td>
</tr>
<tr>
<td>statistics</td>
<td>n.统计学；统计数字（statistic 的复数形式）</td>
<td></td>
</tr>
<tr>
<td>status</td>
<td>n.法律地位（或身份）；（尤指在社会中的）地位，身份；高级职位，社会上层地位；重视（或崇尚）程度；状况，情形</td>
<td>复数statuses</td>
</tr>
<tr>
<td>straightforward</td>
<td>adj.简单的，易懂的；（人）诚实的，坦率的<br/>adv.直截了当地，坦率地</td>
<td></td>
</tr>
<tr>
<td>strategies</td>
<td>n.策略，战略（strategy 的复数）</td>
<td></td>
</tr>
<tr>
<td>stress</td>
<td>n.精神压力，紧张；压力，应力；强调，重要性；（单词）重音，重读，（音乐）加强音；压强；环境恶劣引起的疾病<br/>v.强调，着重；重读；焦虑，紧张；使受压力，使受重压<br/>【名】 （Stress）（意）斯特雷斯 （人名）</td>
<td>复数stresses<br/>第三人称单数stresses<br/>现在分词stressing<br/>过去式stressed<br/>过去分词stressed</td>
</tr>
<tr>
<td>structure</td>
<td>n.结构，构造；结构体，（尤指）大型建筑物；周密安排，精心组织；机构，组织，体系<br/>v.计划，组织，安排</td>
<td>复数structures<br/>第三人称单数structures<br/>现在分词structuring<br/>过去式structured<br/>过去分词structured</td>
</tr>
<tr>
<td>styles</td>
<td>n.风格；样式；模式（style 的复数形式）<br/>n.（Styles）人名；（英）斯泰尔斯</td>
<td></td>
</tr>
<tr>
<td>submitted</td>
<td>v.递交；主张；屈服（submit 的过去分词）</td>
<td></td>
</tr>
<tr>
<td>subordinate</td>
<td>n.部属，下级；从属，次要<br/>v.使从属于，使处于次要地位；使隶属，使服从<br/>adj.从属的，下级的；次要的</td>
<td>复数subordinates<br/>第三人称单数subordinates<br/>现在分词subordinating<br/>过去式subordinated<br/>过去分词subordinated</td>
</tr>
<tr>
<td>subsequent</td>
<td>adj.随后的，接着的；（河，谷）后成的</td>
<td></td>
</tr>
<tr>
<td>subsidiary</td>
<td>n.子公司，附属公司；辅助者<br/>adj.次要的，附属的；子公司的</td>
<td>复数subsidiaries</td>
</tr>
<tr>
<td>substitution</td>
<td>n.代替，替换；代替物；（数） 置换</td>
<td>复数substitutions</td>
</tr>
<tr>
<td>successive</td>
<td>adj.连续的，依次的；接替的，继承的</td>
<td></td>
</tr>
<tr>
<td>sufficient</td>
<td>adj.足够的，充足的；（理由、条件）充足的，充分的</td>
<td></td>
</tr>
<tr>
<td>sum</td>
<td>n.金额，款项；算术，简单计算；总数，总和；全部，一切（尤指数量不大）；&lt;英&gt;计算失误；&lt;英&gt;计算费用<br/>v.概括，总结；求……的和，计算……的总数<br/>【名】 （Sum）（英）萨姆，（柬）孙，（俄、德、捷）苏姆，（越）森（人名）</td>
<td>复数sums或sumy<br/>第三人称单数sums<br/>现在分词summing<br/>过去式summed<br/>过去分词summed</td>
</tr>
<tr>
<td>summary</td>
<td>n.总结，概要<br/>adj.总结性的，概括的；（司法程序）即决的，简易的</td>
<td>复数summaries</td>
</tr>
<tr>
<td>supplementary</td>
<td>adj.补充的，附加的；（角）互补的<br/>n.补充者，增补物；&lt;英&gt;补充提问</td>
<td>复数supplementaries</td>
</tr>
<tr>
<td>survey</td>
<td>n.民意调查，民意测验；考察，调查；（对课题或情况的）全面考察，概述；测量，勘测；测绘图，勘测记录；测量部门；&lt;英&gt; （尤指为欲购房者所做的）房屋鉴定；查勘报告<br/>v.做民意测验，做民意调查；（尤指认真地）审视，检查；测量，勘测；&lt;英&gt; （尤指为可能的买家）查勘，检视（建筑物的状况）；全面评述，概述</td>
<td>复数surveys<br/>第三人称单数surveys<br/>现在分词surveying<br/>过去式surveyed<br/>过去分词surveyed</td>
</tr>
<tr>
<td>survive</td>
<td>v.（经历事故、战争或疾病后）活下来，幸存；比……活得久，比……长寿；挺过，艰难度过；幸免于难，留存；（靠很少的钱）继续维持生活；设法对付（困难或令人不愉快的事）</td>
<td>第三人称单数survives<br/>现在分词surviving<br/>过去式survived<br/>过去分词survived</td>
</tr>
<tr>
<td>suspended</td>
<td>v.悬挂；停止，暂停，中止；（因犯错而）暂令停职；暂令停学；暂令停止参加活动；悬浮，漂浮（suspend 的过去式和过去分词）</td>
<td></td>
</tr>
<tr>
<td>sustainable</td>
<td>adj.（计划、方法、体制）可持续的，持续性的；（自然资源）可持续的，不破坏环境的 ；站得住脚的</td>
<td></td>
</tr>
<tr>
<td>symbolic</td>
<td>adj.用作象征的，被认为是象征的；有象征意义的；（行为举动）象征性的，没有甚么实际影响的；符号的，使用象征的</td>
<td></td>
</tr>
<tr>
<td>tapes</td>
<td>n.录音带，胶纸带；条带，边带</td>
<td></td>
</tr>
<tr>
<td>target</td>
<td>n.目标，指标；（攻击的）目标；（批评、嘲笑等的）对象；靶子；目标受众，受影响的人（或群体）；&lt;史&gt; 圆形小盾；（语音）目标<br/>v.把……作为攻击目标，把……作为批评的对象；面向，把……对准（某群体）；将（钱款或援助）用于</td>
<td></td>
</tr>
<tr>
<td>task</td>
<td>n.（尤指困难的或必须定期做的）工作，任务；（尤指语言教学中旨在帮助达到某一学习目的的）活动<br/>v.派给……任务；对（手段，能力）要求极高，考验</td>
<td>复数tasks<br/>第三人称单数tasks<br/>现在分词tasking<br/>过去式tasked<br/>过去分词tasked</td>
</tr>
<tr>
<td>team</td>
<td>n.（游戏或体育运动的）队，小组；工作队，工作组；（套在一起拉车的）一组牲口（尤指马）<br/>v.协作，合作；使（颜色、布料、衣服）相配；（套在一起拉车的）一组牲口（尤指马）</td>
<td>复数teams<br/>第三人称单数teams<br/>现在分词teaming<br/>过去式teamed<br/>过去分词teamed</td>
</tr>
<tr>
<td>technical</td>
<td>adj.工艺的，技术的；专业的，专门的；严格按照法律意义的，严格按字面解释的；（尤指体育或艺术等活动）技巧（上）的；与机器（或系统）运行相关的，技术性的<br/>n.&lt;美&gt;（车后架设有机枪的）小卡车</td>
<td>复数technicals<br/>比较级more technical<br/>最高级most technical</td>
</tr>
<tr>
<td>techniques</td>
<td>n.技术；方法；技巧（technique 的复数）</td>
<td></td>
</tr>
<tr>
<td>technology</td>
<td>n.科技，技术；技术设备，先进机器；技术学，工艺学；术语</td>
<td>复数technologies</td>
</tr>
<tr>
<td>temporary</td>
<td>adj.暂时的，临时的；短期的，短暂的<br/>n.临时雇员，临时工</td>
<td>复数temporaries</td>
</tr>
<tr>
<td>tension</td>
<td>n.紧张，焦虑；紧张关系，紧张局势；矛盾，冲突；（电线、绳子、肌肉等的）拉紧，绷紧；拉力，张力；（电影、书籍中的）紧张情绪，恐怖气氛；（编织的）针织密度；电压<br/>v.使拉紧，使紧张</td>
<td>复数tensions<br/>第三人称单数tensions<br/>现在分词tensioning<br/>过去式tensioned<br/>过去分词tensioned</td>
</tr>
<tr>
<td>termination</td>
<td>n.终止妊娠，人工流产；结束，终止；&lt;美&gt;解聘，解雇；&lt;美&gt;暗杀；词尾（尤指屈折变化或派生词的词尾）；&lt;古&gt;结局</td>
<td>复数terminations</td>
</tr>
<tr>
<td>text</td>
<td>n.（书、杂志等中区别于图片的）正文，文字材料；（演说等的）原文；（学习某课程必读的）课本，教科书；（供讨论或回答问题的）文本，文章；（讨论等的）题目，主题；（尤指科学或学术方面的）文献；（计算机、手机等）文档；短信；（尤指引作布道主题的）圣经经文；（尤指用于手稿的）粗体正楷<br/>v.（用手机）给……发短信</td>
<td>复数texts<br/>第三人称单数texts<br/>现在分词texting<br/>过去式texted<br/>过去分词texted</td>
</tr>
<tr>
<td>theme</td>
<td>n.（谈话、书籍、电影等的）题目，主题；（音乐的）主旋律；（电影、电视节目、广播节目的）主题音乐，主题曲；（学生的）作文；（聚会、房间等的）风格；（句子的）主位；（名词、动词等的）词干；&lt;史&gt;（拜占庭帝国的）行政区<br/>adj.以奇想主题布置的<br/>v.（休闲场所、活动）以……主题</td>
<td>复数themes</td>
</tr>
<tr>
<td>theory</td>
<td>n.学说，理论；（某一学科基于的）理论，原理；观点，见解</td>
<td>复数theories</td>
</tr>
<tr>
<td>thereby</td>
<td>adv.因此，从而</td>
<td></td>
</tr>
<tr>
<td>thesis</td>
<td>n.论文，毕业（或学位）论文；论题，论点；（文章的）主题；（黑格尔哲学用语）正题；（诗韵）扬音节</td>
<td>复数theses</td>
</tr>
<tr>
<td>topic</td>
<td>n.题目，主题；一般规则，总论</td>
<td>复数topics</td>
</tr>
<tr>
<td>trace</td>
<td>v.查出，发现，追踪；追溯，追究；描绘（事物的过程或发展），记述；（尤指用手指、脚趾）画（图，线）；勾画……的轮廓，勾勒；（用透明纸覆盖在地图、绘画等上）复制，描摹；（手指、嘴唇等）沿着……移动<br/>n.痕迹，遗迹，踪迹；微量，少许；描记图，扫描线；挽绳，缰绳；跟踪，追查；（大脑上的学习或记忆）痕迹，印迹；&lt;西印度，美&gt;小径，小道；交线，迹线；（数）迹<br/>【名】 （Trace）（美）塔斯（人名）</td>
<td>复数traces<br/>第三人称单数traces<br/>现在分词tracing<br/>过去式traced<br/>过去分词traced</td>
</tr>
<tr>
<td>traditional</td>
<td>adj.传统的；根据传统而制造（或使用）的；因袭的，守旧的；（活动）惯例的，经常从事的；典型的；（爵士乐）具20世纪早期风格的</td>
<td>比较级more traditional<br/>最高级most traditional</td>
</tr>
<tr>
<td>transfer</td>
<td>v.（使）转移，搬迁；转移（感情），传染（疾病），转让（权力等）；（使）调动，转职；转会，使转会（尤指职业足球队）；（将所得学分）转到（另一所学校）；转接（电话）；将（钱）转到（另一个账户上）；转让（财产，权利），移交（责任）；转用；转存，转录（资料、音乐等），改编；（旅途中）转乘，换乘；转印（图画，图案）；（通过延伸、隐喻）转变（词义，短语义）<br/>n.转移，转让，调动；（运动员）转会；转换，过渡；已调动的人，已转移的东西；（旅行中）转乘，转搭；&lt;美&gt;转车票，换乘票；纸上可转印的图画或图案；迁移（将已习得的行为在新的情况下应用）</td>
<td>复数transfers<br/>第三人称单数transfers<br/>现在分词transferring<br/>过去式transferred<br/>过去分词transferred</td>
</tr>
<tr>
<td>transformation</td>
<td>n.（彻底或重大的）改观，变化，转变；（用于南非）民主改革；舞台场景的突变；（动物生命周期中的）变态；（物理）嬗变，核的转换；（数，逻）变换；（语言学）转换；（生）遗传转化；（生）细胞转化</td>
<td>复数transformations</td>
</tr>
<tr>
<td>transition</td>
<td>n.过渡，转变；（分子生物）转换；（乐）临时转调；（物理）跃迁，转变<br/>v.转变，过渡</td>
<td>复数transitions<br/>第三人称单数transitions<br/>现在分词transitioning<br/>过去式transitioned<br/>过去分词transitioned</td>
</tr>
<tr>
<td>transmission</td>
<td>n.（无线电、电视等信号的）播送，发送；（电台或电视等的）信息，广播；传递，传播，传染；（车辆的）传动装置，变速器</td>
<td>复数transmissions</td>
</tr>
<tr>
<td>transport</td>
<td>n.运输，运送；交通工具，运输方式；交通运输系统；（运送部队、给养等的）运输船，运输机；强烈的感情，狂喜；&lt;史&gt;流放犯<br/>v.（用交通工具）运输，运送；（以自然方式）运输，传播；使产生身临其境的感觉；流放，放逐（犯人）；使狂喜，使（某人）充满强烈情感（尤指快乐）</td>
<td>复数transports<br/>第三人称单数transports<br/>现在分词transporting<br/>过去式transported<br/>过去分词transported</td>
</tr>
<tr>
<td>trend</td>
<td>n.趋势，动态；时尚，风尚；热门话题<br/>v.&lt;美&gt;趋向，倾向；（尤指地理特征的）走向；成为热门话题</td>
<td>复数trends<br/>第三人称单数trends<br/>现在分词trending<br/>过去式trended<br/>过去分词trended</td>
</tr>
<tr>
<td>trigger</td>
<td>n.（枪械等的）扳机；（尤指引发不良反应或发展的）起因，诱因；（炸弹的）引爆器，触发器<br/>v.引发，激发；起动，触发；引爆（炸弹）<br/>【名】 （Trigger）特里杰（人名）</td>
<td>复数triggers<br/>第三人称单数triggers<br/>现在分词triggering<br/>过去式triggered<br/>过去分词triggered</td>
</tr>
<tr>
<td>ultimately</td>
<td>adv.最终，最后；根本上，最重要地</td>
<td></td>
</tr>
<tr>
<td>undergo</td>
<td>v.经历，经受</td>
<td>第三人称单数undergoes<br/>现在分词undergoing<br/>过去式underwent<br/>过去分词undergone</td>
</tr>
<tr>
<td>underlying</td>
<td>adj.根本的，潜在的；表面下的，下层的；优先的；（数量或水平）实际的<br/>v.位于…的下面；构成…的基础（underlie 的现在分词形式）</td>
<td></td>
</tr>
<tr>
<td>undertaken</td>
<td>v.从事；开始进行（undertake 的过去分词）</td>
<td></td>
</tr>
<tr>
<td>unified</td>
<td>adj.一致的，统一的；联合的，一体的<br/>v.（使）联合，（使）统一；使协调（unify 的过去式和过去分词）</td>
<td></td>
</tr>
<tr>
<td>uniform</td>
<td>n.制服，校服；&lt;非正式&gt;穿制服的警官；（某一群体的人穿的）典型服装，特有服装；（无线电通讯）字母 U 的代码<br/>adj.全部相同的，始终如一的；制服式的<br/>v.使一致；使穿制服</td>
<td>复数uniforms<br/>第三人称单数uniforms<br/>现在分词uniforming<br/>过去式uniformed<br/>过去分词uniformed<br/>比较级more uniform<br/>最高级most uniform</td>
</tr>
<tr>
<td>unique</td>
<td>adj.独一无二的，独特的；非常特别的，极不寻常的；（某人、地或事物）独具的，特有的<br/>n.&lt;古&gt;独一无二的人（或事）<br/>【名】 （Unique）尤妮克（人名）</td>
<td></td>
</tr>
<tr>
<td>utility</td>
<td>n.（煤气、水、电等的）公共服务，公用事业；（供电、供水等的）公用事业单位；应用程序，实用程序；实用，有用；&lt;澳&gt;小卡车，轻型货车；（博弈论，经济学）效用<br/>adj.有用的，多功能的；（体育运动）多面手的；实用的</td>
<td>复数utilities</td>
</tr>
<tr>
<td>utility</td>
<td>n.（煤气、水、电等的）公共服务，公用事业；（供电、供水等的）公用事业单位；应用程序，实用程序；实用，有用；&lt;澳&gt;小卡车，轻型货车；（博弈论，经济学）效用<br/>adj.有用的，多功能的；（体育运动）多面手的；实用的</td>
<td>复数utilities</td>
</tr>
<tr>
<td>validity</td>
<td>n.（法律上的）有效，合法，认可；真实性，正确性</td>
<td></td>
</tr>
<tr>
<td>variable</td>
<td>adj.易变的，多变的；时好时坏的；可变的，可调节的；（数）（数字）变量的；（植，动）变异的，变型的；（齿轮）变速的<br/>n.可变性，可变因素；（数学中的）变量，变元；（计算机）变量（元）；（天文）变星的简称；（东北信风带以北或南半球的东南信风带与西风带之间的）变风区</td>
<td>复数variables<br/>比较级more variable<br/>最高级most variable</td>
</tr>
<tr>
<td>vehicle</td>
<td>n.交通工具，车辆；（实现目的的）工具，媒介；（为展露主演者才华而）度身定制的创作（电影、电视节目、歌曲等）；赋形药，调漆料；（个人，组织从事经营、尤指投资的）公司</td>
<td>复数vehicles</td>
</tr>
<tr>
<td>version</td>
<td>n.（同一种物件稍有不同的）样式，型号；（从不同角度的）说法，描述；（电影、剧本、乐曲等的）版本，改编形式；《圣经》译本；胎位倒转术<br/>v.创制……的新版本，更新……的版本</td>
<td>复数versions</td>
</tr>
<tr>
<td>via</td>
<td>prep.经由，经过（某一地方）；通过，借助于（某种手段或人）</td>
<td></td>
</tr>
<tr>
<td>violation</td>
<td>n.（对法律、协议、原则等的）违背，违反；侵权行为，（对人权的）侵犯；</td>
<td></td>
</tr>
<tr>
<td>（对某物的）损毁，（对圣地的）亵渎；强奸</td>
<td>复数violations</td>
<td></td>
</tr>
<tr>
<td>virtually</td>
<td>adv.事实上，几乎；虚拟地，模拟地</td>
<td></td>
</tr>
<tr>
<td>visible</td>
<td>adj.看得见的；明显的，引人注目的；（进出口贸易）有形商品的；（物理）（光）可见的；现有的，可得到的<br/>n.有形进出口货物（visibles）</td>
<td>复数visibles<br/>比较级more visible<br/>最高级most visible</td>
</tr>
<tr>
<td>vision</td>
<td>n.幻想，想象；幻觉，幻象；构想，展望；眼力，远见卓识；视力，视觉；视野；美好的人（或事物）；（电视或电影的）图像<br/>v.&lt;罕&gt;想像</td>
<td>复数visions<br/>第三人称单数visions<br/>现在分词visioning<br/>过去式visioned<br/>过去分词visioned</td>
</tr>
<tr>
<td>visual</td>
<td>adj.视觉的，视力的；栩栩如生的<br/>n.视觉资料（指说明性的图片、影片等）</td>
<td>复数visuals</td>
</tr>
<tr>
<td>volume</td>
<td>n.体积，容积；总数，总量；音量，响度；（控制音量的）旋钮，控制杆；（成套图书中的）卷，册；（期刊）合订本；书籍；&lt;史&gt;（写在羊皮纸或纸草纸上的）书卷；（尤指头发的）厚，多<br/>adj.大量的<br/>v.以卷的形式发出；成团卷起</td>
<td>复数volumes<br/>第三人称单数volumes<br/>现在分词voluming<br/>过去式volumed<br/>过去分词volumed</td>
</tr>
<tr>
<td>voluntary</td>
<td>adj.自愿的，自发的，主动的；（机构或组织）志愿的，义务性的；（工作）志愿的，无偿的，义务的；（工作者）志愿的，无偿服务的；（人体活动）随意的，可以控制的；&lt;法律&gt;（让与）自愿的，无偿的<br/>n.（教堂里管风琴演奏的）仪式终始曲；&lt;史&gt;（尤指作为其他作品的序曲，或自由创作的）即兴曲，自由调；（比赛中的）自选表演；自愿行动；志愿者</td>
<td>复数voluntaries</td>
</tr>
<tr>
<td>welfare</td>
<td>n.幸福，安康；福利救济，社会福利；（给失业者和穷人的）福利救济金<br/>adj.福利的；接受社会救济的</td>
<td></td>
</tr>
<tr>
<td>whereas</td>
<td>conj.（表示对比）但是，然而；鉴于（用于文件的开头）<br/>n.序言，开场白；条件语句</td>
<td>复数whereases</td>
</tr>
<tr>
<td>whereby</td>
<td>adv.凭此，借以<br/>conj.凭此，借以，与……一致；&lt;非正式&gt;在……的情况下，处于……的位置</td>
<td></td>
</tr>
<tr>
<td>widespread</td>
<td>adj.普遍的，广泛的</td>
<td>比较级more widespread<br/>最高级most widespread</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>摘抄</category>
      </categories>
      <tags>
        <tag>单词表</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】JavaScript的剪贴板操作</title>
    <url>/2023/12/24/JS_clipboard_API/</url>
    <content><![CDATA[<blockquote>
<p>原文地址：<br><a href="https://www.ruanyifeng.com/blog/2021/01/clipboard-api.html">《剪贴板操作 Clipboard API 教程》 - 阮一峰</a></p>
</blockquote>
<span id="more"></span>


<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>浏览器允许 JavaScript 脚本读写剪贴板，自动复制或粘贴内容。</p>
<p>一般来说，脚本不应该改动用户的剪贴板，以免不符合用户的预期。但是，有些时候这样做确实能够带来方便，比如”一键复制”功能，用户点击一下按钮，指定的内容就自动进入剪贴板。</p>
<p>目前，一共有三种方法可以实现剪贴板操作。</p>
<ul>
<li><code>Document.execCommand()</code>方法</li>
<li>异步的 Clipboard API</li>
<li><code>copy</code>事件和<code>paste</code>事件</li>
</ul>
<p>本文逐一介绍这三种方法。</p>
<h2 id="二、Document-execCommand-方法"><a href="#二、Document-execCommand-方法" class="headerlink" title="二、Document.execCommand() 方法"></a>二、Document.execCommand() 方法</h2><p><code>Document.execCommand()</code>是操作剪贴板的传统方法，各种浏览器都支持。</p>
<p>它支持复制、剪切和粘贴这三个操作。</p>
<ul>
<li><code>document.execCommand(&#39;copy&#39;)</code>（复制）</li>
<li><code>document.execCommand(&#39;cut&#39;)</code>（剪切）</li>
<li><code>document.execCommand(&#39;paste&#39;)</code>（粘贴）</li>
</ul>
<p>（1）复制操作</p>
<p>复制时，先选中文本，然后调用<code>document.execCommand(&#39;copy&#39;)</code>，选中的文本就会进入剪贴板。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> inputElement = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#input&#x27;</span>);  <span class="comment">// 获取输入框元素的DOM元素</span></span><br><span class="line">inputElement.<span class="title function_">select</span>(); <span class="comment">//选中输入框节点元素</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">execCommand</span>(<span class="string">&#x27;copy&#x27;</span>); <span class="comment">//执行复制指令</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，脚本先选中输入框<code>inputElement</code>里面的文字（<code>inputElement.select()</code>），然后<code>document.execCommand(&#39;copy&#39;)</code>将其复制到剪贴板。</p>
<p>注意，复制操作最好放在事件监听函数里面，由用户触发（比如用户点击按钮）。如果脚本自主执行，某些浏览器可能会报错。</p>
<p>（2）粘贴操作</p>
<p>粘贴时，调用<code>document.execCommand(&#39;paste&#39;)</code>，就会将剪贴板里面的内容，输出到当前的焦点元素中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pasteText = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#output&#x27;</span>); <span class="comment">// 获取输出框元素的DOM元素</span></span><br><span class="line">pasteText.<span class="title function_">focus</span>(); <span class="comment">//选中输出框节点元素。注意这里用到的方法是focus()，和前面的select()不一样</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">execCommand</span>(<span class="string">&#x27;paste&#x27;</span>); <span class="comment">//执行粘贴指令</span></span><br></pre></td></tr></table></figure>


<p>（3）缺点</p>
<p><code>Document.execCommand()</code>方法虽然方便，但是有一些缺点。</p>
<p>首先，它只能将选中的内容复制到剪贴板，无法向剪贴板任意写入内容。</p>
<p>其次，它是同步操作，如果复制/粘贴大量数据，页面会出现卡顿。有些浏览器还会跳出提示框，要求用户许可，这时在用户做出选择前，页面会失去响应。</p>
<p>为了解决这些问题，浏览器厂商提出了异步的 Clipboard API。</p>
<h2 id="三、异步-Clipboard-API"><a href="#三、异步-Clipboard-API" class="headerlink" title="三、异步 Clipboard API"></a>三、异步 Clipboard API</h2><p>Clipboard API 是下一代的剪贴板操作方法，比传统的<code>document.execCommand()</code>方法更强大、更合理。</p>
<p>它的所有操作都是异步的，返回 Promise 对象，不会造成页面卡顿。而且，它可以将任意内容（比如图片）放入剪贴板。</p>
<p><code>navigator.clipboard</code>属性返回 Clipboard 对象，所有操作都通过这个对象进行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> clipboardObj = navigator.<span class="property">clipboard</span>;</span><br></pre></td></tr></table></figure>

<p>如果<code>navigator.clipboard</code>属性返回<code>undefined</code>，就说明当前浏览器不支持这个 API。</p>
<p>由于用户可能把敏感数据（比如密码）放在剪贴板，允许脚本任意读取会产生安全风险，所以这个 API 的安全限制比较多。</p>
<p>首先，Chrome 浏览器规定，只有 HTTPS 协议的页面才能使用这个 API。不过，开发环境（<code>localhost</code>）允许使用非加密协议。</p>
<p>其次，调用时需要明确获得用户的许可。权限的具体实现使用了 Permissions API，跟剪贴板相关的有两个权限：<code>clipboard-write</code>（写权限）和<code>clipboard-read</code>（读权限）。”写权限”自动授予脚本，而”读权限”必须用户明确同意给予。也就是说，写入剪贴板，脚本可以自动完成，但是读取剪贴板时，浏览器会弹出一个对话框，询问用户是否同意读取。</p>
<p><img src="https://pic2.zhimg.com/80/v2-c9a221f3596941e56ec3bfcf3f7af1a5_720w.webp"></p>
<p>另外，需要注意的是，脚本读取的总是当前页面的剪贴板。这带来的一个问题是，如果把相关的代码粘贴到开发者工具中直接运行，可能会报错，因为这时的当前页面是开发者工具的窗口，而不是网页页面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123; </span><br><span class="line">	<span class="keyword">const</span> text = <span class="keyword">await</span> navigator.<span class="property">clipboard</span>.<span class="title function_">readText</span>(); </span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(text); </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>


<p>如果你把上面的代码，粘贴到开发者工具里面运行，就会报错。因为代码运行的时候，开发者工具窗口是当前页，这个页面不存在 Clipboard API 依赖的 DOM 接口。一个解决方法就是，相关代码放到<code>setTimeout()</code>里面延迟运行，在调用函数之前快速点击浏览器的页面窗口，将其变成当前页。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">async</span> () =&gt; &#123; </span><br><span class="line">	<span class="keyword">const</span> text = <span class="keyword">await</span> navigator.<span class="property">clipboard</span>.<span class="title function_">readText</span>(); </span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(text); </span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码粘贴到开发者工具运行后，快速点击一下网页的页面窗口，使其变为当前页，这样就不会报错了。</p>
<h2 id="四、Clipboard-对象"><a href="#四、Clipboard-对象" class="headerlink" title="四、Clipboard 对象"></a>四、Clipboard 对象</h2><p>Clipboard 对象提供了四个方法，用来读写剪贴板。它们都是异步方法，返回 Promise 对象。</p>
<h3 id="4-1-Clipboard-readText"><a href="#4-1-Clipboard-readText" class="headerlink" title="4.1 Clipboard.readText()"></a>4.1 <code>Clipboard.readText()</code></h3><p><code>Clipboard.readText()</code>方法用于复制剪贴板里面的文本数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>( <span class="string">&#x27;click&#x27;</span>, <span class="keyword">async</span> (e) =&gt; &#123; </span><br><span class="line">	<span class="keyword">const</span> text = <span class="keyword">await</span> navigator.<span class="property">clipboard</span>.<span class="title function_">readText</span>(); </span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(text); </span><br><span class="line">&#125; )</span><br></pre></td></tr></table></figure>


<p>上面示例中，用户点击页面后，就会输出剪贴板里面的文本。注意，浏览器这时会跳出一个对话框，询问用户是否同意脚本读取剪贴板。</p>
<p>如果用户不同意，脚本就会报错。这时，可以使用<code>try...catch</code>结构，处理报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getClipboardContents</span>(<span class="params"></span>) &#123; </span><br><span class="line">	<span class="keyword">try</span> &#123; </span><br><span class="line">		<span class="keyword">const</span> text = <span class="keyword">await</span> navigator.<span class="property">clipboard</span>.<span class="title function_">readText</span>(); </span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Pasted content: &#x27;</span>, text); </span><br><span class="line">	&#125; <span class="keyword">catch</span> (err) &#123; </span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Failed to read clipboard contents: &#x27;</span>, err); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-Clipboard-read"><a href="#4-2-Clipboard-read" class="headerlink" title="4.2 Clipboard.read()"></a>4.2 <code>Clipboard.read()</code></h3><p><code>Clipboard.read()</code>方法用于复制剪贴板里面的数据，可以是文本数据，也可以是二进制数据（比如图片）。该方法需要用户明确给予许可。</p>
<p>该方法返回一个 Promise 对象。一旦该对象的状态变为 resolved，就可以获得一个数组，每个数组成员都是 <code>ClipboardItem</code> 对象的实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getClipboardContents</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123; </span><br><span class="line">		<span class="keyword">const</span> clipboardItems = <span class="keyword">await</span> navigator.<span class="property">clipboard</span>.<span class="title function_">read</span>(); </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">const</span> clipboardItem <span class="keyword">of</span> clipboardItems) &#123; </span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">const</span> type <span class="keyword">of</span> clipboardItem.<span class="property">types</span>) &#123; </span><br><span class="line">				<span class="keyword">const</span> blob = <span class="keyword">await</span> clipboardItem.<span class="title function_">getType</span>(type); </span><br><span class="line">				<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(blob)); </span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; <span class="keyword">catch</span> (err) &#123; </span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">error</span>(err.<span class="property">name</span>, err.<span class="property">message</span>); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ClipboardItem</code> 对象表示一个单独的剪贴项，每个剪贴项都拥有<code>ClipboardItem.types</code>属性和<code>ClipboardItem.getType()</code>方法。</p>
<p><code>ClipboardItem.types</code>属性返回一个数组，里面的成员是该剪贴项可用的 MIME 类型，比如某个剪贴项可以用 HTML 格式粘贴，也可以用纯文本格式粘贴，那么它就有两个 MIME 类型（<code>text/html</code>和<code>text/plain</code>）。</p>
<p><code>ClipboardItem.getType(type)</code>方法用于读取剪贴项的数据，返回一个 Promise 对象。该方法接受剪贴项的 MIME 类型作为参数，返回该类型的数据，该参数是必需的，否则会报错。</p>
<h3 id="4-3-Clipboard-writeText"><a href="#4-3-Clipboard-writeText" class="headerlink" title="4.3 Clipboard.writeText()"></a>4.3 <code>Clipboard.writeText()</code></h3><p><code>Clipboard.writeText()</code>方法用于将文本内容写入剪贴板。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>( <span class="string">&#x27;click&#x27;</span>, <span class="keyword">async</span> (e) =&gt; &#123; </span><br><span class="line">	<span class="keyword">await</span> navigator.<span class="property">clipboard</span>.<span class="title function_">writeText</span>(<span class="string">&#x27;Yo&#x27;</span>) </span><br><span class="line">&#125; )</span><br></pre></td></tr></table></figure>

<p>上面示例是用户在网页点击后，脚本向剪贴板写入文本数据。</p>
<p>该方法不需要用户许可，但是最好也放在<code>try...catch</code>里面防止报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">copyPageUrl</span>(<span class="params"></span>) &#123; </span><br><span class="line">	<span class="keyword">try</span> &#123; </span><br><span class="line">		<span class="keyword">await</span> navigator.<span class="property">clipboard</span>.<span class="title function_">writeText</span>(location.<span class="property">href</span>); </span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Page URL copied to clipboard&#x27;</span>); </span><br><span class="line">	&#125; <span class="keyword">catch</span> (err) &#123; </span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Failed to copy: &#x27;</span>, err); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>JavaScript</tag>
        <tag>剪贴板</tag>
      </tags>
  </entry>
  <entry>
    <title>代码版本管理系统Git介绍与应用实例</title>
    <url>/2023/12/24/Code_version_management_system_Git/</url>
    <content><![CDATA[<p>Git是一个开源的分布式版本控制系统，它可以有效、高速地处理从小到大的任何项目。</p>
<p>本文将从Git的诞生、原理、使用方法、分支与合并功能以及与GitHub的关系等方面对其进行简要介绍。</p>
<span id="more"></span>

<h2 id="零、背景"><a href="#零、背景" class="headerlink" title="零、背景"></a>零、背景</h2><p>Git的诞生与Linux内核的开发有着密切的关系。最初，Linux的内核开发使用的是一个商业版的版本控制系统BitKeeper，但由于Linux创始人Linus Torvalds与BitKeeper开发公司的理念不合，双方合作终止。Linus Torvalds也是个狠人，既然商业公司的BitKeeper用不了，那就自己用C语言开发一个更好的版本控制系统吧。于是Linus 闭关一个月，写出了 Git，这就是Git的由来。</p>
<blockquote>
<p>江湖传说，BitMover 公司 CEO Larry McVoy 与 Linus 曾是好友， Larry 说服 Linus 在内核开发中使用 BitKeeper。而 BitKeeper 在免费使用的许可证中加入很多限制条件，惹恼了内核开发者，最终促使 Linus 开发出了毁灭 BitKeeper 的 Git。</p>
</blockquote>
<p>Git的设计目标是速度、简单、强大的分支管理和完整性。Git最初只是为了管理Linux内核代码，但后来逐渐成为最流行的分布式版本控制系统之一，被许多开源和商业项目所采用。</p>
<h2 id="一、版本控制系统"><a href="#一、版本控制系统" class="headerlink" title="一、版本控制系统"></a>一、版本控制系统</h2><p>参考： <a href="https://blog.csdn.net/ZCShouCSDN/article/details/100590313">《版本控制系统（CVS、SVN、BitKeeper、Git ）概念、分类》</a></p>
<p>在我们的实际开发过程中，经常会有这种需求或问题：</p>
<ol>
<li>实际项目开发中，总是需要将源码拷贝多份，以满足不同的需求。例如，每发布一个版本，就需要复制一份来存档当前版本的源码。</li>
<li>实际项目开发中，基本都是多个人合作完成，在多个人写代码时，就牵扯到代码合并成一份的问题。</li>
</ol>
<p>这些就是版本控制系统需要解决的问题。</p>
<p>目前最常用的版本控制系统是Git，使用Git进行代码托管的网站包括<a href="https://www.github.com/">Github</a>、<a href="https://gitee.com/">码云Gitee</a>等，此外乌克兰GitLabInc.公司的<a href="https://gitlab.com/users/sign_in">GitLab</a> 可以用于在企业或校园的局域网中部署私有的代码仓库，用于代码托管。</p>
<h2 id="二、Git的原理"><a href="#二、Git的原理" class="headerlink" title="二、Git的原理"></a>二、Git的原理</h2><p>Git与其他常见的版本控制系统（如CVS、SVN等）有很大的不同。Git不是以文件为中心，而是以数据为中心。Git的核心是一个简单的键值对数据库，它可以存储任何类型的内容，包括文件、目录、源代码、图片等。Git把每个文件（或目录）的内容作为一个对象（object）存储在数据库中，并用一个40位的SHA-1哈希值作为对象的唯一标识。Git还有另外一种对象，叫做提交（commit），它记录了一个或多个对象的快照，以及提交的作者、时间、信息和父提交等元数据。通过提交对象，Git可以构建出一个有向无环图（DAG），表示项目的历史版本。</p>
<p>Git的工作区域分为三个部分：工作目录（working directory）、暂存区（staging area）和本地仓库（local repository）。工作目录是用户编辑文件的地方，暂存区是用户暂存修改的地方，本地仓库是用户保存版本的地方。用户可以通过不同的命令在这三个部分之间移动文件和版本，实现版本控制的功能。</p>
<h2 id="三、Git的使用方法和常用指令"><a href="#三、Git的使用方法和常用指令" class="headerlink" title="三、Git的使用方法和常用指令"></a>三、Git的使用方法和常用指令</h2><p>Git的使用方法可以分为以下几个步骤：</p>
<ul>
<li>初始化一个本地仓库或克隆一个远程仓库</li>
<li>在工作目录中修改或添加文件</li>
<li>将修改或添加的文件添加到暂存区</li>
<li>将暂存区的文件提交到本地仓库</li>
<li>将本地仓库的提交推送到远程仓库或从远程仓库拉取更新</li>
</ul>
<p>Git的常用指令如下：</p>
<ul>
<li><code>git init</code>：在当前目录下初始化一个空的本地仓库</li>
<li><code>git clone &lt;url&gt;</code>：从指定的URL克隆一个远程仓库到本地</li>
<li><code>git status</code>：查看当前工作目录和暂存区的状态，显示有哪些文件被修改或添加</li>
<li><code>git add &lt;file&gt;</code>：将指定的文件添加到暂存区，如果文件名为.，则表示添加所有文件</li>
<li><code>git commit -m &lt;message&gt;</code>：将暂存区的文件提交到本地仓库，并附上一条提交信息</li>
<li><code>git log</code>：查看本地仓库的提交历史，显示每个提交的哈希值、作者、时间和信息</li>
<li><code>git branch</code>：查看本地仓库的分支，显示有哪些分支，以及当前所在的分支</li>
<li><code>git branch &lt;name&gt;</code>：创建一个名为<name>的新分支</li>
<li><code>git checkout &lt;name&gt;</code>：切换到名为<name>的分支，如果<name>是一个提交的哈希值，则表示切换到该提交的快照</li>
<li><code>git merge &lt;name&gt;</code>：将名为<name>的分支合并到当前分支，如果有冲突，则需要手动解决</li>
<li><code>git push &lt;remote&gt; &lt;branch&gt;</code>：将本地仓库的指定分支推送到指定的远程仓库，如果远程仓库不存在该分支，则会自动创建</li>
<li><code>git pull &lt;remote&gt; &lt;branch&gt;</code>：将指定的远程仓库的指定分支拉取到本地，并与当前分支合并，如果有冲突，则需要手动解决</li>
</ul>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231224200440.png" alt="image.png"></p>
<p>以上只是Git的一些基本指令，Git还有很多高级功能和选项，可以通过git help <command>查看具体的用法和说明。</p>
<h3 id="3-1、Git的分支与合并"><a href="#3-1、Git的分支与合并" class="headerlink" title="3.1、Git的分支与合并"></a>3.1、Git的分支与合并</h3><blockquote>
<p>参考: </p>
<ul>
<li><a href="https://deepinout.com/git/git-questions/521_git_what_are_the_differences_between_git_branch_fork_fetch_merge_rebase_and_clone.html">《Git分支（branch）和分叉（fork）的区别》</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/192972614">《这才是真正的 Git——分支合并 - 腾讯技术工程的文章 - 知乎》</a></li>
</ul>
</blockquote>
<p>特别提一下Git的分支与合并功能。分支与合并是Git最强大的特点之一。分支可以让用户在不影响主线（master）的情况下，开发新的功能或修复bug。合并可以让用户将不同分支的修改整合到一起，形成一个统一的版本。</p>
<p>Git的分支实际上是一个指针，指向某个提交对象。创建分支的代价很低，因为只需要增加一个指针。切换分支的代价也很低，因为只需要改变HEAD的指向。合并分支的代价取决于分支之间的差异，如果差异较小，合并很快；如果差异较大，合并可能需要解决冲突。</p>
<p>Git 会有很多合并策略，其中常见的是 Fast-forward、Recursive 、Ours、Theirs、Octopus。默认 Git 会自动挑选合适的合并策略，如果用户需要强制指定，使用<code>git merge -s &lt;策略名字&gt;</code>。</p>
<ul>
<li>Fast-forward 是最简单的一种合并策略， 是 Git 在合并两个没有分叉的分支时的默认行为，Git 只需要将 master 分支的指向移动到最后一个 commit 节点上即可完成合并。</li>
<li>Recursive 是 Git 分支合并策略中 <strong>最重要也是最常用的策略</strong> ，是 Git 在合并两个有分叉的分支时的默认行为。其算法可以简单描述为：递归寻找路径最短的唯一共同祖先节点，然后以其为 base 节点进行递归三向合并。</li>
<li>Ours 和 Theirs 这两种合并策略也是比较简单的，简单来说就是保留双方的历史记录，但完全忽略掉某一方的文件变更。具体来说，Ours 是只采用自己这一方的文件变更而忽略对方的变更，Theirs  是只采用对方的文件变更而忽略自己这一方的变更。</li>
<li>Octopus 合并策略用于多条分支（大于等于三条）的合并，一般用于测试环境或预发布环境将多个开发分支修改的内容合并在一起。</li>
</ul>
<p>虽然Git的合并策略很多，并且部分合并策略的原理也很复杂，但一般我们在使用Git时不需要考虑这些问题， <strong>Git会帮助我们选择最适合的那个策略。</strong></p>
<h2 id="四、一个例子"><a href="#四、一个例子" class="headerlink" title="四、一个例子"></a>四、一个例子</h2><p>为了更好地理解Git的工作流程，这里举一个小例子。假设我们正在开发一个名为<code>HelloWorld</code>的项目，这个项目使用Git管理代码。同时在Github上，我们以<code>yourname</code>的账号建立一个叫做”HelloWorld”的远端存储库。我们需要实现添加代码并提交到远端存储库，以及创建分支和合并分支的操作。下面是具体步骤：</p>
<p>首先，我们在工作目录下创建一个名为<code>HelloWorld</code>的文件夹，并在里面创建一个名为<code>hello.py</code>的文件。这个文件是项目的主要代码，内容是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hello.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>接下来，在我们的工作目录下执行<code>git init</code>命令，这样，Git就会在文件夹下创建一个名为<code>.git</code>的隐藏文件夹，这个文件夹是我们的本地仓库，它用来存储项目的所有版本信息。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/home/HelloWorld $ git init</span><br><span class="line">git init</span><br><span class="line">Initialized empty Git repository in /home/HelloWorld/.git/</span><br><span class="line"></span><br><span class="line">/home/HelloWorld $ ls -a</span><br><span class="line">.  ..  .git  hello.py</span><br></pre></td></tr></table></figure>

<p>然后，我们执行<code>git add hello.py</code>命令，这样，Git就会把hello.py文件添加到暂存区，暂存区是一个临时的区域，它用来存储我们准备提交的文件。</p>
<p>接下来，我们需要执行<code>git commit -m &quot;First commit&quot;</code>命令，这样，Git就会把我们的暂存区的文件提交到本地仓库，并附上一条信息，表示这是我们的第一次提交。这时，我们的本地仓库就有了一个提交对象，它记录了我们的hello.py文件的内容，以及我们的用户名、邮箱、时间和信息。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/home/HelloWorld $ git commit -m &quot;First commit&quot;</span><br><span class="line">[main (root-commit) cbc7607] First commit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 hello.py</span><br></pre></td></tr></table></figure>

<p>然后，我们需要在GitHub上创建一个名为HelloWorld的远程仓库，这是一个网上的空间，它用来存储和分享我们的项目。我们需要复制我们的远程仓库的URL，例如 <code>https://github.com/yourname/HelloWorld.git</code> 。</p>
<p>接下来，我们需要执行 <code>git remote add origin https://github.com/yourname/HelloWorld.git</code> 命令，这样，Git就会把我们的远程仓库的URL与一个 <strong>名为origin的别名</strong> 关联起来，这样，我们就可以用origin来代替我们的远程仓库的URL，方便我们的操作。</p>
<p>然后，我们需要执行<code>git push origin main</code>命令。这样，Git就会把我们的本地仓库的main分支推送到我们的远程仓库的main分支，这时，我们的远程仓库就有了和我们的本地仓库一样的内容，我们的项目就成功地上传到了网上。</p>
<blockquote>
<p>注意，Github最开始的默认的分支名都为 master ，因此许多老教程里面会用master分支作为默认分支进行教学。2020年发生在美国的一系列社会冲突对开源社区也造成了一定的影响，从那时开始，微软公司使用main分支取代master分支作为默认分支。更多内容可以参考 <a href="https://pages.carm.cc/doc/branch-main.html">《为什么Git分支开始从“master”变为“main”了？ 》</a></p>
</blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/home/HelloWorld $ git push -u orgin main  # `-u` 参数代表&quot;set-upstream&quot; ，建议带上</span><br><span class="line">Username for &#x27;https://github.com&#x27;: yourname</span><br><span class="line">Password for &#x27;https://yourname@github.com&#x27;:</span><br><span class="line">Enumerating objects: 3, done.</span><br><span class="line">Counting objects: 100% (3/3), done.</span><br><span class="line">Writing objects: 100% (3/3), 229 bytes | 114.00 KiB/s, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">To https://github.com/yourname/helloworld.git</span><br><span class="line"> * [new branch]      main -&gt; main</span><br><span class="line">Branch &#x27;main&#x27; set up to track remote branch &#x27;main&#x27; from &#x27;orgin&#x27;.</span><br></pre></td></tr></table></figure>

<p>接下来，我们想给项目添加一个新的功能，让它可以打印出我们的名字。我们不想直接修改我们的main分支，因为这样可能会影响我们的稳定版本，所以我们决定创建一个新的分支，叫做feature。我们需要执行<code>git branch feature</code>命令，这样，Git就会在我们的本地仓库中创建一个名为feature的分支，它指向我们的当前提交，也就是我们的第一次提交。</p>
<p>然后，我们需要执行<code>git checkout feature</code>命令，这样，Git就会切换到我们的feature分支，这时，我们的工作目录和暂存区的内容也会变成我们的feature分支的内容，也就是我们的第一次提交的内容。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/home/HelloWorld $ git checkout feature</span><br><span class="line">M       hello.py</span><br><span class="line">Switched to branch &#x27;feature&#x27;</span><br></pre></td></tr></table></figure>


<p>我们可以在我们的工作目录下修改我们的hello.py文件，添加如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hello.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;What is your name? &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>接下来，我们需要执行<code>git add hello.py</code>命令，把我们修改后的文件添加到暂存区，然后执行<code>git commit -m &quot;Add name feature&quot;</code>命令，把我们的暂存区的文件提交到本地仓库，并附上一条信息，表示这是我们添加的新功能。这时，我们的本地仓库就有了一个新的提交对象，它记录了我们的修改后的文件的内容。我们的feature分支也会指向这个新的提交，而main分支仍然指向我们的第一次提交。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/home/HelloWorld $  git commit -m &quot;Add some feature&quot;</span><br><span class="line">[feature 54ab6eb] Add some feature</span><br><span class="line"> 1 file changed, 3 insertions(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>


<p>然后，我们需要执行<code>git push -u origin feature</code>命令，把本地仓库的feature分支推送到我们的远程仓库的feature分支，这时，我们的远程仓库就有了一个新的分支，它和我们的本地仓库的feature分支一样，包含了我们的新功能。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/home/HelloWorld $ git remote add helloworld https://github.com/yourname/helloworld.git  # 远程仓库还需要再添加一次                                                    </span><br><span class="line">/home/HelloWorld $ git push -u origin feature  # `-u` 参数代表&quot;set-upstream&quot; ，建议带上</span><br><span class="line">Username for &#x27;https://github.com&#x27;: yourname</span><br><span class="line">Password for &#x27;https://yourname@github.com&#x27;:</span><br><span class="line">Enumerating objects: 5, done.</span><br><span class="line">Counting objects: 100% (5/5), done.</span><br><span class="line">Delta compression using up to 4 threads</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (3/3), 296 bytes | 148.00 KiB/s, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">To https://github.com/yourname/helloworld.git</span><br><span class="line">   cbc7607..54ab6eb  feature -&gt; feature</span><br><span class="line">Branch &#x27;feature&#x27; set up to track remote branch &#x27;feature&#x27; from &#x27;helloworld&#x27;.</span><br></pre></td></tr></table></figure>


<p>接下来，我们想把我们的新功能合并到我们的主线上，让我们的项目变得更完善。我们需要执行<code>git checkout main</code>命令，切换回我们的main分支，然后执行<code>git merge feature</code>命令，把我们的feature分支合并到我们的main分支。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/home/HelloWorld $ git checkout main</span><br><span class="line">Switched to branch &#x27;main&#x27;</span><br><span class="line">Your branch is up to date with &#x27;orgin/main&#x27;.</span><br><span class="line">/home/HelloWorld $ git merge feature</span><br><span class="line">Updating cbc7607..54ab6eb</span><br><span class="line">Fast-forward</span><br><span class="line"> hello.py | 4 +++-</span><br><span class="line"> 1 file changed, 3 insertions(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>这时，Git会自动创建一个新的提交对象，它记录了我们的两个分支的合并结果，以及我们的用户名、邮箱、时间和信息。这个提交对象有两个父节点，分别是我们的main分支和feature分支的最新提交。我们的main分支也会指向这个新的提交，而我们的feature分支仍然指向我们的第二次提交。</p>
<p>然后，我们需要执行<code>git push origin main</code>命令，把我们的本地仓库的main分支推送到我们的远程仓库的main分支：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/home/HelloWorld $ git push -u origin main</span><br><span class="line">Username for &#x27;https://github.com&#x27;: yourname</span><br><span class="line">Password for &#x27;https://yourname@github.com&#x27;:</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">To https://github.com/yourname/helloworld.git</span><br><span class="line">   cbc7607..54ab6eb  main -&gt; main</span><br><span class="line">Branch &#x27;main&#x27; set up to track remote branch &#x27;main&#x27; from &#x27;helloworld&#x27;.</span><br></pre></td></tr></table></figure>

<p>这时，我们的远程仓库的main分支也会更新为我们的合并后的版本，我们的项目就完成了一个完整的开发和发布流程。</p>
<h2 id="五、尾声"><a href="#五、尾声" class="headerlink" title="五、尾声"></a>五、尾声</h2><p>Git是一个开源的分布式版本控制系统，它可以有效、高速地处理从小到大的任何项目。Git的诞生与Linux内核的开发有关，Git的原理是基于一个简单的键值对数据库，Git的使用方法是通过一系列的指令在工作目录、暂存区和本地仓库之间移动文件和版本，Git的分支与合并功能是Git最强大的特点之一，Git与GitHub的关系是工具与平台的关系。Git与GitHub的结合，使得开源项目的开发和贡献变得更加便捷和高效。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>GitHub</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>AppImage格式</title>
    <url>/2023/12/31/AppImage%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<p>本文介绍了 AppImage格式，并连带介绍了几种别的打包方式。</p>
<span id="more"></span>


<blockquote>
<p>参考</p>
<ul>
<li><a href="https://www.cnblogs.com/pipci/p/16109756.html">https://www.cnblogs.com/pipci/p/16109756.html</a></li>
<li><a href="https://itsfoss.com/use-appimage-linux/">https://itsfoss.com/use-appimage-linux/</a></li>
<li><a href="https://doc.appimage.cn/docs/appimage/">https://doc.appimage.cn/docs/appimage/</a></li>
<li><a href="https://zh.wikipedia.org/zh-cn/AppImage">https://zh.wikipedia.org/zh-cn/AppImage</a></li>
<li><a href="https://github.com/AppImage/AppImageKit/wiki/FUSE">https://github.com/AppImage/AppImageKit/wiki/FUSE</a></li>
</ul>
</blockquote>
<p>有多种方法可以在 Ubuntu或任何其他 Linux 发行版中安装软件。下载 .deb 或 .rpm 文件并双击它们以安装软件是最方便的方法之一。</p>
<p>然而近年来出现的AppImage格式则颠覆了以往的软件安装方法。<a href="http://appimage.org/">AppImage</a>是一种通用的软件包格式。通过将软件打包在 AppImage 中，开发人员只需提供一个文件即可“统管所有”。最终用户，可以在大多数（不一定是全部）现代 Linux 发行版中使用它。</p>
<h3 id="AppImage-不以传统方式安装软件"><a href="#AppImage-不以传统方式安装软件" class="headerlink" title="AppImage 不以传统方式安装软件"></a>AppImage 不以传统方式安装软件</h3><p>一个典型的 Linux 软件会在不同的地方创建文件（例如<code>/usr/bin</code> 目录），需要 root 权限才能对系统进行这些更改。</p>
<p>AppImage 不这样做。事实上，AppImage 并没有真正安装软件。它是一个压缩映像，包含运行所需软件所需的所有依赖项和库。要运行软件，只需要执行 AppImage 文件即可，站在用户视角上没有解压、提取、安装等等系列操作。卸载软件也很简单，只需要删除 AppImage 文件即可。从这点上看，AppImage和Windows系统上的<code>.exe</code>文件很像。</p>
<p>当然，Linux系统有其特殊性，除了程序的二进制文件（称为ELF文件，可以阅读<a href="https://www.jianshu.com/p/21850560caf0">《PE／ELF／Mach-O之比较》</a> 了解更多）以外，还有一些特殊的文本文件也是可以执行的，后者例如shell脚本以及带有<a href="https://zhuanlan.zhihu.com/p/627316374">shbang</a>字符串的文本文件。例如，著名的python发行版Anaconda在Linux系统平台上提供的安装包就是shell脚本格式的（文件名格式大多为<code>Anaconda3-xxxx-Linux-x86_64.sh</code>），而QQ Linux版也提供shell脚本格式的安装包。这些shell脚本格式的安装包可以直接执行，其原理是调用系统的shell脚本解释器进行解压、提取、安装等操作。</p>
<p>既然调用系统的shell脚本解释器也可以实现这种单文件的程序，且不依赖于系统的包管理器，那么AppImage也是这么做到的吗？并不是如此。如下，我们使用 <code>xxd</code> 指令查看一个典型的AppImage文件的二进制数据编码，可以看见文件的开头4个字节是 <code>.ELF</code> ，这是ELF二进制文件的标志。也就是说，AppImage是个真真切切的二进制文件，而不是调用系统shell指令的脚本。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">~$ xxd Prospect-Mail-0.5.2.AppImage |head</span><br><span class="line">00000000: 7f45 4c46 0201 0100 4149 0200 0000 0000  .ELF....AI......</span><br><span class="line">00000010: 0200 3e00 0100 0000 9046 4000 0000 0000  ..&gt;......F@.....</span><br><span class="line">00000020: 4000 0000 0000 0000 e8d7 0200 0000 0000  @...............</span><br><span class="line">00000030: 0000 0000 4000 3800 0800 4000 2000 1f00  ....@.8...@. ...</span><br><span class="line">00000040: 0600 0000 0500 0000 4000 0000 0000 0000  ........@.......</span><br><span class="line">00000050: 4000 4000 0000 0000 4000 4000 0000 0000  @.@.....@.@.....</span><br><span class="line">00000060: c001 0000 0000 0000 c001 0000 0000 0000  ................</span><br><span class="line">00000070: 0800 0000 0000 0000 0300 0000 0400 0000  ................</span><br><span class="line">00000080: 0002 0000 0000 0000 0002 4000 0000 0000  ..........@.....</span><br><span class="line">00000090: 0002 4000 0000 0000 1c00 0000 0000 0000  ..@.............</span><br></pre></td></tr></table></figure>

<p>AppImage 的一些功能或优点如下：</p>
<ul>
<li>发行版无关：可以在各种不同的 Linux 发行版上运行</li>
<li>无需安装和编译软件：可一键运行</li>
<li>无需root权限：不触及系统文件</li>
<li>便携性：可以在任何地方运行，包括活动磁盘</li>
<li>应用程序处于只读模式</li>
<li>只需删除 AppImage 文件即可删除软件</li>
</ul>
<h2 id="在-Linux-中使用-AppImage"><a href="#在-Linux-中使用-AppImage" class="headerlink" title="在 Linux 中使用 AppImage"></a>在 Linux 中使用 AppImage</h2><p>使用 AppImage 相当简单。它通过以下 3 个简单的步骤完成：</p>
<ul>
<li>下载 AppImage 文件</li>
<li>使其可执行</li>
<li>运行</li>
</ul>
<p>有很多 AppImage 格式的软件可用。在<a href="https://www.appimagehub.com/">AppImage Hub</a>网站上列出了大量的软件，直接从上面下载.appimage 包即可。GIMP、Firefox等都在其中。</p>
<p>默认情况下，下载的 AppImage 文件没有执行权限。必须更改文件的权限才能使其可执行。在命令行中使用 <code>chmod +x &lt;file name&gt;</code> 即可赋予文件可执行权限。</p>
<p>在这以后，只需要在命令行中输入指令 <code>./&lt;file name&gt;</code> （其中<code>&lt;file name&gt;</code> 是AppImage 文件名）即可运行。当然，在图形界面中双击运行也是可以的。</p>
<p>必须说明的一点是，尽管AppImage在设计时就考虑兼容更多的Linux版本，但依然存在一些Linux版本无法运行AppImage的情况，此时AppImage会抛出一段错误，提示缺少的系统组件，然后退出（如下面的终端输出）。尝试根据错误提示补充这些系统库有助于解决问题。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/home/cyclin/Prospect-Mail-0.5.2$ ./Prospect-Mail-0.5.2.AppImage</span><br><span class="line">dlopen(): error loading libfuse.so.2</span><br><span class="line"></span><br><span class="line">AppImages require FUSE to run.</span><br><span class="line">You might still be able to extract the contents of this AppImage</span><br><span class="line">if you run it with the --appimage-extract option.</span><br><span class="line">See https://github.com/AppImage/AppImageKit/wiki/FUSE</span><br><span class="line">for more information</span><br></pre></td></tr></table></figure>

<h2 id="AppImage-文件的内部结构"><a href="#AppImage-文件的内部结构" class="headerlink" title="AppImage 文件的内部结构"></a>AppImage 文件的内部结构</h2><p>如前面所言，我在Windows的Linux子系统（WSL1）上运行AppImage得到了一段错误提示，经过查询这个问题无法解决，因为WSL1并不是一个标准的Linux环境。但报错提示给了我们一点提醒，可以用 <code>--appimage-extract</code> 这个参数对AppImage进行解包。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/home/cyclin/Prospect-Mail-0.5.2$ ./Prospect-Mail-0.5.2.AppImage --appimage-extract</span><br><span class="line">squashfs-root/.DirIcon</span><br><span class="line">squashfs-root/AppRun</span><br><span class="line">squashfs-root/LICENSE.electron.txt</span><br><span class="line">squashfs-root/LICENSES.chromium.html</span><br><span class="line">squashfs-root/chrome-sandbox</span><br><span class="line">... ...</span><br><span class="line">squashfs-root/vk_swiftshader_icd.json</span><br></pre></td></tr></table></figure>

<p>运行上述解包指令，我们得到了一个叫做 <code>squashfs-root</code> 的文件夹。Squashfs 是 Linux 的压缩只读文件系统，这里即是.AppImage文件的运行环境。其中，<code>AppRun</code>文件是软件执行的主要入口，其内部包含了一段shell脚本用于配置环境和调用可执行文件。在这个文件夹下面我们还可以看到许多以 <code>.so</code> 结尾的文件，这是Linux上的动态链接库文件，是软件运行所必须的。此外还有一些<code>.dat</code> 和 <code>.json</code> 之类的配置文件和数据文件。在 <code>/usr</code> 下面则是随软件一起打包的系统库文件，用以保证AppImage在大部分Linux系统上都可以正常执行。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/home/cyclin/Prospect-Mail-0.5.2/squashfs-root$ ls -F</span><br><span class="line">AppRun*                  chrome_100_percent.pak*   libEGL.so*             libvulkan.so.1*         prospect-mail.png@  usr/</span><br><span class="line">LICENSE.electron.txt*    chrome_200_percent.pak*   libGLESv2.so*          locales/                resources/          v8_context_snapshot.bin*</span><br><span class="line">LICENSES.chromium.html*  chrome_crashpad_handler*  libffmpeg.so*          prospect-mail*          resources.pak*      vk_swiftshader_icd.json*</span><br><span class="line">chrome-sandbox*          icudtl.dat*               libvk_swiftshader.so*  prospect-mail.desktop*  snapshot_blob.bin*</span><br><span class="line"></span><br><span class="line">/home/cyclin/Prospect-Mail-0.5.2/squashfs-root$ head -n 20 AppRun</span><br><span class="line">#!/bin/bash</span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line">if [ ! -z &quot;$DEBUG&quot; ] ; then</span><br><span class="line">  env</span><br><span class="line">  set -x</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">THIS=&quot;$0&quot;</span><br><span class="line"># http://stackoverflow.com/questions/3190818/</span><br><span class="line">args=(&quot;$@&quot;)</span><br><span class="line">NUMBER_OF_ARGS=&quot;$#&quot;</span><br><span class="line"></span><br><span class="line">if [ -z &quot;$APPDIR&quot; ] ; then</span><br><span class="line">  # Find the AppDir. It is the directory that contains AppRun.</span><br><span class="line">  # This assumes that this script resides inside the AppDir or a subdirectory.</span><br><span class="line">  # If this script is run inside an AppImage, then the AppImage runtime likely has already set $APPDIR</span><br><span class="line">  path=&quot;$(dirname &quot;$(readlink -f &quot;$&#123;THIS&#125;&quot;)&quot;)&quot;</span><br><span class="line">  while [[ &quot;$path&quot; != &quot;&quot; &amp;&amp; ! -e &quot;$path/$1&quot; ]]; do</span><br><span class="line">    path=$&#123;path%/*&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h2><h3 id="1-打包不好的AppImage即使有执行权限也不会运行"><a href="#1-打包不好的AppImage即使有执行权限也不会运行" class="headerlink" title="1. 打包不好的AppImage即使有执行权限也不会运行"></a>1. 打包不好的AppImage即使有执行权限也不会运行</h3><p>AppImage 的概念是将所有依赖项都包含在包本身中。但是，如果开发人员认为他已经打包了所有依赖项但实际上并没有发生呢？</p>
<p>在这种情况下，即使授予 AppImage 执行权限也无法运行，就像前面所说的那种情况一样。对于这种情况，用户首先可以尝试根据报错信息安装缺少的系统库；如果依然无济于事，则应该联系开发人员并告知其这个问题。</p>
<h3 id="2-桌面集成"><a href="#2-桌面集成" class="headerlink" title="2.桌面集成"></a>2.桌面集成</h3><p>当运行 AppImage 文件时，某些软件可能会提示“安装桌面文件”。如果选择是， AppImage 将像常规安装的应用程序一样与 Linux 系统进行集成。</p>
<p>这意味着这个AppImage软件可以通过 Unity 或 GNOME 桌面进行搜索。可以在菜单中找到它的程序图标（如下图）。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231231120110.png" alt="image.png"></p>
<h2 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h2><h3 id="1、python和java的打包"><a href="#1、python和java的打包" class="headerlink" title="1、python和java的打包"></a>1、python和java的打包</h3><p>AppImage的这种打包方式看起来很眼熟，它相当于把一个软件要用到的所有东西全部放在了一个压缩包里，而不管其中有没有用到系统库，这一点倒是和python的Pyinstaller很像。</p>
<p>众所周知，python是解释型语言，一段python代码必须在python解释器的处理下才能执行，无法像C++、Go这类编译型语言一样编译到原生二进制可执行文件格式。然而，如果要用python开发一个软件给很多人用，而用户电脑上不一定有python环境，该怎么办呢？总不可能一个一个用户都手把手教他们安装python吧。所以Pyinstaller应运而生，它将<code>.py</code>程序源码、程序用到的各个python模块，以及一个python解释器全部打包到一个<code>.exe</code>文件当中，从而让最终得到的<code>.exe</code>文件就像普通的软件一样开箱即用。</p>
<p>要了解更多，可以参考文章 <a href="https://www.jianshu.com/p/f612f13d3b2b">《pyinstaller安装与使用——那些我踩过的坑》</a> 以及 <a href="https://pyinstaller.org/en/stable/">Pyinstaller官方文档</a>。</p>
<p>Java也是如此。一般来说，一个java程序需要编译为字节码文件（<code>.class</code>，通常一个类生成一个文件，因此一个java程序可能会编译出多个字节码文件），这虽然也是一种二进制格式，但无法在系统上原生运行，需要一个java虚拟机（Java Runtime, jre）提供运行环境。更常见的打包方式是使用 <code>jar</code> 工具将多个 <code>.class</code> 打包为一个<code>.jar</code>文件，后者包含了java程序的所有字节码文件以及一些必要的资源文件。然而即使是 <code>.jar</code> 文件，也需要jre的运行时环境。</p>
<p>那么，如果用户电脑上没有jre运行环境，该怎么办呢？思路和Pyinstaller一致，就是在打包的时候把jre一起打包进去。有一些公司会简单粗暴的把jre打包，然后发布版本的时候，再安装程序里写一个脚本，偷偷临时添加jre的环境变量（<a href="https://www.zhihu.com/question/22788689/answer/38270732">如何将Java打包成exe文件在没有JRE环境的电脑上执行？ - 知乎用户的回答</a> ）。当然，现在也有一些高级工具可以自动进行jre的打包操作，例如<a href="https://www.ej-technologies.com/download/exe4j/files">exe4j</a> 。 要了解更多，可以参考文章 <a href="https://www.jianshu.com/p/7b17143349ba">《Java打包成exe 在没有JRE环境的电脑上运行》</a> 。</p>
<h3 id="2、二进制程序在Windows和Linux上的跨平台执行"><a href="#2、二进制程序在Windows和Linux上的跨平台执行" class="headerlink" title="2、二进制程序在Windows和Linux上的跨平台执行"></a>2、二进制程序在Windows和Linux上的跨平台执行</h3><blockquote>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/584081943">《大新闻：C语言二进制程序同时“跨平台”在Windows和Linux上跑了》 - 空童的文章 - 知乎</a></p>
</blockquote>
<p>大新闻！C语言二进制程序同时“跨平台”在Windows和Linux上跑了！！！</p>
<p>这不是标题党，而是去年在科技界真实发生的新闻。湾区大佬Justine Tunney实现了这个伟大的目标。她做了个跨平台的C标准库<a href="https://justine.lol/cosmopolitan/index.html">Cosmopolitan Libc</a>，能够把C语言程序变成为“一次编译到处运行的语言”（build-once run-anywhere language）。没错，就是Java当年叫嚣的口号。不过，这里的C可执行文件可不需要解释器或者虚拟机，而是真正的本地运行的二进制文件，POSIX可运行的多语言格式，能够本地运行于Linux + Mac + Windows + FreeBSD + OpenBSD + NetBSD + BIOS，7大平台。</p>
<p>为了描述这种C语言的二进制跨平台文件格式，她甚至给它取了个名字：APE，即αcτµαlly pδrταblε εxεcµταblε。官网的字体就是那样写的，但读起来感觉就是：Actually portable executable。这个名字完美的契合了“build-once run-anywhere”的口号。</p>
<p>从官网的介绍来看，Cosmopolitan Libc打包了C语言库的很多东西，因此编译出的文件有更强的兼容性。但对于二进制文件来说，Linux平台上的ELF格式和Windows平台上的PE格式并不是一个东西，APE是怎么做到让Linux和Windows同时识别出来的呢？</p>
<p>答案藏在文件头里。在Windows系统下，<code>exe</code>文件（<a href="https://learn.microsoft.com/zh-cn/windows/win32/debug/pe-format">PE格式</a>，“portable Execute”）为了保持和DOS系统的兼容性，其文件以<code>MZ</code>两个字母开头，如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(base) C:\Users\ab124\bin&gt;xxd bunzip2.exe|head </span><br><span class="line">00000000: 4d5a 9000 0300 0000 0400 0000 ffff 0000  MZ..............</span><br><span class="line">00000010: b800 0000 0000 0000 4000 0000 0000 0000  ........@.......</span><br><span class="line">00000020: 0000 0000 0000 0000 0000 0000 0000 0000  ................</span><br><span class="line">00000030: 0000 0000 0000 0000 0000 0000 8000 0000  ................</span><br><span class="line">00000040: 0e1f ba0e 00b4 09cd 21b8 014c cd21 5468  ........!..L.!Th</span><br><span class="line">00000050: 6973 2070 726f 6772 616d 2063 616e 6e6f  is program canno</span><br><span class="line">00000060: 7420 6265 2072 756e 2069 6e20 444f 5320  t be run in DOS</span><br><span class="line">00000070: 6d6f 6465 2e0d 0d0a 2400 0000 0000 0000  mode....$.......</span><br><span class="line">00000080: 5045 0000 6486 0b00 e626 7364 0000 0000  PE..d....&amp;sd....</span><br></pre></td></tr></table></figure>

<p>在Linux系统下，<a href="https://zhuanlan.zhihu.com/p/286088470">ELF格式</a>（“Executable and Linkable Format”）的文件以 <code>.ELF</code> 三个字母开头。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">~/.local/bin$ xxd gzip |head </span><br><span class="line">00000000: 7f45 4c46 0201 0100 0000 0000 0000 0000  .ELF............</span><br><span class="line">00000010: 0300 3e00 0100 0000 c042 0000 0000 0000  ..&gt;......B......</span><br><span class="line">00000020: 4000 0000 0000 0000 c0f9 0400 0000 0000  @...............</span><br><span class="line">00000030: 0000 0000 4000 3800 0d00 4000 2800 2700  ....@.8...@.(.&#x27;.</span><br><span class="line">00000040: 0600 0000 0400 0000 4000 0000 0000 0000  ........@.......</span><br><span class="line">00000050: 4000 0000 0000 0000 4000 0000 0000 0000  @.......@.......</span><br><span class="line">00000060: d802 0000 0000 0000 d802 0000 0000 0000  ................</span><br><span class="line">00000070: 0800 0000 0000 0000 0300 0000 0400 0000  ................</span><br><span class="line">00000080: 1803 0000 0000 0000 1803 0000 0000 0000  ................</span><br><span class="line">00000090: 1803 0000 0000 0000 1c00 0000 0000 0000  ................</span><br></pre></td></tr></table></figure>

<p>然而APE二进制跨平台文件格式则另辟蹊径，通过hack下文件头，把pe文件头和符合 UNIX Sixth Edition shell 规范的脚本混合在了一起，Windows程序加载器识别其为PE文件，Linux程序加载器识别其为shell脚本，从而实现跨平台运行。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/home/cyclin/APE/cosmocc/bin$ xxd make |head </span><br><span class="line">00000000: 4d5a 7146 7044 3d27 0a0a 0010 00f8 0000  MZqFpD=&#x27;........</span><br><span class="line">00000010: 0000 0000 0001 0008 4000 0000 0000 0000  ........@.......</span><br><span class="line">00000020: 0000 0000 0000 0000 2720 3c3c 276a 7573  ........&#x27; &lt;&lt;&#x27;jus</span><br><span class="line">00000030: 7469 6e65 306c 6b73 6a6b 270a 580e 0100  tine0lksjk&#x27;.X...</span><br><span class="line">00000040: b240 eb00 eb14 9090 eb06 4883 ec08 31d2  .@........H...1.</span><br><span class="line">00000050: bd00 00eb 05e9 2545 0000 fc0f 1f87 3ee0  ......%E......&gt;.</span><br><span class="line">00000060: bf00 7031 c98e c1fa 8ed7 89cc fb0e 1fe8  ..p1............</span><br><span class="line">00000070: 0000 5e81 ee72 00b8 0002 5050 0731 ffb9  ..^..r....PP.1..</span><br><span class="line">00000080: 0002 f3a4 0f1f 87d2 ffea 8e20 0000 8ed9  ........... ....</span><br><span class="line">00000090: b900 1bb8 5000 8ec0 31c0 31ff f3aa 80fa  ....P...1.1.....</span><br></pre></td></tr></table></figure>

<p>如上面的代码块所示，使用<code>xxd</code>指令查看APE格式的make程序前100个字节，可以看到这个程序以<code>MZqFpD</code> 开头，在 Windows PE 格式下它就是普通的 PE 格式头，但它又可以被解释为汇编指令 <code>pop %r10 ; jno 0x4a ; jo 0x4a</code> ，再加上后续的指令，就可以实现判断当前是从用户空间启动还是被 boot，从而跳转到对应的代码。这真是个精妙的设计。</p>
<p>当然，对于这个项目，也有一些不同的声音，例如有人就将其评价为“毫无意义，在不同的系统用的是不同的系统api，合成一个畸形的执行程序根本改变不了任何事”。更有人认为APE这个项目仅仅停留在helloworld阶段，涉及更深层次系统调用时就无法解决系统兼容性的问题。不管怎么说，这个项目为我们提供了一个新的视角，可以通过一些巧妙的手法绕过系统限制实现平台之间的兼容。</p>
<p>事实上，计算机技术发展到今天，各个操作系统都在蓬勃发展，一方面为大家带来了更多选择，另一方面则由于系统之间的不兼容造成割裂。许多跨平台技术的出现正是为了弥合系统之间的不兼容性，而这些技术，从HTML到Java，从QT到electron，从WINE再到APE，不论最终是否真正解决了软件跨平台的问题，都对今天的计算机行业造成了很深远的影响。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>AppImage</tag>
        <tag>跨平台技术</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】 南方周末2024新年献词丨守住不惑的底线，选择做最值得的自己</title>
    <url>/2023/12/28/NFZM_2024_newyear/</url>
    <content><![CDATA[<p>没有一个冬天不可逾越，没有一个春天不会来临。</p>
<span id="more"></span>

<p>原文链接： <a href="https://mp.weixin.qq.com/s/-0tq4CuAW_JULfAP-I9C3A">https://mp.weixin.qq.com/s/-0tq4CuAW_JULfAP-I9C3A</a></p>
<p>全文共<strong>2312</strong>字，阅读大约需要<strong>4</strong>分钟</p>
<ul>
<li>守住自己的内心，守住自己的生活，就是在守住不惑的底线，守护人生的大盘。</li>
<li>即使不知道答案，即使不清楚前路，仍可选择做最值得的自己：去思考、去行动，去迎接、去探索。  </li>
</ul>
<p><strong>文｜南方周末编辑部</strong></p>
<hr>
<p>2024年的第一束阳光正在深处积蓄，我们——生于1984年的南方周末也即将迎来创刊四十周年。按照最新一次人口普查的结果，中国人的平均年龄也大约四十岁。  </p>
<p>“四十”而“不惑”，前者是这份新闻纸与吾国吾民的微妙同频，后者是我们念兹在兹的自我期许。</p>
<p>我们诞生于改革开放初启鹏程的春天里，现实百废初兴、百舸争流，未来充满未知、诸多困惑。也正因如此，穿越惑与不惑的边界，求索东方古国现代文明进步的答案，内蕴于我们的基因与使命。</p>
<p>四十年来，我们寻刻着一个民族走向复兴的经纬坐标，记录着无数个体命运的跌宕起伏；我们追求真、歌颂善、呈现美，我们抗拒假、斗争恶、暴露丑；我们持续见证、诉说并努力参与那场壮丽的春天的故事，又从那个故事中汲取无穷力量，让我们在面对未知与困惑时，绝不背离自我的基因与使命：在这里，读懂中国。</p>
<p>读懂永无止境，不惑则是一种状态。本应不惑的年岁，依然会强烈感受到各种困惑的推背感。</p>
<p>百年变局仍在高速演变，一个2023年就足以令人头晕目眩：</p>
<p>暴雨一路向北，杜苏芮狂卷乱奔，气象气候变幻莫测；支原体肺炎上热搜，流感成热词，南北儿科问者如云；网约车多地饱和，全职儿女等待“上岸”；谁记得住3000点保卫多少回？谁忘得了朱令与琴相伴又与病魔抗争的故事？摘下口罩的那一刻，你是否感到寒气？</p>
<p>中美元首在大国关系的十字路口晤谈“正确相处之道”，俄乌冲突未了，巴以厮杀又起，中东局中局风云变幻，福岛核污水每一秒钟都在随洋流扩散，这个地球，能否和合与共?</p>
<p>ChatGPT取代的是马还是马车夫？算法会控制你还是解放你？人类的未来是不是马斯克的星辰大海？新技术带来的是元宇宙的美梦还是潘多拉的魔咒？</p>
<p>惑与不惑永远在刷新边界，行动是穿越的唯一途径。越是目眩神迷，越要抱朴守一，在沧海桑田中守护方寸安宁殊为珍贵。</p>
<p>同在2023年，人们走向烧烤摊，走进演唱会，来一场“特种兵”式的旅行，在City Walk中与远方破镜重圆；与逝者道别，向生者微笑，为村超欢呼，为电竞喝彩，自己出演短剧的主角，让曾长出荒草的街道变成cos的魔法舞台。</p>
<p>这是变局中人的日常，毕竟唯一不变的只有变化本身。而在这其中，守住自己的内心，守住自己的生活，就是在守住不惑的底线，守护人生的大盘。</p>
<p>这也是似曾相识的过往。四十年来，我们看到无数这样的你，我们不停为你加油，因为我们就是你们的一部分。</p>
<p>我们感受着你的困惑，更感佩于你的行动；我们知道你生于平凡，也明白你心有不甘；我们看到你徘徊踯躅，也欣赏你迈开脚步；我们明白你犹豫不决，也理解你做出抉择；我们目睹你只有单枪匹马，也见证你汇成千军万马。</p>
<p>每一次何去何从的困惑，都可能通向一场毅然决然的醒悟。即使不知道答案，即使不清楚前路，仍可选择做最值得的自己：去思考、去行动，去迎接、去探索。无论游刃有余还是头破血流，每一次闪展腾挪都是一次饱含希望的奋起，仿佛每一团在冬夜升起的篝火，都在为迎接春日而燃烧。</p>
<p>不惑是有进无退的前行，是心怀牵挂的闯荡，是背着大山的跳舞。是上有老下有小肩上扛着整个世界却无可依靠的“必须坚强”。那就为自己点个赞吧，然后咬着牙继续走。</p>
<p>不惑是不确定中的结构涌现，是危机中萌发的生机。是在陷入迷茫时坚信自己的珍贵，在遭受厄运时坚持自己的志趣，经过光阴淘洗的种子，破土就是风华。</p>
<p>不惑是从心底生出光与热。即便历经创伤，也以明媚暖意，驱散焦灼与阴翳，随身携带一个宇宙，把爱的能量场安放在自我和他人之间。</p>
<p>不惑是既直击本质，又不失本真。是看清真相后的依然热爱，是洞穿世事后的心怀慈悲，是人生智慧的集中绽放，是“勿意、勿必、勿固、勿我”的笑对。</p>
<p>不惑是哪怕见惯山川湖海，仍能在意一粒沙、一滴水。是千疮百孔里依然藏着的倔强与柔软，是星夜兼程时对一轮朗月不知所起但一往情深的眷念。</p>
<p>不惑是时刻关照弱者的声音。我们每个人都可能是弱者，而社会的安全感与幸福感，也来源于让每个自强的人，能有示弱的机会。不惑的灵魂是夜空中最亮的星，既照亮自己的前路，也成为别人的明灯。</p>
<p>不惑是坚定那些被历史验证的共识。直面复杂与跌宕，始终执手相行，始终心怀敬畏，始终敢于创造。</p>
<p>不惑是坚守“正义、良知、爱心、理性”，是“让无力者有力，让悲观者前行”，是“没有一个冬天不可逾越”，是“总有一种力量让我们泪流满面”，是“每一个这样的你都是英雄”。</p>
<p>而不惑的本源，终将回到真实。每一道困惑的目光里，都闪烁着一个真实的梦想，那可能是大城市里的一张床，是地震后的一碗牛肉面，是父母的养老钱，是孩子的课间十分钟，是一则没有“仅限35岁以下”的招聘启事。每一次踏实的求解，都源自一个不被遮蔽的问题，敲开真相上的坚壳，方能触摸答案。</p>
<p>亲爱的读者，新年的第一束阳光正待升起。这缕晨曦将无远弗届，驱走长夜阴冷，照进大地每一个角落，照进过去、现在与未来。在南方周末将满四十周岁之际，我们期待能与你共同做到不困、不惑、不忧、不惧。</p>
<p>祝你新年快乐！</p>
]]></content>
      <categories>
        <category>摘抄</category>
      </categories>
      <tags>
        <tag>新年献词</tag>
      </tags>
  </entry>
  <entry>
    <title>R语言的对象系统（S3-R6）</title>
    <url>/2023/12/29/R_object_system/</url>
    <content><![CDATA[<p>本文转载自互联网，介绍了R语言从S3到R6的对象系统特性和使用方法。</p>
<span id="more"></span>


<blockquote>
<p>原文链接：</p>
<ul>
<li>R 面向对象编程（一） - 名本无名的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/358532080">https://zhuanlan.zhihu.com/p/358532080</a></li>
<li>R 面向对象编程（二） - 名本无名的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/358783073">https://zhuanlan.zhihu.com/p/358783073</a></li>
<li>R 面向对象编程（三）—— RC - 名本无名的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/359074012">https://zhuanlan.zhihu.com/p/359074012</a></li>
<li>R 面向对象编程（四）—— R6 - 名本无名的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/359383772">https://zhuanlan.zhihu.com/p/359383772</a></li>
</ul>
<p>另外参考：</p>
<ul>
<li> 《R语言基于R6的面向对象编程》 <a href="http://blog.fens.me/r-class-r6/">http://blog.fens.me/r-class-r6/</a></li>
<li> 《发布gridgame游戏包》 <a href="http://blog.fens.me/r-game-gridgame/">http://blog.fens.me/r-game-gridgame/</a></li>
<li> 《撬动R内核的高级工具包pryr》 <a href="http://blog.fens.me/r-pryr/">http://blog.fens.me/r-pryr/</a></li>
<li> 《mlr3_R6对象》 <a href="https://cloud.tencent.com/developer/article/1775379#">https://cloud.tencent.com/developer/article/1775379#</a></li>
</ul>
</blockquote>
<hr>
<blockquote>
<p>R 面向对象编程（一） - 名本无名的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/358532080">https://zhuanlan.zhihu.com/p/358532080</a></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><h3 id="1-面向对象"><a href="#1-面向对象" class="headerlink" title="1. 面向对象"></a><strong>1. 面向对象</strong></h3><p>面向对象编程（<code>object-oriented programming</code>，<code>OOP</code>）是一种编程范式，它将对象作为程序的基本单元，一个对象包含了数据以及操作数据的函数。</p>
<p>那什么是对象？对象是类（<code>class</code>）类的实例。</p>
<p>那什么又是类呢？</p>
<p>类是对现实事物的抽象，比如说，人类是对世界上所有人的总称，而你、我却是实实在在存在于现实中的，也就是一个个对象。</p>
<p>类的定义包含了对数据的描述以及对应的操作方法，比如，人应该有性别、年龄、身高、体重等固有特征，但是每个对象，也就是说虽然每个人的特征千差万别，但都有这些固定的属性客观存在的。</p>
<h3 id="2-R-的面向对象编程"><a href="#2-R-的面向对象编程" class="headerlink" title="2. R 的面向对象编程"></a><strong>2. R 的面向对象编程</strong></h3><p>之前，我们对 <code>R</code> 的理解可能都是停留在函数式编程的概念里。也就是编写一个个函数，来处理不同的对象。</p>
<p>当然，目前 <code>R</code> 主要用于统计计算，而且代码量一般不会很大，几十或上百行。使用函数式的编程方式就可以很好的完成编程任务。</p>
<p>一般来说，在 <code>R</code> 中，函数式编程要比面向对象编程重要得多，因为你通常是将复杂的问题分解成简单的函数，而不是简单的对象。</p>
<p>那为什么我还要学习面向对象编程呢？</p>
<p>面向对象编程的优势是，能够使程序便于分析、设计、理解，提高重用性、灵活性和可扩展性。</p>
<p><code>R</code> 中的 <code>OOP</code> 系统</p>
<ul>
<li><code>base R</code> 提供的：<code>S3</code>, <code>S4</code> 和 <code>reference classes</code> (<code>RC</code>)      </li>
<li><code>CRAN</code> 包提供的：<code>R6</code>、<code>R.oo</code>、<code>proto</code>      </li>
</ul>
<h2 id="S3"><a href="#S3" class="headerlink" title="S3"></a><strong>S3</strong></h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a><strong>1.1 概念</strong></h3><p><code>S3</code> 面向对象编程，是 <code>R</code> 中第一个也是最简单的 <code>OOP</code> 系统，广泛存在于早期开发的 <code>R</code> 包中，也是 <code>CRAN</code> 包最常用的系统。</p>
<p><code>S3</code> 的实现是基于一种特殊的函数（泛型函数，根据传入对象的类型来决定调用哪个方法）</p>
<h3 id="1-2-创建-S3-对象"><a href="#1-2-创建-S3-对象" class="headerlink" title="1.2 创建 S3 对象"></a><strong>1.2 创建 S3 对象</strong></h3><p>_注意_：下面我们会使用 <code>sloop</code> 包提供的函数来帮助我们查看对象的类型</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; install.packages(&#x27;sloop&#x27;)</span><br><span class="line">&gt; library(sloop)</span><br></pre></td></tr></table></figure>

<p>首先，我们使用 <code>attr</code> 来创建一个 <code>S3</code> 对象</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; a &lt;- 1</span><br><span class="line">&gt; attr(a, &#x27;class&#x27;) &lt;- &#x27;bar&#x27;</span><br><span class="line">&gt; a</span><br><span class="line">[1] 1</span><br><span class="line">attr(,&quot;class&quot;)</span><br><span class="line">[1] &quot;bar&quot;</span><br></pre></td></tr></table></figure>

<p>使用 <code>class</code> 或 <code>attr</code> 获取对象的类型</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; class(a)</span><br><span class="line">[1] &quot;bar&quot;</span><br><span class="line">&gt; attr(a, &#x27;class&#x27;)</span><br><span class="line">[1] &quot;bar&quot;</span><br></pre></td></tr></table></figure>

<p>再用 <code>sloop</code> 包的 <code>otype</code> 来判断是何种对象</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; otype(a)</span><br><span class="line">[1] &quot;S3&quot;</span><br><span class="line">&gt; otype(1)</span><br><span class="line">[1] &quot;base&quot;</span><br></pre></td></tr></table></figure>

<p>我们也可以使用 <code>structure</code> 来构建一个 <code>S3</code> 对象</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; b &lt;- structure(2, class=&#x27;foo&#x27;)</span><br><span class="line">&gt; b</span><br><span class="line">[1] 2</span><br><span class="line">attr(,&quot;class&quot;)</span><br><span class="line">[1] &quot;foo&quot;</span><br><span class="line">&gt; otype(b)</span><br><span class="line">[1] &quot;S3&quot;</span><br></pre></td></tr></table></figure>

<p>还可以使用为 <code>class(var)</code> 赋值的方式构建</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; x &lt;- list(a=1)</span><br><span class="line">&gt; class(x)</span><br><span class="line">[1] &quot;list&quot;</span><br><span class="line">&gt; otype(x)</span><br><span class="line">[1] &quot;base&quot;</span><br><span class="line"></span><br><span class="line">&gt; class(x) &lt;- &#x27;foo&#x27;</span><br><span class="line">&gt; class(x)</span><br><span class="line">[1] &quot;foo&quot;</span><br><span class="line">&gt; otype(x)</span><br><span class="line">[1] &quot;S3&quot;</span><br></pre></td></tr></table></figure>

<p>还可以将类属性设置为向量，为 <code>S3</code> 对象指定多个类型</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; c &lt;- structure(3, class=c(&#x27;bar&#x27;, &#x27;foo&#x27;))</span><br><span class="line">&gt; class(c)</span><br><span class="line">[1] &quot;bar&quot; &quot;foo&quot;</span><br><span class="line">&gt; otype(c)</span><br><span class="line">[1] &quot;S3&quot;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-创建泛型函数"><a href="#1-3-创建泛型函数" class="headerlink" title="1.3 创建泛型函数"></a><strong>1.3 创建泛型函数</strong></h3><p>通常，我们使用 <code>UseMethod()</code> 来创建一个泛型函数，例如</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">person &lt;- function(x, ...) &#123;</span><br><span class="line">  UseMethod(&#x27;person&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义完泛型函数之后，可以使用以下方式</p>
<ul>
<li><code>person.xxx</code> 定义名为 <code>xxx</code> 的方法</li>
<li><code>person.default</code> 定义默认方法</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">person.default &lt;- function(x, ...) &#123;</span><br><span class="line">  print(&quot;I am human.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.sing &lt;- function(x, ...) &#123;</span><br><span class="line">  print(&quot;I can sing&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.name &lt;- function(x, ...) &#123;</span><br><span class="line">  print(paste0(&quot;My name is &quot;, x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那如何调用这些方法呢？</p>
<p>首先，我们定义一个 <code>class</code> 属性为 <code>&quot;sing&quot;</code> 的变量</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; a &lt;- structure(&quot;tom&quot;, class=&#x27;sing&#x27;)</span><br></pre></td></tr></table></figure>

<p>然后，将该对象 <code>a</code> 传入 <code>person</code> 中</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; person(tom)</span><br><span class="line">[1] &quot;I can sing&quot;</span><br><span class="line">&gt; person.sing(a)</span><br><span class="line">[1] &quot;I can sing&quot;</span><br></pre></td></tr></table></figure>

<p>可以看到，调用了 <code>person.sing()</code> 方法。</p>
<p>让我们再尝试其他类型</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; b &lt;- structure(&quot;tom&quot;, class=&#x27;name&#x27;)</span><br><span class="line">&gt; person(b)</span><br><span class="line">[1] &quot;My name is tom&quot;</span><br><span class="line">&gt; person(&quot;joy&quot;)</span><br><span class="line">[1] &quot;I am human.&quot;</span><br></pre></td></tr></table></figure>

<p>这样，我们只要使用 <code>person</code> 函数，就能够对不同类型的输入做出相应，输入不同类型的对象会自动调用相应的方法。</p>
<p>对于未指定的类型，会调用 <code>person.default</code> 方法。这就是泛型函数。</p>
<h3 id="1-4-S3-对象的方法"><a href="#1-4-S3-对象的方法" class="headerlink" title="1.4 S3 对象的方法"></a><strong>1.4 S3 对象的方法</strong></h3><p>我们可以使用 <code>methods()</code> 函数来获取 <code>S3</code> 对象包含的所有方法</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; methods(person)</span><br><span class="line">[1] person.default person.name    person.sing  </span><br></pre></td></tr></table></figure>

<p>可以使用 <code>generic.function</code> 参数，传递想要查询的泛型函数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; library(magrittr)</span><br><span class="line">&gt; methods(generic.function = print) %&gt;% head()</span><br><span class="line">[1] &quot;print.acf&quot;     &quot;print.anova&quot;   &quot;print.aov&quot;     &quot;print.aovlist&quot;</span><br><span class="line">[5] &quot;print.ar&quot;      &quot;print.Arima&quot;</span><br></pre></td></tr></table></figure>

<p><code>class</code> 参数指定类名</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; methods(class = lm) %&gt;% head()</span><br><span class="line">[1] &quot;add1.lm&quot;                   &quot;alias.lm&quot;                 </span><br><span class="line">[3] &quot;anova.lm&quot;                  &quot;case.names.lm&quot;            </span><br><span class="line">[5] &quot;coerce,oldClass,S3-method&quot; &quot;confint.lm&quot;</span><br></pre></td></tr></table></figure>

<p>_注意_：一些输出的函数名后缀有 <code>*</code> 号表示不可见函数，例如</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; print.xtabs</span><br><span class="line">错误: 找不到对象&#x27;print.xtabs&#x27;</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>getAnywhere</code> 获取</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; getAnywhere(print.xtabs)</span><br><span class="line">A single object matching ‘print.xtabs’ was found</span><br><span class="line">It was found in the following places</span><br><span class="line">  registered S3 method for print from namespace stats</span><br><span class="line">  namespace:stats</span><br><span class="line">with value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function (x, na.print = &quot;&quot;, ...) </span><br><span class="line">&#123;</span><br><span class="line">    ox &lt;- x</span><br><span class="line">    attr(x, &quot;call&quot;) &lt;- NULL</span><br><span class="line">    print.table(x, na.print = na.print, ...)</span><br><span class="line">    invisible(ox)</span><br><span class="line">&#125;</span><br><span class="line">&lt;bytecode: 0x7fe1e612b9e8&gt;</span><br><span class="line">&lt;environment: namespace:stats&gt;</span><br></pre></td></tr></table></figure>

<p>或者 <code>getS3method</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; getS3method(&quot;print&quot;, &quot;xtabs&quot;)</span><br><span class="line">function (x, na.print = &quot;&quot;, ...) </span><br><span class="line">&#123;</span><br><span class="line">    ox &lt;- x</span><br><span class="line">    attr(x, &quot;call&quot;) &lt;- NULL</span><br><span class="line">    print.table(x, na.print = na.print, ...)</span><br><span class="line">    invisible(ox)</span><br><span class="line">&#125;</span><br><span class="line">&lt;bytecode: 0x7fe1e612b9e8&gt;</span><br><span class="line">&lt;environment: namespace:stats&gt;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-S3-对象的继承"><a href="#1-5-S3-对象的继承" class="headerlink" title="1.5 S3 对象的继承"></a><strong>1.5 S3 对象的继承</strong></h3><p><code>S3</code> 对象是通过 <code>NextMethod()</code> 方法继承的，让我们先定义一个泛型函数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">person &lt;- function(x, ...) &#123;</span><br><span class="line">  UseMethod(&#x27;person&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.father &lt;- function(x, ...) &#123;</span><br><span class="line">  print(&quot;I am father.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.son &lt;- function(x, ...) &#123;</span><br><span class="line">  NextMethod()</span><br><span class="line">  print(&quot;I am son.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; p1 &lt;- structure(1,class=c(&quot;father&quot;))</span><br><span class="line">&gt; person(p1)</span><br><span class="line">[1] &quot;I am father.&quot;</span><br><span class="line">&gt; p2 &lt;- structure(1,class=c(&quot;son&quot;,&quot;father&quot;))</span><br><span class="line">&gt; person(p2)</span><br><span class="line">[1] &quot;I am father.&quot;</span><br><span class="line">[1] &quot;I am son.&quot;</span><br></pre></td></tr></table></figure>

<p>可以看到，在调用 <code>person(p2)</code> 之后，会先执行 <code>person.father()</code> 然后执行 <code>person.son()</code></p>
<p>_注意_：需要将被继承的类型放在第二个（<code>son</code> 之后）</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; ab &lt;- structure(1, class = c(&quot;father&quot;, &quot;son&quot;))</span><br><span class="line">&gt; person(ab)</span><br><span class="line">[1] &quot;I am father.&quot;</span><br></pre></td></tr></table></figure>

<p>这样就实现了面向对象编程中的继承</p>
<h3 id="1-6-缺点"><a href="#1-6-缺点" class="headerlink" title="1.6 缺点"></a><strong>1.6 缺点</strong></h3><ol>
<li><code>S3</code> 并不是完全的面向对象，而是基于泛型函数模拟的面向对象</li>
<li><code>S3</code> 用起来简单，但是对于复杂的对象关系，很难高清对象的意义</li>
<li>缺少检查，<code>class</code> 属性可以被任意设置</li>
</ol>
<h3 id="1-7-示例"><a href="#1-7-示例" class="headerlink" title="1.7 示例"></a><strong>1.7 示例</strong></h3><p><code>S3</code> 对象系统广泛存在于 <code>R</code> 语言的早期开发中，因此，在 <code>base</code> 包中包含了许多 <code>S3</code> 对象。</p>
<p>例如</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; ftype(plot)</span><br><span class="line">[1] &quot;S3&quot;      &quot;generic&quot;</span><br><span class="line">&gt; ftype(print)</span><br><span class="line">[1] &quot;S3&quot;      &quot;generic&quot;</span><br></pre></td></tr></table></figure>

<p>自定义 <code>S3</code> 对象</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">say &lt;- function(x, ...) &#123;</span><br><span class="line">  UseMethod(&quot;say&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">say.numeric &lt;- function(x, ...) &#123;</span><br><span class="line">  paste0(&quot;the number is &quot;, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">say.character &lt;- function(x, ...) &#123;</span><br><span class="line">  paste0(&quot;the character is &quot;, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; say(&#x27;nam&#x27;)</span><br><span class="line">[1] &quot;the character is nam&quot;</span><br><span class="line">&gt; say(12315)</span><br><span class="line">[1] &quot;the number is 12315&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>END -</li>
</ul>
<hr>
<blockquote>
<p>R 面向对象编程（二） - 名本无名的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/358783073">https://zhuanlan.zhihu.com/p/358783073</a></p>
</blockquote>
<h2 id="S4"><a href="#S4" class="headerlink" title="S4"></a><strong>S4</strong></h2><h3 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a><strong>2.1 介绍</strong></h3><p><code>S4</code> 是标准的 <code>R</code> 语言面向对象实现方式，比 <code>S3</code> 的定义更加严格，<code>S4</code> 对象有专门的函数用于定义类（<code>setClass</code>）、泛型函数（<code>setGeneric</code>）、方法（<code>setMethod</code>）以及实例化对象（<code>new</code>），提供了参数检查，多重继承功能。</p>
<p><code>S4</code> 有一个重要的组件 <code>slot</code>，它是对象的属性组件，可以使用专门的运算符 <code>@</code>（发音为 <code>at</code>）来访问。</p>
<p><code>Bioconductor</code> 社区是以 <code>S4</code> 对象作为基础框架，只接受 <code>S4</code> 定义的 <code>R</code> 包。所以，学习 <code>S4</code> 是非常有必要的</p>
<h3 id="2-2-创建对象"><a href="#2-2-创建对象" class="headerlink" title="2.2 创建对象"></a><strong>2.2 创建对象</strong></h3><p>我们需要使用 <code>setClass</code> 来定义一个类，<code>setClass</code> 的参数为</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">setClass(Class, representation, prototype, contains=character(),</span><br><span class="line">         validity, access, where, version, sealed, package,</span><br><span class="line">         S3methods = FALSE, slots)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Class</code>: 指定类名</li>
<li><code>slots</code>: 定义属性和属性类型，<code>list</code> 或命名向量</li>
<li><code>prototype</code>: 设置属性的默认值</li>
<li><code>contains=character()</code>: 指定父类（继承）</li>
<li><code>validity</code>: 定义属性的类型检查器</li>
<li><code>where</code>: 设置存储空间</li>
<li><code>sealed</code>: 如果为 <code>TRUE</code>,则不能使用 <code>setClass</code> 定义相同的类名</li>
<li><code>package</code>: 定义所属的包</li>
</ul>
<p><code>version</code>, <code>package</code>, <code>representation</code>, <code>S3methods</code> 这四个参数在 <code>R-3.0.0</code> 之后不推荐使用</p>
<p>首先，定义一个对象</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">setClass(&quot;Person&quot;,slots=list(name=&quot;character&quot;,age=&quot;numeric&quot;))</span><br></pre></td></tr></table></figure>

<p>然后，初始化一个实例</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; tom &lt;- new(&quot;Person&quot;,name=&quot;tom&quot;,age=18)</span><br><span class="line">&gt; tom</span><br><span class="line">An object of class &quot;Person&quot;</span><br><span class="line">Slot &quot;name&quot;:</span><br><span class="line">[1] &quot;tom&quot;</span><br><span class="line"></span><br><span class="line">Slot &quot;age&quot;:</span><br><span class="line">[1] 18</span><br></pre></td></tr></table></figure>

<p>也可以使用另一种方式</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; Person &lt;- setClass(&quot;Person&quot;,slots=list(name=&quot;character&quot;,age=&quot;numeric&quot;))</span><br><span class="line">&gt; tom &lt;- Person(name=&quot;tom&quot;, age=18)</span><br><span class="line">&gt; tom</span><br><span class="line">An object of class &quot;Person&quot;</span><br><span class="line">Slot &quot;name&quot;:</span><br><span class="line">[1] &quot;tom&quot;</span><br><span class="line"></span><br><span class="line">Slot &quot;age&quot;:</span><br><span class="line">[1] 18</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以初始化的对象实例包含两个属性（<code>slot</code>） <code>name</code> 和 <code>age</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; class(tom)</span><br><span class="line">[1] &quot;Person&quot;</span><br><span class="line">attr(,&quot;package&quot;)</span><br><span class="line">[1] &quot;.GlobalEnv&quot;</span><br><span class="line">&gt; otype(tom)</span><br><span class="line">[1] &quot;S4&quot;</span><br></pre></td></tr></table></figure>

<p><code>tom</code> 是一个 <code>S4</code> 对象，类型为 <code>Person</code></p>
<h3 id="那如何访问属性值呢？"><a href="#那如何访问属性值呢？" class="headerlink" title="那如何访问属性值呢？"></a><strong>那如何访问属性值呢？</strong></h3><p>我们可以使用 <code>slotNames</code> 获取对象的属性，接受一个 S4 对象变量或字符串类名</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; slotNames(tom)</span><br><span class="line">[1] &quot;name&quot; &quot;age&quot; </span><br><span class="line">&gt; slotNames(&quot;Person&quot;)</span><br><span class="line">[1] &quot;name&quot; &quot;age&quot;</span><br></pre></td></tr></table></figure>

<p><code>getSlots</code> 与 <code>slotNames</code> 类似，传入字符串类名，返回属性及其类型的字符串向量</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; getSlots(&quot;Person&quot;)</span><br><span class="line">       name         age </span><br><span class="line">&quot;character&quot;   &quot;numeric&quot; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>获取属性值</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; tom@name</span><br><span class="line">[1] &quot;tom&quot;</span><br><span class="line">&gt; tom@age</span><br><span class="line">[1] 18</span><br><span class="line">&gt; slot(tom, &quot;name&quot;)</span><br><span class="line">[1] &quot;tom&quot;</span><br><span class="line">&gt; slot(tom, &quot;age&quot;)</span><br><span class="line">[1] 18</span><br></pre></td></tr></table></figure>

<p>不同于 <code>S3</code> 使用 <code>$</code> 来访问对象的属性，在 <code>S4</code> 中使用 <code>@</code> 来获取对象的属性，或者使用 <code>slot</code> 函数</p>
<p>当然，我们也可以更改属性的值</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; tom@age &lt;- 28</span><br><span class="line">&gt; tom</span><br><span class="line">An object of class &quot;Person&quot;</span><br><span class="line">Slot &quot;name&quot;:</span><br><span class="line">[1] &quot;tom&quot;</span><br><span class="line"></span><br><span class="line">Slot &quot;age&quot;:</span><br><span class="line">[1] 28</span><br><span class="line"></span><br><span class="line">&gt; slot(tom, &quot;age&quot;) &lt;- 21</span><br><span class="line">&gt; tom</span><br><span class="line">An object of class &quot;Person&quot;</span><br><span class="line">Slot &quot;name&quot;:</span><br><span class="line">[1] &quot;tom&quot;</span><br><span class="line"></span><br><span class="line">Slot &quot;age&quot;:</span><br><span class="line">[1] 21</span><br></pre></td></tr></table></figure>

<p><code>getClass</code> 也接受一个 <code>S4</code> 对象变量，返回包含属性及其对应的值的 <code>list</code>；或字符串类名，返回属性名称及对应的类型</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; getClass(tom)</span><br><span class="line">An object of class &quot;Person&quot;</span><br><span class="line">Slot &quot;name&quot;:</span><br><span class="line">[1] &quot;tom&quot;</span><br><span class="line"></span><br><span class="line">Slot &quot;age&quot;:</span><br><span class="line">[1] 18</span><br><span class="line"></span><br><span class="line">&gt; getClass(&quot;Person&quot;)</span><br><span class="line">Class &quot;Person&quot; [in &quot;.GlobalEnv&quot;]</span><br><span class="line"></span><br><span class="line">Slots:</span><br><span class="line">                          </span><br><span class="line">Name:       name       age</span><br><span class="line">Class: character   numeric</span><br></pre></td></tr></table></figure>

<h3 id="2-3-设置默认值"><a href="#2-3-设置默认值" class="headerlink" title="2.3 设置默认值"></a><strong>2.3 设置默认值</strong></h3><p>当我们不设置属性值时，其默认值为空（不同类型的空值），比如</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; tom &lt;- new(&quot;Person&quot;)</span><br><span class="line">&gt; tom</span><br><span class="line">An object of class &quot;Person&quot;</span><br><span class="line">Slot &quot;name&quot;:</span><br><span class="line">character(0)</span><br><span class="line"></span><br><span class="line">Slot &quot;age&quot;:</span><br><span class="line">numeric(0)</span><br></pre></td></tr></table></figure>

<p>那如何设置属性的默认值呢？</p>
<p>我们可以在 <code>setClass</code> 中指定 <code>prototype</code> 参数，让我们重新定义我们的 <code>Person</code> 类</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">setClass(&quot;Person&quot;,slots=list(name=&quot;character&quot;,age=&quot;numeric&quot;),</span><br><span class="line">         prototype = list(name=&#x27;Unknow&#x27;, age=18))</span><br></pre></td></tr></table></figure>

<p>我们在初始化实例时，不指定属性值会返回默认的值，如</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; new(&quot;Person&quot;)</span><br><span class="line">An object of class &quot;Person&quot;</span><br><span class="line">Slot &quot;name&quot;:</span><br><span class="line">[1] &quot;Unknow&quot;</span><br><span class="line"></span><br><span class="line">Slot &quot;age&quot;:</span><br><span class="line">[1] 18</span><br><span class="line"></span><br><span class="line">&gt; sam &lt;- new(&quot;Person&quot;,name=&quot;sam&quot;)</span><br><span class="line">&gt; sam</span><br><span class="line">An object of class &quot;Person&quot;</span><br><span class="line">Slot &quot;name&quot;:</span><br><span class="line">[1] &quot;sam&quot;</span><br><span class="line"></span><br><span class="line">Slot &quot;age&quot;:</span><br><span class="line">[1] 18</span><br></pre></td></tr></table></figure>

<h3 id="2-4-类型检查"><a href="#2-4-类型检查" class="headerlink" title="2.4 类型检查"></a><strong>2.4 类型检查</strong></h3><p>在上面 <code>Person</code> 类的定义中，我们指定了属性值的类型，如果我们传入的类型不一致会是什么结果呢?</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; new(&quot;Person&quot;, name=&quot;tom&quot;, age=&quot;0&quot;)</span><br><span class="line">Error in validObject(.Object) : </span><br><span class="line">  类别为“Person”的对象不对: invalid object for slot &quot;age&quot; in class &quot;Person&quot;: got class &quot;character&quot;, should be or extend class &quot;numeric&quot;</span><br></pre></td></tr></table></figure>

<p>会抛出异常。</p>
<p>但是对于 <code>age</code> 参数应该是非负值，这种非类型错误可以进行额外的检查</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">setClass(&quot;Person&quot;,</span><br><span class="line">         slots=list(name=&quot;character&quot;,age=&quot;numeric&quot;),</span><br><span class="line">         prototype = list(name=&#x27;Unknow&#x27;, age=18),</span><br><span class="line">         validity = function(object) &#123;</span><br><span class="line">           if(object@age &lt;= 0) </span><br><span class="line">             return(&quot;Age is negative.&quot;)</span><br><span class="line">           return(TRUE)</span><br><span class="line">         &#125;)</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; new(&quot;Person&quot;, name=&quot;tom&quot;, age=-1)</span><br><span class="line">Error in validObject(.Object) : </span><br><span class="line">  类别为“Person”的对象不对: Age is negative.</span><br></pre></td></tr></table></figure>

<p>或者在 <code>setClass</code> 外部使用 <code>setValidity</code> 设置检查</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">setClass(&quot;Person&quot;,slots=list(name=&quot;character&quot;,age=&quot;numeric&quot;),</span><br><span class="line">         prototype = list(name=&#x27;Unknow&#x27;, age=18))</span><br><span class="line"></span><br><span class="line">setValidity(&quot;Person&quot;, function(object) &#123;</span><br><span class="line">  if(object@age &lt;= 0) </span><br><span class="line">    return(&quot;Age is negative.&quot;)</span><br><span class="line">  return(TRUE)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-5-使用已有实例创建新实例"><a href="#2-5-使用已有实例创建新实例" class="headerlink" title="2.5 使用已有实例创建新实例"></a><strong>2.5 使用已有实例创建新实例</strong></h3><p><code>S4</code> 对象还支持使用已经实例化的对象来创建新的实例化对象</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; setClass(&quot;Person&quot;,slots=list(name=&quot;character&quot;,age=&quot;numeric&quot;))</span><br><span class="line">&gt; tom &lt;- new(&quot;Person&quot;,name=&quot;tom&quot;,age=18)</span><br><span class="line">&gt; jay &lt;- initialize(tom, name=&quot;jay&quot;, age=20)</span><br><span class="line">&gt; jay</span><br><span class="line">An object of class &quot;Person&quot;</span><br><span class="line">Slot &quot;name&quot;:</span><br><span class="line">[1] &quot;jay&quot;</span><br><span class="line"></span><br><span class="line">Slot &quot;age&quot;:</span><br><span class="line">[1] 20</span><br><span class="line"></span><br><span class="line">&gt; tom</span><br><span class="line">An object of class &quot;Person&quot;</span><br><span class="line">Slot &quot;name&quot;:</span><br><span class="line">[1] &quot;tom&quot;</span><br><span class="line"></span><br><span class="line">Slot &quot;age&quot;:</span><br><span class="line">[1] 18</span><br></pre></td></tr></table></figure>

<h3 id="2-6-创建函数"><a href="#2-6-创建函数" class="headerlink" title="2.6 创建函数"></a><strong>2.6 创建函数</strong></h3><p>在定义了类及其属性之后，我们就可以定义与类相关联的方法了</p>
<p><code>S4</code> 的函数定义不同于 <code>S3</code>，<code>S4</code> 将函数的定义和实现分开了，即接口和实现分离。</p>
<p>先通过 <code>setGeneric()</code> 来定义函数的接口，然后通过 <code>setMethod()</code> 来实现函数功能。</p>
<p>我们先定义一个函数接口</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">setGeneric(name = &quot;getName&quot;,def = function(object) standardGeneric(&quot;getName&quot;))</span><br></pre></td></tr></table></figure>

<p>然后，实现函数的功能并指定类型</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">setMethod(f = &quot;getName&quot;,signature = &quot;Person&quot;,</span><br><span class="line">          definition = function(object) object@name)</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><p>我们定义一个 <code>Person</code> 类，包含了 <code>name</code> 和 <code>age</code> 两个属性，然后分别为这两个属性定义 <code>get</code> 和 <code>set</code> 方法。</p>
<p>通常，我们在面向对象的程序设计中，会将数据进行封装，而不是直接把数据暴露出来。如</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">setClass(&quot;Person&quot;,slots=list(name=&quot;character&quot;,age=&quot;numeric&quot;),</span><br><span class="line">         prototype = list(name=&#x27;Unknow&#x27;, age=18))</span><br><span class="line"></span><br><span class="line">setGeneric(name = &quot;getName&quot;,def = function(object) standardGeneric(&quot;getName&quot;))</span><br><span class="line">setMethod(f = &quot;getName&quot;,signature = &quot;Person&quot;,</span><br><span class="line">          definition = function(object) object@name)</span><br><span class="line"></span><br><span class="line">setGeneric(name = &quot;setName&quot;,def = function(object, name) standardGeneric(&quot;setName&quot;))</span><br><span class="line">setMethod(f = &quot;setName&quot;,signature = &quot;Person&quot;,</span><br><span class="line">          definition = function(object, name) &#123;</span><br><span class="line">            object@name &lt;- name</span><br><span class="line">            return(object)</span><br><span class="line">          &#125;)</span><br><span class="line"></span><br><span class="line">setGeneric(name = &quot;getAge&quot;,def = function(object) standardGeneric(&quot;getAge&quot;))</span><br><span class="line">setMethod(f = &quot;getAge&quot;,signature = &quot;Person&quot;,</span><br><span class="line">          definition = function(object) object@age)</span><br><span class="line"></span><br><span class="line">setGeneric(name = &quot;setAge&quot;,def = function(object, age) standardGeneric(&quot;setAge&quot;))</span><br><span class="line">setMethod(f = &quot;setAge&quot;,signature = &quot;Person&quot;,</span><br><span class="line">          definition = function(object, age) &#123;</span><br><span class="line">            object@age &lt;- age</span><br><span class="line">            return(object)</span><br><span class="line">          &#125;)</span><br></pre></td></tr></table></figure>

<p>使用方法</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; tom &lt;- new(&quot;Person&quot;,name=&quot;tom&quot;,age=18)</span><br><span class="line">&gt; getName(tom)</span><br><span class="line">[1] &quot;tom&quot;</span><br><span class="line">&gt; getAge(tom)</span><br><span class="line">[1] 18</span><br><span class="line">&gt; setName(tom, &quot;tomi&quot;)</span><br><span class="line">An object of class &quot;Person&quot;</span><br><span class="line">Slot &quot;name&quot;:</span><br><span class="line">[1] &quot;tomi&quot;</span><br><span class="line"></span><br><span class="line">Slot &quot;age&quot;:</span><br><span class="line">[1] 18</span><br><span class="line"></span><br><span class="line">&gt; setAge(tom, 22)</span><br><span class="line">An object of class &quot;Person&quot;</span><br><span class="line">Slot &quot;name&quot;:</span><br><span class="line">[1] &quot;tom&quot;</span><br><span class="line"></span><br><span class="line">Slot &quot;age&quot;:</span><br><span class="line">[1] 22</span><br></pre></td></tr></table></figure>

<p>查看函数的类型</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; ftype(getName)</span><br><span class="line">[1] &quot;S4&quot;      &quot;generic&quot;</span><br></pre></td></tr></table></figure>

<p>查看函数的信息</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; getMethod(&quot;getAge&quot;, &quot;Person&quot;)</span><br><span class="line">Method Definition:</span><br><span class="line"></span><br><span class="line">function (object) </span><br><span class="line">object@age</span><br><span class="line"></span><br><span class="line">Signatures:</span><br><span class="line">        object  </span><br><span class="line">target  &quot;Person&quot;</span><br><span class="line">defined &quot;Person&quot;</span><br><span class="line"></span><br><span class="line">&gt; existsMethod(&quot;getAge&quot;, &quot;Person&quot;)</span><br><span class="line">[1] TRUE</span><br><span class="line">&gt; hasMethod(&quot;getAge&quot;, &quot;Person&quot;)</span><br><span class="line">[1] TRUE</span><br></pre></td></tr></table></figure>

<h3 id="2-7-继承"><a href="#2-7-继承" class="headerlink" title="2.7 继承"></a><strong>2.7 继承</strong></h3><p><code>S4</code> 对象的继承是通过 <code>contains</code> 参数来设置的，可接受字符串类名或字符串向量</p>
<p>例如，我们定义 <code>chinese</code> 类并继承自 <code>Person</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Person &lt;- setClass(&quot;Person&quot;,</span><br><span class="line">         slots=list(name=&quot;character&quot;,age=&quot;numeric&quot;),</span><br><span class="line">         prototype = list(name=&#x27;Unknow&#x27;, age=18),</span><br><span class="line">         validity = function(object) &#123;</span><br><span class="line">           if(object@age &lt;= 0) </span><br><span class="line">             return(&quot;Age is negative.&quot;)</span><br><span class="line">           return(TRUE)</span><br><span class="line">         &#125;)</span><br><span class="line">chinese &lt;- setClass(&quot;chinese&quot;, contains = &quot;Person&quot;)</span><br></pre></td></tr></table></figure>

<p>创建实例</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; chinese(name=&quot;lisin&quot;, age = 38)</span><br><span class="line">An object of class &quot;chinese&quot;</span><br><span class="line">Slot &quot;name&quot;:</span><br><span class="line">[1] &quot;lisin&quot;</span><br><span class="line"></span><br><span class="line">Slot &quot;age&quot;:</span><br><span class="line">[1] 38</span><br></pre></td></tr></table></figure>

<h3 id="2-8-实例"><a href="#2-8-实例" class="headerlink" title="2.8 实例"></a><strong>2.8 实例</strong></h3><p>我们举个例子来加深对 <code>S4</code> 实现面向对象编程的理解</p>
<ol>
<li>我们先定义一个顶层的类：<code>Shape</code></li>
<li>然后定义两个继承自 <code>Shape</code> 的子类：<code>Circle</code>、<code>Rectangle</code></li>
<li>并添加对应的计算面积和周长的函数：<code>area</code>、<code>circum</code></li>
</ol>
<p>我们定义如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 设置父类</span><br><span class="line">Shape &lt;- setClass(&quot;Shape&quot;, slots = c(shape=&quot;character&quot;))</span><br><span class="line"># 定义父类方法，获取 shape 属性的值</span><br><span class="line">setGeneric(&quot;getShape&quot;,function(object, ...)&#123;</span><br><span class="line">  standardGeneric(&quot;getShape&quot;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setMethod(&quot;getShape&quot;, &quot;Shape&quot;, function(object, ...) &#123;</span><br><span class="line">  return(object@shape)</span><br><span class="line">&#125;)</span><br><span class="line"># 定义 area 函数的接口</span><br><span class="line">setGeneric(&quot;area&quot;,function(object, ...)&#123;</span><br><span class="line">  standardGeneric(&quot;area&quot;)</span><br><span class="line">&#125;)</span><br><span class="line"># 定义 circum 函数的接口</span><br><span class="line">setGeneric(&quot;circum&quot;,function(object, ...)&#123;</span><br><span class="line">  standardGeneric(&quot;circum&quot;)</span><br><span class="line">&#125;)</span><br><span class="line"># 定义 Circle 类</span><br><span class="line">Circle &lt;- setClass(&quot;Circle&quot;, slots = c(radius=&quot;numeric&quot;), </span><br><span class="line">                   contains = &quot;Shape&quot;, prototype = list(radius=1, shape=&quot;circle&quot;),</span><br><span class="line">                   validity = function(object) &#123;</span><br><span class="line">                     if(object@radius &lt;= 0) stop(&quot;Radius is negative&quot;)</span><br><span class="line">                   &#125;)</span><br><span class="line"># area 函数对 Circle 类的实现</span><br><span class="line">setMethod(&quot;area&quot;, &quot;Circle&quot;, function(object, ...)&#123;</span><br><span class="line">  return(pi * object@radius^2)</span><br><span class="line">&#125;)</span><br><span class="line"># circum 函数对 Circle 类的实现</span><br><span class="line">setMethod(&quot;circum&quot;, &quot;Circle&quot;, function(object, ...)&#123;</span><br><span class="line">  return(2 * pi * object@radius)</span><br><span class="line">&#125;)</span><br><span class="line"># 定义 Rectangle 类</span><br><span class="line">Rectangle &lt;- setClass(&quot;Rectangle&quot;, slots = c(height=&quot;numeric&quot;, width=&quot;numeric&quot;), </span><br><span class="line">                   contains = &quot;Shape&quot;, prototype = list(height=1, width=1, shape=&quot;rectangle&quot;),</span><br><span class="line">                   validity = function(object) &#123;</span><br><span class="line">                     if(object@height &lt;= 0 | object@width &lt;= 0) stop(&quot;Radius is negative&quot;)</span><br><span class="line">                   &#125;)</span><br><span class="line"># area 函数对 Rectangle 类的实现</span><br><span class="line">setMethod(&quot;area&quot;, &quot;Rectangle&quot;, function(object, ...)&#123;</span><br><span class="line">  return(object@height * object@width)</span><br><span class="line">&#125;)</span><br><span class="line"># circum 函数对 Rectangle 类的实现</span><br><span class="line">setMethod(&quot;circum&quot;, &quot;Rectangle&quot;, function(object, ...)&#123;</span><br><span class="line">  return(2 * (object@height + object@width))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; a &lt;- Circle(radius = 3)</span><br><span class="line">&gt; area(a)</span><br><span class="line">[1] 28.27433</span><br><span class="line">&gt; circum(a)</span><br><span class="line">[1] 18.84956</span><br><span class="line">&gt; </span><br><span class="line">&gt; b &lt;- Rectangle(height = 3, width = 4)</span><br><span class="line">&gt; area(b)</span><br><span class="line">[1] 12</span><br><span class="line">&gt; circum(b)</span><br><span class="line">[1] 14</span><br></pre></td></tr></table></figure>

<p>使用 <code>getShape</code> 获取 <code>shape</code> 属性</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; getShape(a)</span><br><span class="line">[1] &quot;circle&quot;</span><br><span class="line">&gt; getShape(b)</span><br><span class="line">[1] &quot;rectangle&quot;</span><br></pre></td></tr></table></figure>


<hr>
<blockquote>
<p>R 面向对象编程（三）—— RC - 名本无名的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/359074012">https://zhuanlan.zhihu.com/p/359074012</a></p>
</blockquote>
<h2 id="RC"><a href="#RC" class="headerlink" title="RC"></a><strong>RC</strong></h2><h3 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a><strong>3.1 介绍</strong></h3><p><code>Reference Classes(RC)</code> 是在 <code>R 2.12</code> 版本开始引入的新一代的面向对象系统，也被称为 <code>R5</code>（这并不是官方的名称，只是为了和 <code>S3</code>、<code>S4</code> 保持队形<code>（￣。。￣）</code>）。</p>
<p>这个面向对象系统不同于 <code>S3</code> 和 <code>S4</code> 使用泛型函数模型实现类和方法，<code>RC</code> 的方法被  <em>封装</em> 在类的定义中。</p>
<p><code>RC</code> 面向对象系统在行为、风格上更像其他面向对象编程语言，如 <code>Java</code> 和 <code>C++</code> 等。</p>
<p><code>RC</code> 使用 <code>$</code> 符号来调用方法，获取和修改对象的属性，调用方法或设置属性的值会修改对象，这种方式不同于常用的函数式编程模型。</p>
<h3 id="3-2-创建-RC-类"><a href="#3-2-创建-RC-类" class="headerlink" title="3.2 创建 RC 类"></a><strong>3.2 创建 RC 类</strong></h3><p>首先，我们可以使用 <code>setRefClass</code> 来定义类，并返回一个生成器对象。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">setRefClass(Class, fields = , contains = , methods =,</span><br><span class="line">     where =, inheritPackage =, ...)</span><br></pre></td></tr></table></figure>

<p>参数列表：</p>
<ul>
<li><code>Class</code>: 字符串类名</li>
<li><code>fields</code>: 定义属性名称与类型，可以是命名字符串向量或命名列表。</li>
<li><code>contains</code>: 定义父类，多重继承传递父类向量。如果父类也是 <code>RC</code>，会继承父类的属性和方法</li>
<li><code>methods</code>: 一个命名列表，定义对象可调用的方法。也可以使用 <code>$methods</code> 方法定义函数</li>
<li><code>where</code>: 类定义的存储空间</li>
<li><code>inheritPackage</code>: 是否继承父类的环境</li>
<li><code>...</code>: 其他参数类似 <code>setClass</code></li>
</ul>
<p>定义一个 RC 类</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; Person &lt;- setRefClass(&quot;Person&quot;, fields = c(name=&#x27;character&#x27;,age=&#x27;numeric&#x27;,gender=&#x27;factor&#x27;))</span><br><span class="line">&gt; Person</span><br><span class="line">Generator for class &quot;Person&quot;:</span><br><span class="line"></span><br><span class="line">Class fields:</span><br><span class="line">                                    </span><br><span class="line">Name:       name       age    gender</span><br><span class="line">Class: character   numeric    factor</span><br><span class="line"></span><br><span class="line">Class Methods: </span><br><span class="line">     &quot;sing&quot;, &quot;say&quot;, &quot;field&quot;, &quot;trace&quot;, &quot;getRefClass&quot;, &quot;initFields&quot;, &quot;copy&quot;, &quot;callSuper&quot;, </span><br><span class="line">     &quot;.objectPackage&quot;, &quot;export&quot;, &quot;untrace&quot;, &quot;getClass&quot;, &quot;show&quot;, &quot;usingMethods&quot;, &quot;.objectParent&quot;, </span><br><span class="line">     &quot;import&quot;</span><br><span class="line"></span><br><span class="line">Reference Superclasses: </span><br><span class="line">     &quot;envRefClass&quot;</span><br></pre></td></tr></table></figure>

<p>使用 <code>$new</code> 实例化对象，也可以直接使用类名实例化</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; genders &lt;- factor(c(&quot;F&quot;, &quot;M&quot;))</span><br><span class="line">&gt; tom &lt;- Person$new(name=&quot;tom&quot;, age=19, gender=genders[1])</span><br><span class="line"># tom &lt;- Person(name=&quot;tom&quot;, age=19, gender=genders[1])</span><br><span class="line">&gt; tom</span><br><span class="line">Reference class object of class &quot;Person&quot;</span><br><span class="line">Field &quot;name&quot;:</span><br><span class="line">[1] &quot;tom&quot;</span><br><span class="line">Field &quot;age&quot;:</span><br><span class="line">[1] 19</span><br><span class="line">Field &quot;gender&quot;:</span><br><span class="line">[1] F</span><br><span class="line">Levels: F M</span><br></pre></td></tr></table></figure>

<p>查看类型</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; otype(tom)</span><br><span class="line">[1] &quot;RC&quot;</span><br><span class="line">&gt; class(tom)</span><br><span class="line">[1] &quot;Person&quot;</span><br><span class="line">attr(,&quot;package&quot;)</span><br><span class="line">[1] &quot;.GlobalEnv&quot;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-访问属性"><a href="#3-3-访问属性" class="headerlink" title="3.3 访问属性"></a><strong>3.3 访问属性</strong></h3><p>我们可以使用 <code>$</code> 符号，访问及修改属性值</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; tom$name</span><br><span class="line">[1] &quot;tom&quot;</span><br><span class="line">&gt; tom$age</span><br><span class="line">[1] 19</span><br><span class="line">&gt; tom$age &lt;- tom$age + 1</span><br><span class="line">&gt; tom$age</span><br><span class="line">[1] 20</span><br></pre></td></tr></table></figure>

<p>赋值给另一个对象</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; sam &lt;- tom</span><br><span class="line">&gt; sam</span><br><span class="line">Reference class object of class &quot;Person&quot;</span><br><span class="line">Field &quot;name&quot;:</span><br><span class="line">[1] &quot;tom&quot;</span><br><span class="line">Field &quot;age&quot;:</span><br><span class="line">[1] 20</span><br><span class="line">Field &quot;gender&quot;:</span><br><span class="line">[1] F</span><br><span class="line">Levels: F M</span><br><span class="line">&gt; sam$name &lt;- &quot;sam&quot;</span><br><span class="line">&gt; sam</span><br><span class="line">Reference class object of class &quot;Person&quot;</span><br><span class="line">Field &quot;name&quot;:</span><br><span class="line">[1] &quot;sam&quot;</span><br><span class="line">Field &quot;age&quot;:</span><br><span class="line">[1] 20</span><br><span class="line">Field &quot;gender&quot;:</span><br><span class="line">[1] F</span><br><span class="line">Levels: F M</span><br><span class="line">&gt; tom</span><br><span class="line">Reference class object of class &quot;Person&quot;</span><br><span class="line">Field &quot;name&quot;:</span><br><span class="line">[1] &quot;sam&quot;</span><br><span class="line">Field &quot;age&quot;:</span><br><span class="line">[1] 20</span><br><span class="line">Field &quot;gender&quot;:</span><br><span class="line">[1] F</span><br><span class="line">Levels: F M</span><br></pre></td></tr></table></figure>

<p>以直接赋值的方式，只是传递了对象的引用，而不是重新构建了一个实例。</p>
<p>可以调用内置的 <code>copy()</code> 方式，创建一份拷贝</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; sam &lt;- tom$copy()</span><br><span class="line">&gt; sam$age &lt;- 28</span><br><span class="line">&gt; sam</span><br><span class="line">Reference class object of class &quot;Person&quot;</span><br><span class="line">Field &quot;name&quot;:</span><br><span class="line">[1] &quot;sam&quot;</span><br><span class="line">Field &quot;age&quot;:</span><br><span class="line">[1] 28</span><br><span class="line">Field &quot;gender&quot;:</span><br><span class="line">[1] F</span><br><span class="line">Levels: F M</span><br><span class="line">&gt; tom</span><br><span class="line">Reference class object of class &quot;Person&quot;</span><br><span class="line">Field &quot;name&quot;:</span><br><span class="line">[1] &quot;sam&quot;</span><br><span class="line">Field &quot;age&quot;:</span><br><span class="line">[1] 20</span><br><span class="line">Field &quot;gender&quot;:</span><br><span class="line">[1] F</span><br><span class="line">Levels: F M</span><br></pre></td></tr></table></figure>

<h3 id="3-4-定义方法"><a href="#3-4-定义方法" class="headerlink" title="3.4 定义方法"></a><strong>3.4 定义方法</strong></h3><p>在 <code>RC</code> 对象系统中，我们可以在创建类的同时指定对应的方法，而不需要将类和函数的定义分离。</p>
<p>例如，我们定义 <code>Person</code> 类</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Person &lt;- setRefClass(&quot;Person&quot;, fields = c(name=&#x27;character&#x27;,age=&#x27;numeric&#x27;,gender=&#x27;factor&#x27;),</span><br><span class="line">                      methods = list(</span><br><span class="line">                        setName = function(x) &#123;</span><br><span class="line">                          name &lt;&lt;- x</span><br><span class="line">                        &#125;,</span><br><span class="line">                        setAge = function(x) &#123;</span><br><span class="line">                          age &lt;&lt;- x</span><br><span class="line">                        &#125;</span><br><span class="line">                      ))</span><br></pre></td></tr></table></figure>

<p>然后使用方法，改变属性值</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; jay &lt;- Person(name=&quot;jay&quot;, age=21, gender=genders[2])</span><br><span class="line">&gt; jay$setAge(28)</span><br><span class="line">&gt; jay</span><br><span class="line">Reference class object of class &quot;Person&quot;</span><br><span class="line">Field &quot;name&quot;:</span><br><span class="line">[1] &quot;jay&quot;</span><br><span class="line">Field &quot;age&quot;:</span><br><span class="line">[1] 28</span><br><span class="line">Field &quot;gender&quot;:</span><br><span class="line">[1] M</span><br><span class="line">Levels: F M</span><br></pre></td></tr></table></figure>

<p>_注意_：我们在函数内部使用了 <code>&lt;&lt;-</code> 赋值方式。</p>
<p>该赋值方式通常在函数中使用，会在其上层环境中搜索该变量，如果找到了，则重新为该变量赋值；否则会创建为一个全局变量</p>
<p>如果我们将上面的代码改为</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Person &lt;- setRefClass(&quot;Person&quot;, fields = c(name=&#x27;character&#x27;,age=&#x27;numeric&#x27;,gender=&#x27;factor&#x27;),</span><br><span class="line">                      methods = list(</span><br><span class="line">                        setName = function(x) &#123;</span><br><span class="line">                          name &lt;- x</span><br><span class="line">                        &#125;,</span><br><span class="line">                        setAge = function(x) &#123;</span><br><span class="line">                          age &lt;- x</span><br><span class="line">                        &#125;</span><br><span class="line">                      ))</span><br></pre></td></tr></table></figure>

<p>执行相同的代码</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; jay &lt;- Person(name=&quot;jay&quot;, age=21, gender=genders[2])</span><br><span class="line">&gt; jay$setAge(28)</span><br><span class="line">&gt; jay</span><br><span class="line">Reference class object of class &quot;Person&quot;</span><br><span class="line">Field &quot;name&quot;:</span><br><span class="line">[1] &quot;jay&quot;</span><br><span class="line">Field &quot;age&quot;:</span><br><span class="line">[1] 21</span><br><span class="line">Field &quot;gender&quot;:</span><br><span class="line">[1] M</span><br><span class="line">Levels: F M</span><br></pre></td></tr></table></figure>

<p>发现 <code>age</code> 的值并没有被修改</p>
<p>为了不让类定义看起来很臃肿，可以将函数的定义剥离出来。</p>
<p>我们可以使用 <code>$methods()</code> 的方式为类定义相应的方法。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Person &lt;- setRefClass(&quot;Person&quot;, fields = c(name=&#x27;character&#x27;,age=&#x27;numeric&#x27;,gender=&#x27;factor&#x27;))</span><br><span class="line"></span><br><span class="line">Person$methods(</span><br><span class="line">  setName = function(x) &#123;</span><br><span class="line">    name &lt;&lt;- x</span><br><span class="line">  &#125;,</span><br><span class="line">  setAge = function(x) &#123;</span><br><span class="line">    age &lt;&lt;- x</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>调用方法</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; jay &lt;- Person(name=&quot;jay&quot;, age=21, gender=genders[2])</span><br><span class="line">&gt; jay$setAge(28)</span><br><span class="line">&gt; jay</span><br><span class="line">Reference class object of class &quot;Person&quot;</span><br><span class="line">Field &quot;name&quot;:</span><br><span class="line">[1] &quot;jay&quot;</span><br><span class="line">Field &quot;age&quot;:</span><br><span class="line">[1] 28</span><br><span class="line">Field &quot;gender&quot;:</span><br><span class="line">[1] M</span><br><span class="line">Levels: F M</span><br></pre></td></tr></table></figure>

<h3 id="3-5-定义构造函数"><a href="#3-5-定义构造函数" class="headerlink" title="3.5 定义构造函数"></a><strong>3.5 定义构造函数</strong></h3><p><code>RC</code> 类在实例化对象时，会自动调用构造器函数 <code>$initialize()</code>，我们可以使用该函数来初始化属性值</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Person &lt;- setRefClass(&quot;Person&quot;, fields = c(name=&#x27;character&#x27;,age=&#x27;numeric&#x27;,gender=&#x27;factor&#x27;),</span><br><span class="line">                      methods = list(</span><br><span class="line">                        initialize = function(name=&quot;Unknown&quot;, age=18, gender=genders[1]) &#123;</span><br><span class="line">                          name &lt;&lt;- name</span><br><span class="line">                          age &lt;&lt;- age</span><br><span class="line">                          gender &lt;&lt;- gender</span><br><span class="line">                        &#125;</span><br><span class="line">                      ))</span><br></pre></td></tr></table></figure>

<p>实例化</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; Person()</span><br><span class="line">Reference class object of class &quot;Person&quot;</span><br><span class="line">Field &quot;name&quot;:</span><br><span class="line">[1] &quot;Unknown&quot;</span><br><span class="line">Field &quot;age&quot;:</span><br><span class="line">[1] 18</span><br><span class="line">Field &quot;gender&quot;:</span><br><span class="line">[1] F</span><br><span class="line">Levels: F M</span><br><span class="line">&gt; Person(name=&quot;tom&quot;)</span><br><span class="line">Reference class object of class &quot;Person&quot;</span><br><span class="line">Field &quot;name&quot;:</span><br><span class="line">[1] &quot;tom&quot;</span><br><span class="line">Field &quot;age&quot;:</span><br><span class="line">[1] 18</span><br><span class="line">Field &quot;gender&quot;:</span><br><span class="line">[1] F</span><br><span class="line">Levels: F M</span><br></pre></td></tr></table></figure>

<h3 id="3-6-继承"><a href="#3-6-继承" class="headerlink" title="3.6 继承"></a><strong>3.6 继承</strong></h3><p><code>RC</code> 也是通过 <code>contains</code> 参数来指定父类</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">User &lt;- setRefClass(&quot;User&quot;, fields = c(username=&quot;character&quot;, password=&quot;character&quot;))</span><br><span class="line">User$methods(</span><br><span class="line">  getName = function() &#123;</span><br><span class="line">    return(username)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">VIP &lt;- setRefClass(&quot;VIP&quot;, contains = &quot;User&quot;, fields = c(level=&quot;numeric&quot;))</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">tom &lt;- VIP(username=&quot;tom&quot;, password=&quot;123456&quot;, level=3)</span><br><span class="line">&gt; tom</span><br><span class="line">Reference class object of class &quot;VIP&quot;</span><br><span class="line">Field &quot;username&quot;:</span><br><span class="line">[1] &quot;tom&quot;</span><br><span class="line">Field &quot;password&quot;:</span><br><span class="line">[1] &quot;123456&quot;</span><br><span class="line">Field &quot;level&quot;:</span><br><span class="line">[1] 3</span><br><span class="line">&gt; tom$getName()</span><br><span class="line">[1] &quot;tom&quot;</span><br></pre></td></tr></table></figure>

<h3 id="3-7-RC-的内置方法"><a href="#3-7-RC-的内置方法" class="headerlink" title="3.7 RC 的内置方法"></a><strong>3.7 RC 的内置方法</strong></h3><p>在我们定义完类之后</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; Person</span><br><span class="line">Generator for class &quot;Person&quot;:</span><br><span class="line"></span><br><span class="line">Class fields:</span><br><span class="line">                                    </span><br><span class="line">Name:       name       age    gender</span><br><span class="line">Class: character   numeric    factor</span><br><span class="line"></span><br><span class="line">Class Methods: </span><br><span class="line">     &quot;initialize&quot;, &quot;field&quot;, &quot;trace&quot;, &quot;getRefClass&quot;, &quot;initFields&quot;, &quot;copy&quot;, &quot;callSuper&quot;, </span><br><span class="line">     &quot;.objectPackage&quot;, &quot;export&quot;, &quot;untrace&quot;, &quot;getClass&quot;, &quot;show&quot;, &quot;usingMethods&quot;, &quot;.objectParent&quot;, </span><br><span class="line">     &quot;import&quot;</span><br><span class="line"></span><br><span class="line">Reference Superclasses: </span><br><span class="line">     &quot;envRefClass&quot;</span><br></pre></td></tr></table></figure>

<p>从 <code>Class Methods</code> 输出的方法中我们可以看到，很多方法都不是我们定义的，这些都是内置的方法。像我们前面用到的 <code>copy</code> 和 <code>initialize</code> 也在其中</p>
<p><img src="https://pic3.zhimg.com/80/v2-d53e6ef8e1faf0a88376490e9430c5d2_720w.webp"></p>
<p>我们为上面的继承的例子，添加一些功能</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">User &lt;- setRefClass(&quot;User&quot;, fields = c(username=&quot;character&quot;, password=&quot;character&quot;))</span><br><span class="line">User$methods(</span><br><span class="line">  getName = function() &#123;</span><br><span class="line">    return(username)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">VIP &lt;- setRefClass(&quot;VIP&quot;, contains = &quot;User&quot;, fields = c(level=&quot;numeric&quot;))</span><br><span class="line">VIP$methods(</span><br><span class="line">  getName = function() &#123;</span><br><span class="line">    cat(&quot;VIP：&quot;, callSuper())</span><br><span class="line">  &#125;,</span><br><span class="line">  add = function(x, y) &#123;</span><br><span class="line">    return(x+y)</span><br><span class="line">  &#125;,</span><br><span class="line">  multiple = function(x, y) &#123;</span><br><span class="line">    return(x*y)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>我们在子类中重写了 <code>getName</code> 方法，通过 <code>callSuper()</code> 调用父类的 <code>getName</code> 方法获取 <code>name</code> 属性，并在前面添加 <code>VIP</code> 标记</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; tom &lt;- VIP(username=&quot;tom&quot;, password=&quot;123456&quot;, level=3)</span><br><span class="line">&gt; tom$getName()</span><br><span class="line">VIP： tom</span><br></pre></td></tr></table></figure>

<p>我们重新为 <code>tom</code> 的属性赋值</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; tom$initFields(username=&quot;sam&quot;, password=&quot;1234&quot;)</span><br><span class="line">Reference class object of class &quot;VIP&quot;</span><br><span class="line">Field &quot;username&quot;:</span><br><span class="line">[1] &quot;sam&quot;</span><br><span class="line">Field &quot;password&quot;:</span><br><span class="line">[1] &quot;1234&quot;</span><br><span class="line">Field &quot;level&quot;:</span><br><span class="line">[1] 3</span><br><span class="line">&gt; tom</span><br><span class="line">Reference class object of class &quot;VIP&quot;</span><br><span class="line">Field &quot;username&quot;:</span><br><span class="line">[1] &quot;sam&quot;</span><br><span class="line">Field &quot;password&quot;:</span><br><span class="line">[1] &quot;1234&quot;</span><br><span class="line">Field &quot;level&quot;:</span><br><span class="line">[1] 3</span><br></pre></td></tr></table></figure>

<p>获取或设置某一属性</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; tom$field(&quot;username&quot;)</span><br><span class="line">[1] &quot;sam&quot;</span><br><span class="line">&gt; tom$field(&quot;username&quot;, &quot;tom&quot;)</span><br><span class="line">&gt; tom</span><br><span class="line">Reference class object of class &quot;VIP&quot;</span><br><span class="line">Field &quot;username&quot;:</span><br><span class="line">[1] &quot;tom&quot;</span><br><span class="line">Field &quot;password&quot;:</span><br><span class="line">[1] &quot;1234&quot;</span><br><span class="line">Field &quot;level&quot;:</span><br><span class="line">[1] 3</span><br></pre></td></tr></table></figure>

<p>获取对象的类的定义</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; tom$getClass()</span><br><span class="line">Reference Class &quot;VIP&quot;:</span><br><span class="line"></span><br><span class="line">Class fields:</span><br><span class="line">                                    </span><br><span class="line">Name:   username  password     level</span><br><span class="line">Class: character character   numeric</span><br><span class="line"></span><br><span class="line">Class Methods: </span><br><span class="line">     &quot;getName#User&quot;, &quot;multiple&quot;, &quot;add&quot;, &quot;import&quot;, &quot;.objectParent&quot;, &quot;usingMethods&quot;, &quot;show&quot;, &quot;getClass&quot;, </span><br><span class="line">     &quot;untrace&quot;, &quot;export&quot;, &quot;.objectPackage&quot;, &quot;callSuper&quot;, &quot;copy&quot;, &quot;initFields&quot;, &quot;getRefClass&quot;, &quot;trace&quot;, </span><br><span class="line">     &quot;field&quot;, &quot;getName&quot;</span><br><span class="line"></span><br><span class="line">Reference Superclasses: </span><br><span class="line">     &quot;User&quot;, &quot;envRefClass&quot;</span><br><span class="line"></span><br><span class="line">&gt; tom$getRefClass()</span><br><span class="line">Generator for class &quot;VIP&quot;:</span><br><span class="line"></span><br><span class="line">Class fields:</span><br><span class="line">                                    </span><br><span class="line">Name:   username  password     level</span><br><span class="line">Class: character character   numeric</span><br><span class="line"></span><br><span class="line">Class Methods: </span><br><span class="line">     &quot;getName#User&quot;, &quot;multiple&quot;, &quot;add&quot;, &quot;import&quot;, &quot;.objectParent&quot;, &quot;usingMethods&quot;, &quot;show&quot;, &quot;getClass&quot;, </span><br><span class="line">     &quot;untrace&quot;, &quot;export&quot;, &quot;.objectPackage&quot;, &quot;callSuper&quot;, &quot;copy&quot;, &quot;initFields&quot;, &quot;getRefClass&quot;, &quot;trace&quot;, </span><br><span class="line">     &quot;field&quot;, &quot;getName&quot;</span><br><span class="line"></span><br><span class="line">Reference Superclasses: </span><br><span class="line">     &quot;User&quot;, &quot;envRefClass&quot;</span><br><span class="line"># 查看类型</span><br><span class="line">&gt; otype(tom$getClass())</span><br><span class="line">[1] &quot;S4&quot;</span><br><span class="line">&gt; otype(tom$getRefClass())</span><br><span class="line">[1] &quot;RC&quot;</span><br></pre></td></tr></table></figure>

<p><code>tom$show()</code> 和 <code>show(tom)</code> 以及直接输入 <code>tom</code> 都可以输出对象的信息</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; tom$show()</span><br><span class="line">Reference class object of class &quot;VIP&quot;</span><br><span class="line">Field &quot;username&quot;:</span><br><span class="line">[1] &quot;tom&quot;</span><br><span class="line">Field &quot;password&quot;:</span><br><span class="line">[1] &quot;1234&quot;</span><br><span class="line">Field &quot;level&quot;:</span><br><span class="line">[1] 3</span><br><span class="line">&gt; show(tom)</span><br><span class="line">Reference class object of class &quot;VIP&quot;</span><br><span class="line">Field &quot;username&quot;:</span><br><span class="line">[1] &quot;tom&quot;</span><br><span class="line">Field &quot;password&quot;:</span><br><span class="line">[1] &quot;1234&quot;</span><br><span class="line">Field &quot;level&quot;:</span><br><span class="line">[1] 3</span><br></pre></td></tr></table></figure>

<p>追踪方法</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; tom$trace(&quot;add&quot;)</span><br><span class="line">Tracing reference method &quot;add&quot; for object from class &quot;VIP&quot;</span><br><span class="line">[1] &quot;add&quot;</span><br><span class="line">&gt; tom$add(1, 3)</span><br><span class="line">Tracing tom$add(1, 3) on entry </span><br><span class="line">[1] 4</span><br><span class="line">&gt; tom$add(4, 5)</span><br><span class="line">Tracing tom$add(4, 5) on entry </span><br><span class="line">[1] 9</span><br><span class="line">&gt; tom$untrace(&quot;add&quot;)</span><br><span class="line">Untracing reference method &quot;add&quot; for object from class &quot;VIP&quot;</span><br><span class="line">[1] &quot;add&quot;</span><br><span class="line">&gt; add(1, 1)</span><br><span class="line">[1] 2</span><br></pre></td></tr></table></figure>

<p>将子类转换为父类类型</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; tom$export(&#x27;User&#x27;)</span><br><span class="line">Reference class object of class &quot;User&quot;</span><br><span class="line">Field &quot;username&quot;:</span><br><span class="line">[1] &quot;tom&quot;</span><br><span class="line">Field &quot;password&quot;:</span><br><span class="line">[1] &quot;1234&quot;</span><br><span class="line">&gt; tom</span><br><span class="line">Reference class object of class &quot;VIP&quot;</span><br><span class="line">Field &quot;username&quot;:</span><br><span class="line">[1] &quot;tom&quot;</span><br><span class="line">Field &quot;password&quot;:</span><br><span class="line">[1] &quot;1234&quot;</span><br><span class="line">Field &quot;level&quot;:</span><br><span class="line">[1] 3</span><br></pre></td></tr></table></figure>

<p>从上面的结果可以看到，转换为父类型之后，<code>level</code> 属性被删除了，但是原始对象并没有被修改</p>
<p>使用一个对象给另一个对象赋值</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; sam &lt;- VIP()</span><br><span class="line">&gt; sam</span><br><span class="line">Reference class object of class &quot;VIP&quot;</span><br><span class="line">Field &quot;username&quot;:</span><br><span class="line">character(0)</span><br><span class="line">Field &quot;password&quot;:</span><br><span class="line">character(0)</span><br><span class="line">Field &quot;level&quot;:</span><br><span class="line">numeric(0)</span><br><span class="line">&gt; sam$import(tom$export(&quot;User&quot;))</span><br><span class="line">&gt; sam</span><br><span class="line">Reference class object of class &quot;VIP&quot;</span><br><span class="line">Field &quot;username&quot;:</span><br><span class="line">[1] &quot;tom&quot;</span><br><span class="line">Field &quot;password&quot;:</span><br><span class="line">[1] &quot;1234&quot;</span><br><span class="line">Field &quot;level&quot;:</span><br><span class="line">numeric(0)</span><br><span class="line">&gt; sam$import(tom)</span><br><span class="line">&gt; sam</span><br><span class="line">Reference class object of class &quot;VIP&quot;</span><br><span class="line">Field &quot;username&quot;:</span><br><span class="line">[1] &quot;tom&quot;</span><br><span class="line">Field &quot;password&quot;:</span><br><span class="line">[1] &quot;1234&quot;</span><br><span class="line">Field &quot;level&quot;:</span><br><span class="line">[1] 3</span><br></pre></td></tr></table></figure>

<h3 id="3-8-RC-类方法"><a href="#3-8-RC-类方法" class="headerlink" title="3.8 RC 类方法"></a><strong>3.8 RC 类方法</strong></h3><p>我们使用 <code>setRefClass</code> 函数定义的类，会自动包含一些方法帮助我们查看类的属性和方法。</p>
<p>比如，我们上面使用到的 <code>$new()</code> 函数，还有一些其他函数</p>
<p>查看 <code>User</code> 类中的属性及其类型</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; User$fields()</span><br><span class="line">   username    password </span><br><span class="line">&quot;character&quot; &quot;character&quot;</span><br></pre></td></tr></table></figure>

<p>查看 <code>User</code> 中定义的方法</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; User$methods()</span><br><span class="line"> [1] &quot;.objectPackage&quot; &quot;.objectParent&quot;  &quot;callSuper&quot;      &quot;copy&quot;           &quot;export&quot;        </span><br><span class="line"> [6] &quot;field&quot;          &quot;getClass&quot;       &quot;getName&quot;        &quot;getRefClass&quot;    &quot;import&quot;        </span><br><span class="line">[11] &quot;initFields&quot;     &quot;show&quot;           &quot;trace&quot;          &quot;untrace&quot;        &quot;usingMethods&quot; </span><br></pre></td></tr></table></figure>

<p>查看函数的调用方式</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; VIP$help(&quot;add&quot;)</span><br><span class="line">Call:</span><br><span class="line">$add(x, y)</span><br></pre></td></tr></table></figure>

<p>为 <code>User</code> 的属性增加 <code>get</code> 和 <code>set</code> 方法</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; User$accessors(&quot;password&quot;)</span><br><span class="line">&gt; User$methods()</span><br><span class="line"> [1] &quot;.objectPackage&quot; &quot;.objectParent&quot;  &quot;callSuper&quot;      &quot;copy&quot;           &quot;export&quot;        </span><br><span class="line"> [6] &quot;field&quot;          &quot;getClass&quot;       &quot;getName&quot;        &quot;getPassword&quot;    &quot;getRefClass&quot;   </span><br><span class="line">[11] &quot;import&quot;         &quot;initFields&quot;     &quot;setPassword&quot;    &quot;show&quot;           &quot;trace&quot;         </span><br><span class="line">[16] &quot;untrace&quot;        &quot;usingMethods&quot;</span><br></pre></td></tr></table></figure>

<p>将属性固定，一旦赋值后便不可更改</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; User$lock(&quot;username&quot;)</span><br><span class="line"># 查看被锁定的属性</span><br><span class="line">&gt; User$lock()</span><br><span class="line">[1] &quot;username&quot;</span><br><span class="line">&gt; a &lt;- User(username=&quot;fly&quot;)</span><br><span class="line">&gt; a</span><br><span class="line">Reference class object of class &quot;User&quot;</span><br><span class="line">Field &quot;username&quot;:</span><br><span class="line">[1] &quot;fly&quot;</span><br><span class="line">Field &quot;password&quot;:</span><br><span class="line">character(0)</span><br><span class="line">&gt; a$username &lt;- &quot;a&quot;</span><br><span class="line">错误: invalid replacement: reference class field ‘username’ is read-only</span><br></pre></td></tr></table></figure>

<h3 id="3-9-示例"><a href="#3-9-示例" class="headerlink" title="3.9 示例"></a><strong>3.9 示例</strong></h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Person &lt;- setRefClass(</span><br><span class="line">  &quot;Person&quot;, </span><br><span class="line">  fields = list(</span><br><span class="line">    name=&quot;character&quot;,</span><br><span class="line">    age=&quot;numeric&quot;</span><br><span class="line">  ),</span><br><span class="line">  methods = list(</span><br><span class="line">    initialize = function(name=&quot;Unknown&quot;, age=18) &#123;</span><br><span class="line">      name &lt;&lt;- name</span><br><span class="line">      age &lt;&lt;- age</span><br><span class="line">    &#125;,</span><br><span class="line">    talk = function() &#123;</span><br><span class="line">      return(&quot;talking...&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Chinese &lt;- setRefClass(</span><br><span class="line">  &quot;Chinese&quot;,</span><br><span class="line">  contains = &quot;Person&quot;,</span><br><span class="line">  fields = list(</span><br><span class="line">    language=&quot;character&quot;</span><br><span class="line">  ),</span><br><span class="line">  methods = list(</span><br><span class="line">    initialize = function(name, age, language=&quot;chinese&quot;) &#123;</span><br><span class="line">      callSuper(name, age)</span><br><span class="line">      language &lt;&lt;- language</span><br><span class="line">    &#125;,</span><br><span class="line">    talk = function() &#123;</span><br><span class="line">      return(paste0(callSuper(), language))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line">Chinese$lock(&quot;language&quot;)</span><br><span class="line"></span><br><span class="line">American &lt;- setRefClass(</span><br><span class="line">  &quot;American&quot;,</span><br><span class="line">  contains = &quot;Person&quot;,</span><br><span class="line">  fields = list(</span><br><span class="line">    language=&quot;character&quot;</span><br><span class="line">  ),</span><br><span class="line">  methods = list(</span><br><span class="line">    initialize = function(name, age, language=&quot;english&quot;) &#123;</span><br><span class="line">      callSuper(name, age)</span><br><span class="line">      language &lt;&lt;- language</span><br><span class="line">    &#125;,</span><br><span class="line">    talk = function() &#123;</span><br><span class="line">      return(paste0(callSuper(), language))</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">American$lock(&quot;language&quot;)</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; a &lt;- American(&quot;lusy&quot;, 20)</span><br><span class="line">&gt; a</span><br><span class="line">Reference class object of class &quot;American&quot;</span><br><span class="line">Field &quot;name&quot;:</span><br><span class="line">[1] &quot;lusy&quot;</span><br><span class="line">Field &quot;age&quot;:</span><br><span class="line">[1] 20</span><br><span class="line">Field &quot;language&quot;:</span><br><span class="line">[1] &quot;english&quot;</span><br><span class="line">&gt; a$talk()</span><br><span class="line">[1] &quot;talking...english&quot;</span><br><span class="line">&gt; b &lt;- Chinese(&quot;lisin&quot;, 18)</span><br><span class="line">&gt; b</span><br><span class="line">Reference class object of class &quot;Chinese&quot;</span><br><span class="line">Field &quot;name&quot;:</span><br><span class="line">[1] &quot;lisin&quot;</span><br><span class="line">Field &quot;age&quot;:</span><br><span class="line">[1] 18</span><br><span class="line">Field &quot;language&quot;:</span><br><span class="line">[1] &quot;chinese&quot;</span><br><span class="line">&gt; b$talk()</span><br><span class="line">[1] &quot;talking...chinese&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>END -</li>
</ul>
<hr>
<blockquote>
<p>R 面向对象编程（四）—— R6 - 名本无名的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/359383772">https://zhuanlan.zhihu.com/p/359383772</a></p>
</blockquote>
<h2 id="R6"><a href="#R6" class="headerlink" title="R6"></a><strong>R6</strong></h2><h3 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a><strong>4.1 介绍</strong></h3><p><code>R6</code> 是 <code>R</code> 的封装式面向对象编程的实现，比内置的 <code>RC</code> 类更简单，更快，更轻量级。</p>
<p>与内置的 <code>R3</code>、<code>R4</code> 和 <code>RC</code> 不同，<code>R6</code> 是一个单独的 <code>R</code> 包，因此不需要依赖 <code>methods</code> 包。</p>
<p><code>R6</code> 类支持：</p>
<ul>
<li>属性和方法的公有化和私有化</li>
<li>主动绑定</li>
<li>跨包之间的继承</li>
</ul>
<p>为什么这个包叫 <code>R6</code> 呢？</p>
<p>哈哈，当然是为了保持队形了啊</p>
<p><code>S3、S4、S5、S6</code>，虽然 <code>RC</code> 的官方名称并不是 <code>S5</code>，但不妨碍大家这么称呼。</p>
<p>学过其他语言的面向对象编程系统的应该知道，我们前面几节讲的 <code>R</code> 中几种系统设计的并不够好，所以，需要 <code>R6</code> 这样的包。</p>
<h3 id="4-2-创建-R6-对象"><a href="#4-2-创建-R6-对象" class="headerlink" title="4.2 创建 R6 对象"></a><strong>4.2 创建 R6 对象</strong></h3><p><code>R6</code> 是第三方包，所以记得先安装一下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">install.packages(&quot;R6&quot;)</span><br><span class="line">library(R6)</span><br></pre></td></tr></table></figure>

<p><code>R6</code> 是通过 <code>R6Class()</code> 函数创建类</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">R6Class(classname = NULL, public = list(), private = NULL,</span><br><span class="line">  active = NULL, inherit = NULL, lock_objects = TRUE, class = TRUE,</span><br><span class="line">  portable = TRUE, lock_class = FALSE, cloneable = TRUE,</span><br><span class="line">  parent_env = parent.frame(), lock)</span><br></pre></td></tr></table></figure>

<p>参数列表</p>
<p><img src="https://pic1.zhimg.com/80/v2-c5695756bc9e29c035d24d7533f16c5c_720w.webp"></p>
<p>创建一个简单的 <code>Person</code> 类</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Person &lt;- R6Class(</span><br><span class="line">  &quot;Person&quot;,</span><br><span class="line">  public = list(</span><br><span class="line">    name = NA,</span><br><span class="line">    initialize = function(name) &#123;</span><br><span class="line">      self$name &lt;- name</span><br><span class="line">    &#125;,</span><br><span class="line">    say = function() &#123;</span><br><span class="line">      cat(&quot;my name is &quot;, self$name)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>创建实例，同样使用 <code>$new</code> 方法来实例化</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; tom &lt;- Person$new(name = &quot;tom&quot;)</span><br><span class="line">&gt; tom</span><br><span class="line">&lt;Person&gt;</span><br><span class="line">  Public:</span><br><span class="line">    clone: function (deep = FALSE) </span><br><span class="line">    initialize: function (name) </span><br><span class="line">    name: tom</span><br><span class="line">    say: function () </span><br></pre></td></tr></table></figure>

<p>查看类与实例的类型</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; class(Person)</span><br><span class="line">[1] &quot;R6ClassGenerator&quot;</span><br><span class="line">&gt; class(tom)</span><br><span class="line">[1] &quot;Person&quot; &quot;R6&quot;    </span><br><span class="line">&gt; otype(tom)</span><br><span class="line">[1] &quot;S3&quot;</span><br><span class="line">&gt; otype(Person)</span><br><span class="line">[1] &quot;S3&quot;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，其实 <code>R6</code> 系统是基于 <code>S3</code> 构建的，这也是它不同于 <code>RC</code> 的原因</p>
<h3 id="4-3-公有成员与私有成员"><a href="#4-3-公有成员与私有成员" class="headerlink" title="4.3 公有成员与私有成员"></a><strong>4.3 公有成员与私有成员</strong></h3><p>在 <code>R6</code> 系统的类定义中，可以设置公有成员和私有成员。这一特征与 <code>Java</code> 和 <code>C++</code> 的类很像，使用私有成员来隐藏一些数据属性和方法。</p>
<p>在 <code>R6</code> 中公有成员的访问使用的是 <code>self</code> 对象来引用，而私有需要用 <code>private</code> 对象来引用。</p>
<p>在前面的例子中，我们使用的是 <code>self$name</code> 来获取公有属性 <code>name</code>，现在让我们来添加私有成员</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Person &lt;- R6Class(</span><br><span class="line">  &quot;Person&quot;,</span><br><span class="line">  public = list(</span><br><span class="line">    name = NA,</span><br><span class="line">    initialize = function(name, money) &#123;</span><br><span class="line">      self$name &lt;- name</span><br><span class="line">      private$money &lt;- money</span><br><span class="line">    &#125;,</span><br><span class="line">    say = function() &#123;</span><br><span class="line">      cat(&quot;my name is &quot;, self$name)</span><br><span class="line">    &#125;,</span><br><span class="line">    incSalary = function(percent) &#123;</span><br><span class="line">      private$setMoney(private$money * (1 + percent))</span><br><span class="line">      invisible(self)</span><br><span class="line">    &#125;</span><br><span class="line">  ),</span><br><span class="line">  private = list(</span><br><span class="line">    money = NA,</span><br><span class="line">    setMoney = function(m) &#123;</span><br><span class="line">      cat(paste0(&quot;change &quot;, self$name, &quot;&#x27;s salary!\n&quot;))</span><br><span class="line">      private$money &lt;- m</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>我们添加了私有属性 <code>money</code> 和私有函数 <code>setMoney</code></p>
<p>我们先创建一个实例化对象</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; tom &lt;- Person$new(name = &quot;tom&quot;, 1000)</span><br><span class="line">&gt; tom</span><br><span class="line">&lt;Person&gt;</span><br><span class="line">  Public:</span><br><span class="line">    clone: function (deep = FALSE) </span><br><span class="line">    incSalary: function (percent) </span><br><span class="line">    initialize: function (name, money) </span><br><span class="line">    name: tom</span><br><span class="line">    say: function () </span><br><span class="line">  Private:</span><br><span class="line">    money: 1000</span><br><span class="line">    setMoney: function (m) </span><br></pre></td></tr></table></figure>

<p>然后调用对应的方法</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; tom$name</span><br><span class="line">[1] &quot;tom&quot;</span><br><span class="line">&gt; tom$money</span><br><span class="line">NULL</span><br><span class="line">&gt; tom$incSalary(0.1)</span><br><span class="line">change tom&#x27;s salary!</span><br><span class="line">&gt; tom$setMoney</span><br><span class="line">NULL</span><br><span class="line">&gt; tom$setMoney()</span><br><span class="line">错误: 不适用于非函数</span><br></pre></td></tr></table></figure>

<p>我们可以使用 <code>$</code> 符号正常访问公有成员，但是无法访问私有成员</p>
<p>_注意_：我们在 <code>incSalary</code> 函数中添加了一行 <code>invisible(self)</code>，这样我们就可以对这个方法进行链式调用了，例如</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; tom$incSalary(0.1)$incSalary(0.2)$incSalary(0.3)</span><br><span class="line">change tom&#x27;s salary!</span><br><span class="line">change tom&#x27;s salary!</span><br><span class="line">change tom&#x27;s salary!</span><br><span class="line">&gt; tom</span><br><span class="line">&lt;Person&gt;</span><br><span class="line">  Public:</span><br><span class="line">    clone: function (deep = FALSE) </span><br><span class="line">    incSalary: function (percent) </span><br><span class="line">    initialize: function (name, money) </span><br><span class="line">    name: tom</span><br><span class="line">    say: function () </span><br><span class="line">    test: function () </span><br><span class="line">  Private:</span><br><span class="line">    money: 1887.6</span><br><span class="line">    setMoney: function (m) </span><br></pre></td></tr></table></figure>

<p>_注意_：我们在访问成员时都是使用了 <code>self</code> 或 <code>private</code> 对象，而不管是在 <code>public</code> 参数里面还是 <code>private</code> 参数里面</p>
<p>我们可以测试一下 <code>self</code> 和 <code>private</code> 到底是什么，我们在上面的例子中，添加一个 <code>test</code> 公有函数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Person &lt;- R6Class(</span><br><span class="line">  &quot;Person&quot;,</span><br><span class="line">  public = list(</span><br><span class="line">    name = NA,</span><br><span class="line">    initialize = function(name, money) &#123;</span><br><span class="line">      self$name &lt;- name</span><br><span class="line">      private$money &lt;- money</span><br><span class="line">    &#125;,</span><br><span class="line">    say = function() &#123;</span><br><span class="line">      cat(&quot;my name is &quot;, self$name)</span><br><span class="line">    &#125;,</span><br><span class="line">    incSalary = function(percent) &#123;</span><br><span class="line">      private$setMoney(private$money * (1 + percent))</span><br><span class="line">    &#125;,</span><br><span class="line">    test = function() &#123;</span><br><span class="line">      print(self)</span><br><span class="line">      print(strrep(&quot;=&quot;, 20))</span><br><span class="line">      print(private)</span><br><span class="line">      print(strrep(&quot;=&quot;, 20))</span><br><span class="line">      print(ls(envir = private))</span><br><span class="line">    &#125;</span><br><span class="line">  ),</span><br><span class="line">  private = list(</span><br><span class="line">    money = NA,</span><br><span class="line">    setMoney = function(m) &#123;</span><br><span class="line">      cat(paste0(&quot;change &quot;, self$name, &quot;&#x27;s salary!&quot;))</span><br><span class="line">      private$money &lt;- m</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>测试一下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; tom &lt;- Person$new(name = &quot;tom&quot;, 1000)</span><br><span class="line">&gt; tom$test()</span><br><span class="line">&lt;Person&gt;</span><br><span class="line">  Public:</span><br><span class="line">    clone: function (deep = FALSE) </span><br><span class="line">    incSalary: function (percent) </span><br><span class="line">    initialize: function (name, money) </span><br><span class="line">    name: tom</span><br><span class="line">    say: function () </span><br><span class="line">    test: function () </span><br><span class="line">  Private:</span><br><span class="line">    money: 1000</span><br><span class="line">    setMoney: function (m) </span><br><span class="line">[1] &quot;====================&quot;</span><br><span class="line">&lt;environment: 0x7fe1d2135cf0&gt;</span><br><span class="line">[1] &quot;====================&quot;</span><br><span class="line">[1] &quot;money&quot;    &quot;setMoney&quot;</span><br></pre></td></tr></table></figure>

<p>从上面的输出结果可以看出，<code>self</code> 对象更像是实例化的对象本身，而 <code>private</code> 则是一个环境空间。这个环境空间就像是变量的作用域，因此，<code>private</code> 只在类中被调用，而对于类外部是不可见的。</p>
<h3 id="4-4-主动绑定"><a href="#4-4-主动绑定" class="headerlink" title="4.4 主动绑定"></a><strong>4.4 主动绑定</strong></h3><p>主动绑定可以让对函数调用看起来像是在访问属性，主动绑定总是公开成员，外不可见的。</p>
<p>这与 <code>Python</code> 中的 <code>@property</code> 装饰器是一样的，有些时候，我们并不想直接把数据属性暴露在外面，被随意修改。</p>
<p>例如，我们有一个 <code>Student</code> 类，包含一个 <code>score</code> 属性，但是不想将其暴露在外面被随意修改，所以我们将其设置为私有属性，同时定义 <code>get/set</code> 方法，并在 <code>set</code> 方法中控制有效范围</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Student &lt;- R6Class(</span><br><span class="line">  &quot;Student&quot;,</span><br><span class="line">  public = list(</span><br><span class="line">    name = NA,</span><br><span class="line">    initialize = function(name) &#123;</span><br><span class="line">      self$name &lt;- name</span><br><span class="line">    &#125;,</span><br><span class="line">    getScore = function() &#123;</span><br><span class="line">      return(private$score)</span><br><span class="line">    &#125;,</span><br><span class="line">    setScore = function(score) &#123;</span><br><span class="line">      if (score &lt; 0 || score &gt; 100) </span><br><span class="line">        stop(&quot;Score incorrect!&quot;)</span><br><span class="line">      private$score &lt;- score</span><br><span class="line">    &#125;</span><br><span class="line">  ),</span><br><span class="line">  private = list(</span><br><span class="line">    score = NA</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; sam &lt;- Student$new(&quot;sam&quot;)</span><br><span class="line">&gt; sam$setScore(99)</span><br><span class="line">&gt; sam$getScore()</span><br><span class="line">[1] 99</span><br><span class="line">&gt; sam$setScore(101)</span><br><span class="line">Error in sam$setScore(101) : Score incorrect!</span><br></pre></td></tr></table></figure>

<p>这样是可以达到我们的目的，但还是不能像属性那样用起来方便</p>
<p>所以 <code>R6</code> 为我们提供了 <code>active</code> 参数，重新改写上面的例子</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Student &lt;- R6Class(</span><br><span class="line">  &quot;Student&quot;,</span><br><span class="line">  public = list(</span><br><span class="line">    name = NA,</span><br><span class="line">    initialize = function(name) &#123;</span><br><span class="line">      self$name &lt;- name</span><br><span class="line">    &#125;</span><br><span class="line">  ),</span><br><span class="line">  private = list(</span><br><span class="line">    .score = NA</span><br><span class="line">  ),</span><br><span class="line">  active = list(</span><br><span class="line">    score = function(s) &#123;</span><br><span class="line">      if (missing(s))</span><br><span class="line">        return(private$.score)</span><br><span class="line">      if (s &lt; 0 || s &gt; 100)</span><br><span class="line">        stop(&quot;Score incorrect!&quot;)</span><br><span class="line">      private$.score &lt;- s</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>_注意_：<code>public</code>, <code>private</code> 和 <code>active</code> 参数内的属性名必须唯一，所以我们将私有属性改为了 <code>.score</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; sam &lt;- Student$new(&quot;sam&quot;)</span><br><span class="line">&gt; sam</span><br><span class="line">&lt;Student&gt;</span><br><span class="line">  Public:</span><br><span class="line">    clone: function (deep = FALSE) </span><br><span class="line">    initialize: function (name) </span><br><span class="line">    name: sam</span><br><span class="line">    score: active binding</span><br><span class="line">  Private:</span><br><span class="line">    .score: NA</span><br><span class="line">&gt; sam$score</span><br><span class="line">[1] NA</span><br><span class="line">&gt; sam$score &lt;- 100</span><br><span class="line">&gt; sam$score</span><br><span class="line">[1] 100</span><br></pre></td></tr></table></figure>

<h3 id="4-5-继承"><a href="#4-5-继承" class="headerlink" title="4.5 继承"></a><strong>4.5 继承</strong></h3><p>R6 通过 <code>inherit</code> 参数指定父类，例如，我们定义一个 <code>worker</code> 类，它继承自上面的 <code>Person</code> 类</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Worker &lt;- R6Class(</span><br><span class="line">  &quot;Worker&quot;,</span><br><span class="line">  inherit = Person,</span><br><span class="line">  public = list(</span><br><span class="line">    company = &quot;Gene&quot;,</span><br><span class="line">    info = function() &#123;</span><br><span class="line">      print(&quot;NGS analysis!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>创建对象并使用父类的方法</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; siri &lt;- Worker$new(&quot;Siri&quot;, 100)</span><br><span class="line">&gt; siri$incSalary(0.1)</span><br><span class="line">change Siri&#x27;s salary!</span><br><span class="line">&gt; siri</span><br><span class="line">&lt;Worker&gt;</span><br><span class="line">  Inherits from: &lt;Person&gt;</span><br><span class="line">  Public:</span><br><span class="line">    clone: function (deep = FALSE) </span><br><span class="line">    company: Gene</span><br><span class="line">    incSalary: function (percent) </span><br><span class="line">    info: function () </span><br><span class="line">    initialize: function (name, money) </span><br><span class="line">    name: Siri</span><br><span class="line">    say: function () </span><br><span class="line">    test: function () </span><br><span class="line">  Private:</span><br><span class="line">    money: 110</span><br><span class="line">    setMoney: function (m) </span><br></pre></td></tr></table></figure>

<p>我们可以使用 <code>super</code> 对象来调用父类的方法，让我们来重写 <code>incSalary</code> 方法</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Worker &lt;- R6Class(</span><br><span class="line">  &quot;Worker&quot;,</span><br><span class="line">  inherit = Person,</span><br><span class="line">  public = list(</span><br><span class="line">    company = &quot;Gene&quot;,</span><br><span class="line">    info = function() &#123;</span><br><span class="line">      print(&quot;NGS analysis!&quot;)</span><br><span class="line">    &#125;,</span><br><span class="line">    incSalary = function(percent) &#123;</span><br><span class="line">      super$incSalary(percent + 0.1)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>运行与上面相同的代码</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; siri &lt;- Worker$new(&quot;Siri&quot;, 100)</span><br><span class="line">&gt; siri$incSalary(0.1)</span><br><span class="line">change Siri&#x27;s salary!</span><br><span class="line">&gt; siri</span><br><span class="line">&lt;Worker&gt;</span><br><span class="line">  Inherits from: &lt;Person&gt;</span><br><span class="line">  Public:</span><br><span class="line">    clone: function (deep = FALSE) </span><br><span class="line">    company: Gene</span><br><span class="line">    incSalary: function (percent) </span><br><span class="line">    info: function () </span><br><span class="line">    initialize: function (name, money) </span><br><span class="line">    name: Siri</span><br><span class="line">    say: function () </span><br><span class="line">    test: function () </span><br><span class="line">  Private:</span><br><span class="line">    money: 120</span><br><span class="line">    setMoney: function (m) </span><br></pre></td></tr></table></figure>

<p>可以看到，工资的增长增加了 <code>0.1</code></p>
<h3 id="4-6-引用对象字段"><a href="#4-6-引用对象字段" class="headerlink" title="4.6 引用对象字段"></a><strong>4.6 引用对象字段</strong></h3><p>如果您的 R6 类的属性中包含其他类的实例化对象时，该对象将在 <code>R6</code> 对象的所有实例中共享。例如</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ShareClass &lt;- R6Class(</span><br><span class="line">  &quot;ShareClass&quot;,</span><br><span class="line">  public = list(</span><br><span class="line">    num = NULL</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Common &lt;- R6Class(</span><br><span class="line">  &quot;Common&quot;,</span><br><span class="line">   public = list(</span><br><span class="line">     share = ShareClass$new()</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&gt; c1 &lt;- Common$new()</span><br><span class="line">&gt; c1$share$num &lt;- 1</span><br><span class="line"></span><br><span class="line">&gt; c2 &lt;- Common$new()</span><br><span class="line">&gt; c2$share$num &lt;- 2</span><br><span class="line"></span><br><span class="line">&gt; c1$share$num</span><br><span class="line">[1] 2</span><br></pre></td></tr></table></figure>

<p>_注意_：不能把实例化对象放在 <code>initialize</code> 方法中</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">UnCommon &lt;- R6Class(</span><br><span class="line">  &quot;Common&quot;,</span><br><span class="line">  public = list(</span><br><span class="line">    share = NULL,</span><br><span class="line">    initialize = function() &#123;</span><br><span class="line">      share &lt;&lt;- ShareClass$new()</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">n1 &lt;- UnCommon$new()</span><br><span class="line">n1$share$num &lt;- 1</span><br><span class="line"></span><br><span class="line">n2 &lt;- UnCommon$new()</span><br><span class="line">n2$share$num &lt;- 2</span><br><span class="line"></span><br><span class="line">n1$share$num</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>share</code> 属性并没有改变</p>
<h3 id="4-7-可移植和不可移植类"><a href="#4-7-可移植和不可移植类" class="headerlink" title="4.7 可移植和不可移植类"></a><strong>4.7 可移植和不可移植类</strong></h3><p><code>portable</code> 参数可以设置 <code>R6</code> 类是否为可移植类型还是不可移植类型，主要区别在于：</p>
<ul>
<li>可移植类支持跨包继承，但是不可移植类型的兼容性不好</li>
<li>可移植类使用 <code>self</code> 和 <code>private</code> 来访问成员。不可移植类直接使用属性名称来访问，如 <code>share</code>，并使用 <code>&lt;&lt;-</code> 操作符对这些成员进行赋值</li>
</ul>
<h3 id="4-8-为现有类添加成员"><a href="#4-8-为现有类添加成员" class="headerlink" title="4.8 为现有类添加成员"></a><strong>4.8 为现有类添加成员</strong></h3><p>有时候，我们需要对已经创建的类添加新的成员，可以使用 <code>$set()</code> 方法来完成。</p>
<p>例如，我们为 <code>Student</code> 类添加一个属性</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; Student$set(&quot;public&quot;, &quot;age&quot;, 21)</span><br><span class="line">&gt; sam &lt;- Student$new(&quot;sam&quot;)</span><br><span class="line">&gt; sam</span><br><span class="line">&lt;Student&gt;</span><br><span class="line">  Public:</span><br><span class="line">    age: 21</span><br><span class="line">    clone: function (deep = FALSE) </span><br><span class="line">    initialize: function (name) </span><br><span class="line">    name: sam</span><br><span class="line">    score: active binding</span><br><span class="line">  Private:</span><br><span class="line">    .score: NA</span><br></pre></td></tr></table></figure>

<p>当然也可以使用这种方式修改属性值</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; Student$set(&quot;public&quot;, &quot;age&quot;, 18, overwrite = TRUE)</span><br><span class="line">&gt; sam &lt;- Student$new(&quot;sam&quot;)</span><br><span class="line">&gt; sam</span><br><span class="line">&lt;Student&gt;</span><br><span class="line">  Public:</span><br><span class="line">    age: 18</span><br><span class="line">    clone: function (deep = FALSE) </span><br><span class="line">    initialize: function (name) </span><br><span class="line">    name: sam</span><br><span class="line">    score: active binding</span><br><span class="line">  Private:</span><br><span class="line">    .score: NA</span><br></pre></td></tr></table></figure>

<p>_注意_：我们设置了 <code>overwrite=TRUE</code></p>
<p>添加一个方法</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; Student$set(&quot;public&quot;, &quot;getName&quot;, function() self$name)</span><br><span class="line">&gt; sam &lt;- Student$new(&quot;sam&quot;)</span><br><span class="line">&gt; sam$getName()</span><br><span class="line">[1] &quot;sam&quot;</span><br></pre></td></tr></table></figure>

<h3 id="4-9-打印对象"><a href="#4-9-打印对象" class="headerlink" title="4.9 打印对象"></a><strong>4.9 打印对象</strong></h3><p><code>R6</code> 对象有一个默认的 <code>print</code> 方法，列出对象的所有成员。我们可以为类自定义一个 <code>print</code> 方法，那么它将覆盖默认的方法</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Student &lt;- R6Class(</span><br><span class="line">  &quot;Student&quot;,</span><br><span class="line">  public = list(</span><br><span class="line">    name = NA,</span><br><span class="line">    initialize = function(name) &#123;</span><br><span class="line">      self$name &lt;- name</span><br><span class="line">    &#125;,</span><br><span class="line">    print = function(...) &#123;</span><br><span class="line">      cat(&quot;class&quot;, class(self), &quot;\n&quot;)</span><br><span class="line">      cat(ls(self), sep = &#x27;,&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  ),</span><br><span class="line">  private = list(</span><br><span class="line">    .score = NA</span><br><span class="line">  ),</span><br><span class="line">  active = list(</span><br><span class="line">    score = function(s) &#123;</span><br><span class="line">      if (missing(s))</span><br><span class="line">        return(private$.score)</span><br><span class="line">      if (s &lt; 0 || s &gt; 100)</span><br><span class="line">        stop(&quot;Score incorrect!&quot;)</span><br><span class="line">      private$.score &lt;- s</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&gt; sam &lt;- Student$new(&quot;sam&quot;)</span><br><span class="line">&gt; print(sam)</span><br><span class="line">class Student R6 </span><br><span class="line">clone,initialize,name,print,score</span><br></pre></td></tr></table></figure>

<ul>
<li>END -</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>R语言</tag>
        <tag>对象系统</tag>
      </tags>
  </entry>
  <entry>
    <title>各个系统的软件安装包格式浅析</title>
    <url>/2023/12/30/%E5%90%84%E4%B8%AA%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8C%85%E6%A0%BC%E5%BC%8F%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<p>如题。</p>
<span id="more"></span>

<h2 id="一、Linux平台上的安装包格式"><a href="#一、Linux平台上的安装包格式" class="headerlink" title="一、Linux平台上的安装包格式"></a>一、Linux平台上的安装包格式</h2><p>在Linux系统之前，最为广泛使用的系统之一是贝尔实验室开发的Unix。由于当时的硬件厂商很多，不同硬件之间存在很大的不兼容性（例如CPU指令集不一样）。因此，早期的软件分发方式是源代码分发，也就是说系统内置一份代码编译器，软件开发者只需要提供 <code>.tar.gz</code> 源代码包即可，用户下载源代码包后自行编译为可执行文件。</p>
<p>这一设计也被早期的Linux所继承。Linux系统内置了<a href="https://gcc.gnu.org/"><code>gcc</code>编译器</a>，可以完成对C/C++/Fortran/Go等语言编写的软件的编译。这种做法理论上解决了软件在不同设备上的兼容性问题。然而，随着计算机技术的发展，现在的一些大型软件的代码动辄几个GB（例如chrome和firefox的源代码已经达到了几十个GB之多，<a href="https://www.zhihu.com/question/290767285/answer/1200993861">编译需要四个多小时</a>） ，如果每个软件都要本地编译显然不现实；此外，一些商业软件的源代码是闭源的，这些软件只能以二进制可执行文件的形式发布。因此，对软件进行预编译和打包显得尤为必要。</p>
<p>在Linus Benedict Torvalds于1991年发布Linux系统以后，围绕Linux系统这一内核出现了许多的Linux发行版，后者除了Linux系统以外还带有完善的软件生态和包管理器（注意，Linux内核本身是不带任何包管理器的），这些发行版中比较著名的有debian和Red Hat等，这些发行版以及他们所带的包管理器深深影响了今天的Linux生态。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231231000832.png" alt="image.png"></p>
<p>Wikipedia上有人用一张图片整理了Linux的各个发行版以及它们的上下游关系，可以点击这个<a href="https://commons.wikimedia.org/wiki/File:Linux_Distribution_Timeline.svg">链接</a>进行查看。可以看出，Linux的发行版虽然很多，但如果粗略分类的话，大致可以分出Red Hat和debian两个大阵营，而这也和它们所采用的包管理器有关。下面我们将分别介绍这些包管理器格式。</p>
<h3 id="（一）传统包管理器"><a href="#（一）传统包管理器" class="headerlink" title="（一）传统包管理器"></a>（一）传统包管理器</h3><h4 id="1、rpm格式"><a href="#1、rpm格式" class="headerlink" title="1、rpm格式"></a>1、rpm格式</h4><p>rpm格式最初的名称叫做Red Hat Package Manager（“红帽包管理器”），是Red Hat发行版默认采用的包管理器格式。Red Hat发行版由红帽公司（Red Hat）开发和维护，后者是一家提供服务器系统解决方案和运维服务的商业公司。也正因为这一点，Red Hat发行版为世界各地的许多企业、公司等广为使用。Red Hat发行版还衍生出了许多Linux发行版，例如fedoraOS和centOS，这些发行版都以rpm格式作为包管理器格式。</p>
<p>rpm格式本质上是一种压缩包，其可以包含任意一组文件。大多数RPM文件都是“二进制RPM”（binary RPMs），包含某些软件的编译版本。也有少数属于“源代码RPM”（source RPMs），包含软件的源代码，安装过程需要进行编译。RPM还包含一些额外的文件，用于对安装包完整性进行校验。</p>
<p>能够对rpm进行解包和安装的包管理器软件包括rpm、yum、dnf等。<a href="https://en.wikipedia.org/wiki/RPM_Package_Manager">rpm</a> 是最早被开发出的包管理器软件（没错，包管理器软件和安装包格式同名）。使用rpm可以直接对软件包进行操作，例如安装一个软件包可以使用<code>rpm -ivh package.rpm</code>命令，卸载软件包可以使用<code>rpm -e package</code>命令。此外，rpm还提供了查询已安装软件包、验证软件包完整性等功 能。但是，使用rpm管理软件包需要手动解决依赖关系，这可能会给用户带来不便。</p>
<p>为了解决软件包之间的依赖关系的问题，Red Hat公司推出了<a href="https://en.wikipedia.org/wiki/Yellowdog_Updater,_Modified">yum</a> 包管理器。yum全称Yellowdog Updater Modified（“Yellowdog升级器修改版”），其名称来自于<a href="https://en.wikipedia.org/wiki/Yellow_Dog_Linux">Yellow Dog Linux</a>的包管理器Yellowdog Updater。yum是基于rpm的包管理器，它解决了rpm需要手动解决依赖关系的问题。yum可以自动从指定的软件源中获取软件包及其依赖关系，并进行安装、更新和卸载等操作。yum的优点在于可以自动处理依赖关系，并且支持从多个软件源中获取软件包。此外，yum还提供了丰富的命令行选项和功能，如搜索软件包、查看软件包信息、清理缓存等。</p>
<p>dnf是Fedora、Red Hat Enterprise Linux（RHEL）和CentOS等发行版中默认的包管理器，它是yum的下一代替代品。dnf在功能和性能上进行了改进和优化，提供了更快、更稳定的软件包管理体验。与yum相比，dnf具有更快的元数据处理速度、更好的并发性能以及更简洁的命令行语法。此外，dnf还支持模块化内容、弱依赖关系处理、事务回滚等高级功能。</p>
<h4 id="2、deb格式"><a href="#2、deb格式" class="headerlink" title="2、deb格式"></a>2、deb格式</h4><p>deb是Debian软件包格式，文件扩展名为.deb，跟Debian的命名一样，deb也是因Debra Murdock（Debian创始人Ian Murdock的前妻）而得名。</p>
<p>与拥有大公司背书的Red Hat不同，Debian从诞生之初就是一个由社区维护的Linux发行版，然而这并不能阻挡debian的强大。作为最早的<a href="https://zh.wikipedia.org/wiki/Linux%E5%8F%91%E8%A1%8C%E7%89%88" title="Linux发行版">Linux发行版</a>之一，Debian在建立之初便被定位为在<a href="https://zh.wikipedia.org/wiki/GNU%E8%A8%88%E5%8A%83" title="GNU计划">GNU计划</a>的精神指导下进行公开开发并自由发布的项目。Debian以其坚守<a href="https://zh.wikipedia.org/wiki/Unix" title="Unix">Unix</a>和<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E8%BB%9F%E9%AB%94" title="自由软件">自由软件</a>的精神，以及给予用户的众多选择而闻名。在Debian系统的基础上发展出了许多著名的Linux发行版，例如Ubuntu（由英国公司Canonical开发和维护）、<a href="https://www.ubuntukylin.com/">优麒麟</a> （ubuntu中文定制版）、<a href="https://zh.wikipedia.org/wiki/Raspberry_Pi_OS">Raspberry Pi OS</a>（树莓派Linux开发板的官方系统）等。</p>
<p>和rpm格式类似，deb格式也是对软件的编译版本和源代码的打包格式。其诞生时间比rpm晚了几年，不过支持的特性也更丰富。</p>
<p>能够对deb进行解包和安装的包管理器软件包括apt-get、apt等。dpkg是deb包的解包和安装工具，类似于Red Hat系统上的rpm。apt-get这一高级包管理工具构建在dpkg的基础上，它是Debian系的诸多Linux发行版默认包管理器，提供了<a href="https://mirrors.tuna.tsinghua.edu.cn/help/debian/">自定义软件源</a>和自动处理依赖关系的功能。apt-get可以从指定的软件仓库中下载和安装软件包及其依赖项，使得软件包的管理变得更 加简单和方便。常用的apt-get命令包括 <code>apt-get install package</code> （安装软件包）和 <code>apt-get remove package</code> （卸载软件包）等。</p>
<p>apt是apt-get的下一代替代品，旨在提供更友好、更一致的命令行界面。apt与apt-get在功能上非常相似，但apt在命令语法和输出格式上进行了一些改进，使得它更加易于使用和阅读。此外，apt还支持一些 新的功能，如并行安装、进度条显示等。在最新的Debian和Ubuntu版本中，推荐使用apt来替代apt-get进行软件包管理。</p>
<p>另外，deb格式也为一些非debian系的系统所采用，例如在macOS上，<a href="https://en.wikipedia.org/wiki/Fink_(software)">flink</a> 包管理器是对apt的移植，可以安装deb格式的包。此外，安卓系统上有一款著名的Linux终端程序叫做<a href="https://wiki.termux.com/wiki/Main_Page">Termux</a> ，其自带的Linux环境也使用apt进行安装包管理。</p>
<h4 id="3、pacman格式"><a href="#3、pacman格式" class="headerlink" title="3、pacman格式"></a>3、pacman格式</h4><p>Linux发行版不止Red Hat系和Debian系。奉行简洁主义、致力于通过滚动更新来提供大多数软件的最新稳定版本的Arch Linux系统就为许多极客所喜爱，而这一系统提供的官方说明书 <a href="https://wiki.archlinux.org/">Arch Linux wiki</a> 作为一份详细的Linux学习资料，也在许多圈子中广为人知。Arch Linux采用的包管理器叫做<a href="https://wiki.archlinux.org/title/Pacman">pacman</a>，和apt/yum一样，这一包管理器可以解决安装过程中的依赖问题，自动下载并且安装所有需要的软件包，但是pacman的设计理念更简洁。</p>
<p>此外，与前面的系统不同，Arch Linux还有 <a href="https://wiki.archlinux.org/title/Arch_User_Repository">Arch User Repository（AUR）</a> 这一第三方存储库，这是一个面向Arch用户的社区驱动存储库，允许用户在此分发自己编写的软件包。</p>
<h3 id="（二）第二包管理器"><a href="#（二）第二包管理器" class="headerlink" title="（二）第二包管理器"></a>（二）第二包管理器</h3><p>前面介绍的包管理器基本上都需要root权限才能进行软件的安装和卸载，并且依赖于特定的Linux发行版。如果有一种更加通用的包管理器，使软件安装包可以一次打包、不同发行版使用，则会大大方便用户的使用。这也是下面要介绍的第二包管理器的设计灵感来源。通过这些包格式分发的任何应用程序都可以在支持这些框架的任何Linux系统上运行。</p>
<h4 id="1、flatpak格式"><a href="#1、flatpak格式" class="headerlink" title="1、flatpak格式"></a>1、flatpak格式</h4><blockquote>
<p>不依赖于特定发行版的包装格式在Linux生态系中在Flatpak前早已被提出过数次。2000年代早期，<a href="https://zh.wikipedia.org/wiki/Autopackage" title="Autopackage">autopackage</a>开始，2004年则是klik。到了2014年，klik便演化成AppImage，其目标是成为不依赖于特定散布版的<a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E6%94%9C%E5%BC%8F%E8%BB%9F%E9%AB%94" title="绿色软件">便携式</a>上游打包格式。Ubuntu母公司<a href="https://zh.wikipedia.org/wiki/Canonical%E5%85%AC%E5%8F%B8" title="Canonical公司">Canonical</a>则于2016年发布了<a href="https://zh.wikipedia.org/wiki/Snappy_(%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8)" title="Snappy (包管理器)">Snappy</a>，其目标也是为了提供广泛的linux生态系一个通用的包装格式，其支持类似于Flatpak的格式，同时也支持应用程序商店式的数字发行与更新模式。</p>
<p><a href="https://zh.wikipedia.org/zh-cn/Flatpak">https://zh.wikipedia.org/zh-cn/Flatpak</a></p>
</blockquote>
<p>Flatpak由红帽员工亚历山大·拉尔森(Alexander Larsson)开发，并于2015年正式发布。它是用C编程开发的，提供了在Linux发行版上安装应用程序的一种快速和直接的方法。</p>
<p>Flatpak的工作原理是将一个应用程序组合并编译成一个包。此前，Flatpak被称为xdg-app。这个特定的框架使用了在沙箱环境中运行应用程序而不需要根特权的概念。因此，一些flatpak应用程序不能访问和利用系统的全部资源。</p>
<p>Flatpak应用程序主要针对三种桌面环境——FreeDesktop、KDE和GNOME。不幸的是，Flatpak不支持任何后端工具，因为它只生成在Desktop环境中运行的应用程序。这是这个包管理器的一个主要缺点，因为它不支持<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>，除非用户安装像GNOME这样的桌面环境。</p>
<p>Flatpak有一个名为Flathub的在线商店，用户可以在那里找到并下载他们想要的应用程序。Flathub首次发布时，只允许开发者发布免费和开源的应用程序。然而，在更新了他们的条款和条件之后，开发人员现在甚至可以发布专有包。</p>
<h4 id="2、snap格式"><a href="#2、snap格式" class="headerlink" title="2、snap格式"></a>2、snap格式</h4><p>Flatpak背后有Red Hat公司的背书，而snap格式的背后则有Ubuntu母公司Canonical的背书。</p>
<p>Snap是由Canonical开发和维护的一个包管理器，于2014年首次发布。Snap是基于debian的发行版(比如Ubuntu)最好的备选包管理器之一。除了作为一个包存储，它还支持一个命令行界面来安装包。</p>
<p>它最初是为Ubuntu开发的，但已经很容易被其他Linux发行版采用，包括Arch、Linux Mint、CentOS、Gentoo和Fedora。这些发行版还包括对Snapcraft框架的支持。为了方便地维护包，Snap为所有Snap应用程序使用了一个中央包存储库。</p>
<p>同样的，Snap有一个在线应用商店(Snapcraft)，用户可以在那里找到并安装应用程序。这对用户来说是一个相当大的优势，因为他们有一个大的库来搜索他们需要的任何软件包。Snapcraft也由canonical维护和控制。此外，Snapcraft框架允许开发者开发他们的包，并将它们上传到Snap商店。</p>
<p>然而，在推广snap格式时，Canonical公司有些操之过急，这导致了一些批评和争议。例如，在Ubuntu 22.04版本中，Firefox浏览器和chrome浏览器的下载方式从apt被替换为了snap，而snap版的Firefox浏览器稳定性欠佳（<a href="https://www.zhihu.com/question/47659130/answer/1268946270">如何看待snap软件包？ - 刘米藕的回答 - 知乎</a>）。</p>
<p>下面这张表格比较了apt和snap两种包管理器的区别。如果更注重系统稳定性，使用<code>apt</code>可能更合适，因为它提供了经过测试和适应特定Ubuntu版本的软件包。如果需要使用最新版本的软件，或需要更大的独立性和隔离性，可以考虑使用<code>snap</code>。</p>
<table>
<thead>
<tr>
<th>特征</th>
<th>apt</th>
<th>snap</th>
</tr>
</thead>
<tbody><tr>
<td>包的来源</td>
<td>Ubuntu软件仓库</td>
<td>Snap Store（独立仓库）</td>
</tr>
<tr>
<td>版本更新</td>
<td>通常稍滞后</td>
<td>通常提供最新版本</td>
</tr>
<tr>
<td>系统资源</td>
<td>共享系统库和依赖项</td>
<td>独立于系统，自包含依赖项</td>
</tr>
<tr>
<td>独立性</td>
<td>依赖系统库</td>
<td>自包含，不依赖系统库</td>
</tr>
<tr>
<td>隔离性</td>
<td>无隔离</td>
<td>应用隔离，避免库冲突</td>
</tr>
<tr>
<td>安装命令</td>
<td>sudo apt install</td>
<td>sudo snap install</td>
</tr>
<tr>
<td>卸载命令</td>
<td>sudo apt remove</td>
<td>sudo snap remove</td>
</tr>
<tr>
<td>更新命令</td>
<td>sudo apt update</td>
<td>sudo snap refresh</td>
</tr>
</tbody></table>
<h4 id="3、AppImage格式"><a href="#3、AppImage格式" class="headerlink" title="3、AppImage格式"></a>3、AppImage格式</h4><blockquote>
<ul>
<li><a href="https://zh.wikipedia.org/zh-cn/AppImage">https://zh.wikipedia.org/zh-cn/AppImage</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1936349">https://cloud.tencent.com/developer/article/1936349</a></li>
</ul>
</blockquote>
<p>这个包格式是由Simon Peter开发的，并以Kik的名字首次发布到市场上。AppImage使用了与Java编程相同的概念——“编写一次，随处运行”或“一个应用程序，一个文件”。</p>
<p><strong>AppImage包包含应用程序本身及其运行所需的所有依赖项</strong> 。一旦下载了文件，例如balena-etcher.AppImage，就不需要安装文件。只需为它分配正确的权限，使其可执行，然后运行它。例如，运行balena-etcher.AppImage文件，可以使用下面的命令:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sudo chmod +x balena-etcher.<span class="property">AppImage</span></span><br><span class="line">./balena-etcher.<span class="property">AppImageCopy</span></span><br></pre></td></tr></table></figure>

<p>从这一点上看，AppImage更像一种可执行文件的格式而非安装包格式。</p>
<p>像Snap和Flatpak包格式一样，AppImage也有一个在线仓库来查找和下载AppImage包——<a href="https://www.appimagehub.com/">AppImage Hub</a>网站。</p>
<p>要更新AppImage包，需要在下载文件时查看提供的更新指南。也可以使用AppImage Updater或下载新版本的应用程序。AppImage支持Arch Linux、Centos、Debian、Fedora、OpenSUSE、Red Hat Linux和Ubuntu。</p>
<h4 id="4、玲珑格式"><a href="#4、玲珑格式" class="headerlink" title="4、玲珑格式"></a>4、玲珑格式</h4><p>要谈到中国人在Linux生态中的贡献，就不得不提到<a href="https://www.deepin.org/">Deepin OS</a>（“深度操作系统”）。Deepin OS由武汉深之度公司开发，是国人自主知识产权的Linux发行版，最初在ubuntu系统的基础上进行重构，使用Qt框架重写了桌面管理器，即DDE（Deepin Desktop Environment），这是一个简洁美观、相当符合国人操作习惯的桌面管理器（强推！！！）。在后来的发展中，Deepin OS的上游系统逐渐从ubuntu迁移到debian，而现在他们已经实现了从Linux 内核直接构建系统，不依赖于任何发行版。</p>
<p>Deepin OS支持deepin store、deepin Music、deepin Movie等一系列第一方应用软件。除了深度原创应用外，它还包含了大量来自开源社区的应用软件，甚至通过WINE将一些windows平台上的软件如QQ和微信移植到了Deepin OS系统上，从而满足广大用户日常的学习和工作需求。（目前QQ有了比较完善的Linux版，但微信Linux版依然只是网页版套壳，所以Deepin OS的移植工作对于广大Linux用户来说意义重大）</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/deepin.png" alt="deepin.png"></p>
<p>最初，Deepin OS也使用apt-get进行包管理功能。随着Deepin OS的发展，开发人员感到apt-get无法满足一些功能，因此随着Deepin OS V23版本的发布，<a href="https://linglong.dev/">玲珑</a> 包管理器也随之发布了。</p>
<p>根据官网的介绍，玲珑包管理器名称来源于“八宝玲珑塔，蕴含芥子乾坤般的另一个世界，状似七层实非七层，以逞道法之变化”。玲珑包管理器提升了易用性，解决 <code>deb</code>、<code>rpm</code>依赖冲突问题，同时加强安全防护，实现了应用权限管理机制，还支持应用增量更新。玲珑包管理器支持命令行调用，也支持图形界面下的安装和管理操作。</p>
<h2 id="二、Windows平台上的安装包格式"><a href="#二、Windows平台上的安装包格式" class="headerlink" title="二、Windows平台上的安装包格式"></a>二、Windows平台上的安装包格式</h2><blockquote>
<p>参考：<br><a href="https://zhuanlan.zhihu.com/p/571758477">https://zhuanlan.zhihu.com/p/571758477</a><br><a href="https://learn.microsoft.com/zh-cn/windows/uwp/packaging">https://learn.microsoft.com/zh-cn/windows/uwp/packaging</a></p>
</blockquote>
<p>Windows 主要有4种安装程序格式，分别是MSI，EXE、AppX和MSIX。</p>
<p>MSI格式是Windows最基本的安装格式。MSI是Microsoft Installer的简写, 它使用微软提供的标准安装卸载界面，本质上 MSI 就是一个数据库，包含该软件的所有必要数据。安装过程不会检测该软件是否已经存在于计算机，或者是否缺少什么必备组件，它会直接覆盖安装路径中的所有文件。这种简单粗暴的方式，非常适合无人值守的情况，驱动程序大多也是用 MSI 格式安装。</p>
<p>EXE安装程序则更普及。本质上，EXE就是一个可执行程序，大多数Windows程序都是EXE格式。因为是程序，所以能实现更多功能，比如检测已安装项，允许自定义安装路径，安装包语言，安装密码，打开网址，版权协议显示，检测安装缺失的必备运行库，以及更漂亮酷炫的安装界面等等。上述功能需要软件厂商在发布EXE安装包时自己实现，Windows只负责执行这些EXE格式的安装程序。</p>
<p>AppX 是 Windows 8 后推出的新安装格式，用于 UWP 应用的安装。它继承了 MSI 的优点，就像手机软件的安装过程一样，几乎没有给用户任何选项，它允许直接覆盖升级，完全干净的卸载。另一个重要的特点在于，Appx 程序运行在沙盒中，不能访问其他应用内存、文件，因此安全性更高。这个安装格式之所以没有火起来，估计主要是对开发者太不友好，限制了软件权限，封包AppX 格式还必须重写。此外，低版本的Windows也无法使用这一格式。</p>
<p>MISX文件格式则是AppX的后继者，其集成了Windows之前的文件格式安装技术，并继承了UWP的特性，更加安全和可靠，网络带宽优化，磁盘空间优化，程序自定义，并支持全部的Windows应用程序，而且MSIX使程序可更干净地卸载。现在的Windows应用商店提供的程序安装包都是MISX格式，此外Windows官方发布的一些应用程序也以MISX格式提供安装包。</p>
<p>MSIX安装器将支持所有的 Windows 文件格式，包括 Win32、WPF、WinForm 和 UWP。这样开发者只要遵循 MSIX 封装协议，将开发的应用程序封装为 .MSIX 格式后发布到Windows 10 应用商店，或其他网站，用户下载后就可以根据自己实际需要自行选择安装方式。另外国内很多流氓安装软件经常卸载软件后还留下文件夹和注册表。使用 MSIX 安装的程序都被放在类似「沙盒」的环境中，所有文件、注册表都按规则存放（例如 AppData 文件夹），卸载时所有数据都会被删除不会有残留。</p>
<p>能够使用的 MSIX 文件都必须要有受信任的根签名，并且上传到应用商店的软件都需要经过微软的审核。所以MSIX 格式可以给用户带来更大的安全感，但这样也可能需要签名或审核，可能需要给微软支付费用或审核，所以对于个人开发者或资金不足的软件工作室，有可能还是会选择免费的 EXE 格式，而不是马上就迁移到MSIX格式。另外 MSIX 格式甚至可以在 Windows7，Linux 等更多平台上直接运行。</p>
<h2 id="三、macOS平台上的安装包格式"><a href="#三、macOS平台上的安装包格式" class="headerlink" title="三、macOS平台上的安装包格式"></a>三、macOS平台上的安装包格式</h2><blockquote>
<p>参考： <a href="https://www.jianshu.com/p/2cc5675afb1e#">https://www.jianshu.com/p/2cc5675afb1e#</a></p>
</blockquote>
<p>主要有两种格式：PKG &amp; DMG</p>
<ul>
<li>PKG 安装包的安装类过程似 Windows 系统里的安装程序，双击之后自动运行安装向导，根据提示进行安装。    </li>
<li>DMG 安装包（实际上是一个虚拟磁盘文件），双击该文件，等待加载，然后会打开一个访达（Finder）窗口。通常里面包括该软件App本身，以及应用程序（Applications）文件夹的快捷方式。直接拖拽复制该软件App到「应用程序」文件夹即可。可近似理解为 Windows 里的绿色软件安装方式，只要复制进本地磁盘就行了。</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>AppImage</tag>
        <tag>安装包格式</tag>
        <tag>deb</tag>
        <tag>rpm</tag>
        <tag>snap</tag>
        <tag>flatpak</tag>
      </tags>
  </entry>
  <entry>
    <title>R语言dataframe和pandas的比较</title>
    <url>/2023/12/31/pandas.vs.R_dataframe/</url>
    <content><![CDATA[<p>dataframe是统计学研究中经常使用的一种数据格式，最早在R语言上实现。python作为后起之秀，通过pandas这一模块也实现了对dataframe的支持。那么，这两种不同编程语言的dataframe又有什么区别呢？二者之间能否实现数据互通呢？本文将回答这些问题。</p>
<span id="more"></span>



<h2 id="从R语言历史说起"><a href="#从R语言历史说起" class="headerlink" title="从R语言历史说起"></a>从R语言历史说起</h2><p>S语言，一种用于统计的编程语言，由贝尔实验室的约翰·钱伯斯 、瑞克·贝克尔（Rick Becker）与艾伦·威尔克斯（Allan Wilks）共同研发，在1975年至1976年间在贝尔实验室被开发出来。 </p>
<p>在那个年代，最主要的统计运算程序都是直接调用Fortran的子程序。但是S语言采用了高度互动式的方法来实现，因此极其先进，并被统计学工作者广泛采用。</p>
<p>S语言的后继者包括S-PLUS和R，然而S-PLUS是商业软件，因此流行并不广。更为人所熟知的是R语言。</p>
<p>1995年，新西兰Auckland大学的Robert Gentleman 和 Ross Ihaka（名字前缀均为R） 及其他志愿人员基于S语言的源代码开发了R语言系统。R语言增加了Scheme语言中词法作用域这一机制，使程序员得以将代码中某一对象的适用范围限制到一小段代码之中。在统计学家马丁·梅克勒的建议下，R语言成为GNU公共许可证下的一款免费开源软件。1997年4月，R综合文件网（CRAN）正式上线，其作为R语言各种软件包的仓库被广泛使用，地位相当于python的pypi。</p>
<p>因为S语言的血缘，R语言原生拥有一些适合统计学编程的面向对象数据结构，例如<code>data.frame</code> （数据框）这一数据类型。</p>
<p>原生R语言的语法依然有些晦涩，于是有能人强者开发了<a href="https://www.tidyverse.org/packages/">tidyverse</a>这一软件包集合，包括ggplot2（绘图）、dplyr（数据过滤和操作）、stringr（字符串处理）、readr（数据导入和导出）等多个著名工具包，它们“共享一个基本的设计理念、语法和数据结构”，也因此被广泛使用，现在已渐渐有了取代了R-base中一些基础函数的趋势。</p>
<p><a href="https://new.bioconductor.org/">bioconductor</a> 是一个生信领域开源软件包的分发平台，大量生物学数据的处理工具托管于此。bioconductor上的软件包大都服务于R语言，使用到了许多R的功能，bioconductor包管理器也运行在R语言上，但bioconductor与CRAN没有任何关系，前者使用<code>biocmanager::install</code> 进行包管理，后者使用 <code>install.packages()</code>进行包管理。</p>
<h2 id="R语言的dataframe"><a href="#R语言的dataframe" class="headerlink" title="R语言的dataframe"></a>R语言的dataframe</h2><p>如果是从其他编程语言转到R语言的初学者，对<a href="https://adv-r.hadley.nz/names-values.html?q=data.frame#df-modify">dataframe</a>这一数据类型会感到有些莫名其妙。它既不像python的向量和矩阵那样，可以抽象为一维和二维的数组结构，也不像C++那种支持自定义属性和方法的“对象”。然而，经过一段时间的使用，其实会发现，dataframe是一种强大的数据结构。</p>
<p>如下所示，我们使用<code>head()</code> 函数打印一个dataframe的内容，可以看出这是一种以数据库表或Excel表格形式存储数据的结构。和数组/矩阵不同，dataframe支持按列名访问数据，这很适合处理一些统计表格中的数据。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; data(iris) # 加载iris数据集</span><br><span class="line">&gt; head(iris) # 打印iris数据集的前6行内容</span><br><span class="line">  Sepal.Length Sepal.Width Petal.Length Petal.Width Species</span><br><span class="line">1          5.1         3.5          1.4         0.2  setosa</span><br><span class="line">2          4.9         3.0          1.4         0.2  setosa</span><br><span class="line">3          4.7         3.2          1.3         0.2  setosa</span><br><span class="line">4          4.6         3.1          1.5         0.2  setosa</span><br><span class="line">5          5.0         3.6          1.4         0.2  setosa</span><br><span class="line">6          5.4         3.9          1.7         0.4  setosa</span><br><span class="line">&gt; head(iris[&quot;Species&quot;]) # 访问`Species` 这一列的信息</span><br><span class="line">  Species</span><br><span class="line">1  setosa</span><br><span class="line">2  setosa</span><br><span class="line">3  setosa</span><br><span class="line">4  setosa</span><br><span class="line">5  setosa</span><br><span class="line">6  setosa</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>dataframe也支持按行号或列号进行索引。如下代码是两个例子，分别访问数据框的第一个元素和打印一定范围内的元素。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; iris[1,1]</span><br><span class="line">[1] 5.1</span><br><span class="line">&gt; iris[1:3,1:5]</span><br><span class="line">  Sepal.Length Sepal.Width Petal.Length Petal.Width Species</span><br><span class="line">1          5.1         3.5          1.4         0.2  setosa</span><br><span class="line">2          4.9         3.0          1.4         0.2  setosa</span><br><span class="line">3          4.7         3.2          1.3         0.2  setosa</span><br></pre></td></tr></table></figure>

<p>与dataframe相辅相成的还有R语言内置的<a href="https://adv-r.hadley.nz/subsetting.html?q=apply#subset-multiple">apply</a>函数，它可以对dataframe进行高效的行操作和列操作。R语言还有一系列<code>read</code>和<code>write</code>函数，如<code>read.csv</code>和<code>write.csv</code>，支持从表格文件中导入数据，或者导出数据到表格文件当中。</p>
<h2 id="Python对dataframe格式的支持"><a href="#Python对dataframe格式的支持" class="headerlink" title="Python对dataframe格式的支持"></a>Python对dataframe格式的支持</h2><p>目前我们已经知道，Python的<a href="https://pandas.pydata.org/">Pandas</a>包也支持dataframe格式，二者在某些细节方面有区别，但设计思路大体上相同。或者说，pandas从一开始就是Python社区为了对标R语言的dataframe而写出来的模块。从R markdown核心开发人员、R语言大佬谢益辉的博客中可以看出这一点：</p>
<blockquote>
<p>上回是讲 R 的各种怪癖，经过这五个月，我觉得 Python 有一统江湖的野心。过去我们总说统计是 R 的强项，别的语言要重写 R 的四千个包根本不可能，看 pandas 费了多大劲才实现 R/S 几十年前就实现的数据框结构，蟒蛇社区要重写个 ggplot2 有希望吗？多数人可能不会选择重造轮子，可是我渐渐发现蟒蛇社区真的是鸡血太充足了，真有人愿意把统计的东西一项一项重写出来。上次我在微博上说有人用 IPython notebook 展示了线性模型的设计阵，便是一个一统统计江湖的象征，现在又有人开始用 IPython 写贝叶斯 / MCMC 的书。小众的 R 社区，会不会被蟒蛇吞掉呢？</p>
<p>——《千年等一回》谢益辉 2013-02-27</p>
</blockquote>
<p>pandas实现了dataframe的各种操作，包括按列的数据选择器、数据选取和修改、从文件读取数据、导出数据到文件等功能。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231231153148.png" alt="image.png"></p>
<p>如上图，pandas的官方文档甚至贴心的给出了pandas与其他工具的比较，以方便大家从其他工具迁移到pandas。</p>
<h2 id="pandas-vs-R-dataframe"><a href="#pandas-vs-R-dataframe" class="headerlink" title="pandas vs R dataframe"></a>pandas vs R dataframe</h2><p>终于到了重点，pandas和R dataframe这两个工具的区别是什么呢？</p>
<p>下面这一段的内容主要参考<a href="https://pandas.pydata.org/docs/getting_started/comparison/comparison_with_r.html#base-r">pandas官方文档</a> 。表格里面列出了dataframe的常见操作在两个工具中的区别：</p>
<h4 id="1-查询、过滤和抽样"><a href="#1-查询、过滤和抽样" class="headerlink" title="1. 查询、过滤和抽样"></a>1. 查询、过滤和抽样</h4><table>
<thead>
<tr>
<th>R</th>
<th>pandas</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>dim(df)</code></td>
<td><code>df.shape</code></td>
<td>输出dataframe的数据维度</td>
</tr>
<tr>
<td><code>head(df)</code></td>
<td><code>df.head()</code></td>
<td>输出dataframe前几行数据</td>
</tr>
<tr>
<td><code>slice(df, 1:10)</code></td>
<td><code>df.iloc[:9]</code></td>
<td>按行号或列号索引对数据进行切片。在R中，这一功能需要<code>dplyr</code>包的支持</td>
</tr>
<tr>
<td><code>filter(df, col1 == 1, col2 == 1)</code></td>
<td><code>df.query(&#39;col1 == 1 &amp; col2 == 1&#39;)</code></td>
<td>按条件进行过滤。在R中，这一功能需要<code>dplyr</code>包的支持</td>
</tr>
<tr>
<td><code>df[df$col1 == 1 &amp; df$col2 == 1,]</code></td>
<td><code>df[(df.col1 == 1) &amp; (df.col2 == 1)]</code></td>
<td>按条件进行过滤</td>
</tr>
<tr>
<td><code>select(df, col1, col2)</code></td>
<td><code>df[[&#39;col1&#39;, &#39;col2&#39;]]</code></td>
<td>按列名进行数据选取。在R中，这一功能需要<code>dplyr</code>包的支持</td>
</tr>
<tr>
<td><code>select(df, col1:col3)</code></td>
<td><code>df.loc[:, &#39;col1&#39;:&#39;col3&#39;]</code></td>
<td>按列名进行数据选取（选择多个列）。在R中，这一功能需要<code>dplyr</code>包的支持</td>
</tr>
<tr>
<td><code>select(df, -(col1:col3))</code></td>
<td><code>df.drop(cols_to_drop, axis=1)</code></td>
<td>按列名进行数据过滤（排除掉指定列）。在R中，这一功能需要<code>dplyr</code>包的支持。在pandas中，需要额外的代码提取出所有要排除的列</td>
</tr>
<tr>
<td><code>distinct(select(df, col1))</code></td>
<td><code>df[[&#39;col1&#39;]].drop_duplicates()</code></td>
<td>选择一列中不同的数据</td>
</tr>
<tr>
<td><code>distinct(select(df, col1, col2))</code></td>
<td><code>df[[&#39;col1&#39;, &#39;col2&#39;]].drop_duplicates()</code></td>
<td>选择两列中不同的数据</td>
</tr>
<tr>
<td><code>sample_n(df, 10)</code></td>
<td><code>df.sample(n=10)</code></td>
<td>按数量抽样</td>
</tr>
<tr>
<td><code>sample_frac(df, 0.01)</code></td>
<td><code>df.sample(frac=0.01)</code></td>
<td>按比例抽样</td>
</tr>
</tbody></table>
<h4 id="2-排序"><a href="#2-排序" class="headerlink" title="2. 排序"></a>2. 排序</h4><table>
<thead>
<tr>
<th>R</th>
<th>pandas</th>
</tr>
</thead>
<tbody><tr>
<td><code>arrange(df, col1, col2)</code></td>
<td><code>df.sort_values([&#39;col1&#39;, &#39;col2&#39;])</code></td>
</tr>
<tr>
<td><code>arrange(df, desc(col1))</code></td>
<td><code>df.sort_values(&#39;col1&#39;, ascending=False)</code></td>
</tr>
</tbody></table>
<h4 id="3-变换"><a href="#3-变换" class="headerlink" title="3. 变换"></a>3. 变换</h4><table>
<thead>
<tr>
<th>R</th>
<th>pandas</th>
</tr>
</thead>
<tbody><tr>
<td><code>select(df, col_one = col1)</code></td>
<td><code>df.rename(columns=&#123;&#39;col1&#39;: &#39;col_one&#39;&#125;)[&#39;col_one&#39;]</code></td>
</tr>
<tr>
<td><code>rename(df, col_one = col1)</code></td>
<td><code>df.rename(columns=&#123;&#39;col1&#39;: &#39;col_one&#39;&#125;)</code></td>
</tr>
<tr>
<td><code>mutate(df, c=a-b)</code></td>
<td><code>df.assign(c=df[&#39;a&#39;]-df[&#39;b&#39;])</code></td>
</tr>
</tbody></table>
<h4 id="4-分组与总结"><a href="#4-分组与总结" class="headerlink" title="4. 分组与总结"></a>4. 分组与总结</h4><table>
<thead>
<tr>
<th>R</th>
<th>pandas</th>
</tr>
</thead>
<tbody><tr>
<td><code>summary(df)</code></td>
<td><code>df.describe()</code></td>
</tr>
<tr>
<td><code>gdf &lt;- group_by(df, col1)</code></td>
<td><code>gdf = df.groupby(&#39;col1&#39;)</code></td>
</tr>
<tr>
<td><code>summarise(gdf, avg=mean(col1, na.rm=TRUE))</code></td>
<td><code>df.groupby(&#39;col1&#39;).agg(&#123;&#39;col1&#39;: &#39;mean&#39;&#125;)</code></td>
</tr>
<tr>
<td><code>summarise(gdf, total=sum(col1))</code></td>
<td><code>df.groupby(&#39;col1&#39;).sum()</code></td>
</tr>
</tbody></table>
<p>由于R语言对象系统的特点，上述比较中用到的R语言的函数如<code>select(),mutate(),summary()</code> 等都可以直接调用；但在python中，这些函数属于pandas对象的方法，因此需要用“对象名+方法名”的方法来调用（例如 <code>df.head()</code> 就是调用<code>df</code>这一pandas对象的<code>head()</code>方法。但总体上看，两种语言实现的dataframe操作在很多地方都是一致的。</p>
<h3 id="R-dataframe和pandas-dataframe的相互转换"><a href="#R-dataframe和pandas-dataframe的相互转换" class="headerlink" title="R dataframe和pandas dataframe的相互转换"></a>R dataframe和pandas dataframe的相互转换</h3><p>有些时候我们可能有跨编程语言操作的需要，例如在R语言中使用某个bioconductor上的包进行数据预处理，随后用python上的某些工具进行建模和可视化。因此，将dataframe对象在两种语言之间相互转换也是有必要的。</p>
<p>最简单粗暴的转换方法是以文本文件（.csv或.txt）为中介的。具体方法如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>R</th>
<th>pandas</th>
</tr>
</thead>
<tbody><tr>
<td>导出到文本文件</td>
<td><code>write.table()</code>或<code>write.csv()</code></td>
<td><code>pandas.to_table()</code>或<code>pandas.to_csv()</code></td>
</tr>
<tr>
<td>从文本文件导入</td>
<td><code>read.table()</code>或<code>read.csv()</code></td>
<td><code>pandas.read_table()</code>或<code>pandas.read_csv()</code></td>
</tr>
</tbody></table>
<p>但是，当数据量过大时，这样的导入导出操作极其耗时，且会产生巨大的文本文件。如果能以一些中间格式（如<code>.RData</code>）为媒介进行数据交换，则会更方便一点。</p>
<p><code>.RData</code>文件是R语言的<a href="https://zh.wikipedia.org/zh-cn/%E5%BA%8F%E5%88%97%E5%8C%96">序列化文件格式</a>。所谓序列化 (Serialization)就是将对象的状态信息转换为可以存储或传输的形式的过程，譬如说将一个dataframe的二进制数据流直接存储到文件当中（而不是转换为csv这种文本文件）。R语言提供了<code>save()</code>和<code>save.image()</code>两个函数用于将数据对象存储到 <code>.RData</code>文件，提供了<code>load()</code>函数用于从 <code>.RData</code>文件中读取对象。使用<code>.RData</code>文件存储速度更快，且更节省空间。</p>
<p>那么python有没有可能去读取一个R语言的<code>.RData</code>文件呢？答案是可以的。有一个python模块叫做rpy2，可以实现python中对R的调用，以及二者之间的数据结构互转。使用<code>pip install rpy2</code>指令即可进行安装</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/85025665">“攻略” : “R 语言格式数据导入python进行分析” - Psion03的文章 - 知乎</a></p>
</blockquote>
<p>关于R dataframe转pandas dataframe，可以参考下面的文档说明</p>
<blockquote>
<p><a href="https://rpy2.github.io/doc/v3.5.x/html/generated_rst/pandas.html#from-r-to-pandas">https://rpy2.github.io/doc/v3.5.x/html/generated_rst/pandas.html#from-r-to-pandas</a></p>
</blockquote>
<p>以一个实例来说明。我们将R语言的示例数据集<code>iris</code>导入到<code>.RData</code>里面，随后再用python读取这个数据集。首先，使用下面的代码导出<code>iris</code>：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">data<span class="punctuation">(</span>iris<span class="punctuation">)</span></span><br><span class="line">save<span class="punctuation">(</span>iris<span class="punctuation">,</span>file<span class="operator">=</span><span class="string">&quot;iris.RData&quot;</span><span class="punctuation">)</span> <span class="comment"># 现在iris.RData文件里面是iris这个数据框</span></span><br></pre></td></tr></table></figure>

<p>然后在同一文件夹下，使用下面的python代码导入<code>iris</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&quot;R_HOME&quot;</span>]=<span class="string">&#x27;D:\\R\\R-4.3.1&#x27;</span> <span class="comment"># 此处把路径设置为你的电脑上的R可执行文件的位置</span></span><br><span class="line"><span class="comment"># R_HOME环境变量必须设置一下，否则下一行 `import rpy2` 会出错</span></span><br><span class="line"><span class="comment"># 下面导入一些必须的rpy2模块</span></span><br><span class="line"><span class="keyword">import</span> rpy2.robjects <span class="keyword">as</span> ro</span><br><span class="line"><span class="keyword">from</span> rpy2.robjects.packages <span class="keyword">import</span> importr</span><br><span class="line"><span class="keyword">from</span> rpy2.robjects <span class="keyword">import</span> pandas2ri</span><br><span class="line"><span class="comment"># import R&#x27;s &quot;base&quot; package</span></span><br><span class="line">base = importr(<span class="string">&#x27;base&#x27;</span>)</span><br><span class="line"><span class="comment"># import R&#x27;s &quot;utils&quot; package</span></span><br><span class="line">utils = importr(<span class="string">&#x27;utils&#x27;</span>)</span><br><span class="line"><span class="comment"># 这里我们尝试将 `matrix1` 的四个dataframe导入进来</span></span><br><span class="line"><span class="comment"># 修正：只能导入一个dataframe。另外几个dataframe之后慢慢处理。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面定义Rcode。rpy2需要调用R解释器，运行这些Rcode完成一些操作。</span></span><br><span class="line">rcodes = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">load(&quot;iris.RData&quot;) #读取前面保存的RData文件</span></span><br><span class="line"><span class="string">return(iris) #将iris这个数据框作为Rcode运行的返回值</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行R code，读取并导出iris</span></span><br><span class="line">iris=ro.r(rcodes.strip())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时的iris虽然导入到python中了，然而对象类型依然是R/rpy2 DataFrame，无法直接操作。</span></span><br><span class="line"><span class="comment"># 需要下面的代码将其转变为可操作的pandas数据框对象。</span></span><br><span class="line"><span class="comment"># 将R dataframe转码为pandas dataframe</span></span><br><span class="line"><span class="keyword">with</span> (ro.default_converter + pandas2ri.converter).context():</span><br><span class="line">  iris_df = ro.conversion.get_conversion().rpy2py(iris)</span><br><span class="line">iris_df <span class="comment"># 打印一下看看</span></span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20231231164453.png" alt="image.png"></p>
<p>如图，通过我们的一番操作，成功实现了将R语言的dataframe导入python中的操作。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>python</tag>
        <tag>R</tag>
        <tag>dataframe</tag>
        <tag>rpy2</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】搜索引擎高级搜索指令大全</title>
    <url>/2024/01/07/WebsiteSearchCommand/</url>
    <content><![CDATA[<p>一些搜索指令。</p>
<span id="more"></span>

<blockquote>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/647126521">《搜索引擎高级搜索指令大全》 - 知乎用户8zytQB的文章 - 知乎 </a></p>
<p>本文中的部分搜索指令并未经过实际验证，请谨慎使用。</p>
</blockquote>
<p>高级搜索–网页标题通常是对网页内容提纲挈领式的归纳。把查询内容范围限定在网页标题中，有时能获得良好的效果。使用的方式，是把查询内容中，特别关键的部分，用 “<code>&lt;标识符&gt;:</code>” 连起来。</p>
<h2 id="site"><a href="#site" class="headerlink" title="site:"></a>site:</h2><p>site: 是 SEO 最熟悉、最实用的高级搜索指令（例如：<code>site:www.qoot.cool</code>），用来搜索某个域名下的所有被搜索引擎收录的页面，适用于所有的搜索引擎。</p>
<p>另外，site 命令还可以限制在某一网站内搜索，site 语法把搜索范围局限在这些网站内，以提高搜索效率。</p>
<p>例：下面这个搜索指令可以搜索菜鸟教程网站上与python有关的所有网页</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">python site:runoob.com</span><br></pre></td></tr></table></figure>


<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20240107161655.png" alt="image.png"></p>
<h2 id="domain"><a href="#domain" class="headerlink" title="domain:"></a>domain:</h2><p>用 domain 命令可以查找跟某一网站相关的信息或反向链接，目前此指令只适用于百度，例如：在百度上提交搜索 “<code>domain:www.qoot.cool</code>”， 所搜索的结果就的关于 <a href="http://www.qoot.cool/">www.qoot.cool</a> 网站的反向链接。</p>
<h2 id="link"><a href="#link" class="headerlink" title="link:"></a>link:</h2><p>查询网站外链的搜索指令（例如：<code>link:www.qoot.cool</code>） ，此搜索指令只适用于 Google，在百度上是不起作用的。</p>
<h2 id="linkdomain"><a href="#linkdomain" class="headerlink" title="linkdomain:"></a>linkdomain:</h2><p>linkdomain: 指令只适用于雅虎，返回的是某个域名的反向链接，雅虎的反向链接数据还比较准确，是 SEO 人员研究竞争对手外部链接情况的重要工具之一。</p>
<p>比如搜索 <code>linkdomain:www.qoot.cool-site:www.qoot.cool</code> 得到的就是 库特博客 的外部链接，因为 <code>-site:www.qoot.cool</code> 已经排除了本身的页面，也就是内部链接，剩下的就都是外部链接了。</p>
<h2 id="inurl"><a href="#inurl" class="headerlink" title="inurl:"></a>inurl:</h2><p>URL 全称 Uniform Resource Locator，中文译为 “统一资源定位器”，就是地址栏里的内容。</p>
<p>inurl指令用于搜索查询词出现在 url 中的页面，百度和 Google 都支持 inurl 指令，inurl 指令支持中文和英文。</p>
<p>inurl使用格式是一般有 3 种形式：“inurl:xxx”、“inurl:xxx 关键词” 和 “关键词 inurl:xxx”。</p>
<ul>
<li>inurl:xxx 的作用是命令搜索引擎查找 url 中包含 xxx 的网页，例如：inurl: qoot</li>
<li>“inurl:xxx 关键词” 或 “关键词 inurl:xxx” 两者意义一样，都是要求搜索引擎查找的结果满足 url 中包括 xxx 和网页中含有 “关键词” 的两个要求。</li>
</ul>
<p>例子：<code>PHP inurl:www.qoot.cool</code> ，即表示网页正文包含 “PHP”，url 中有 “<a href="http://www.qoot.cool”./">www.qoot.cool”。</a></p>
<p>通常情况，任何网站的 url 都不是随意设置的，都经过一番过虑，有一定用意的，很多地方，url 链接和网页的内容有着密切的相关，所以，可以利用这种相关性，来缩小范围，快速准确地找到所需信息。</p>
<p>比如搜索：inurl:库特博客，返回的结果都是网址 url 中包含 “库特博客” 的页面。</p>
<p>由于关键词出现在 url 中对排名有一定影响，使用 inurl: 搜索可以更准确地找到竞争对手。</p>
<p>例：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">inurl:python</span><br></pre></td></tr></table></figure>


<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20240107162156.png" alt="image.png"></p>
<h2 id="and"><a href="#and" class="headerlink" title="and"></a>and</h2><p>利用 and 表示前后两个关键词是 “与” 的逻辑关系，例如输入关键词：““库特 and 库特博客””，就会找出将包含 “库特” 和 “库特博客” 有关的网站。</p>
<h2 id="or"><a href="#or" class="headerlink" title="or"></a>or</h2><p>利用 or (|) 表示前后两个词是 “或” 的逻辑关系，例如输入关键词：““库特 or 库特博客””，会找出将包含 “库特” 或者 “库特博客” 的网页。</p>
<h2 id="“-”-语法"><a href="#“-”-语法" class="headerlink" title="“|” 语法"></a>“|” 语法</h2><p>使用 “A|B” 来搜索 “或者包含词语 A，或者包含词语 B” 的网页。</p>
<p>例如：您要查询 “库特” 或 “库特博客” 相关资料，无须分两次查询，只要输入 ““库特 | 库特博客”” 搜索即可，百度会提供跟 “|” 前后任何字词相关的资料，并把最相关的网页排在前列。</p>
<h2 id="双引号（””）"><a href="#双引号（””）" class="headerlink" title="双引号（””）"></a>双引号（””）</h2><p>把搜索词放在双引号中（英文半角双引号），代表完全匹配搜索一个词，也就是说搜索结果返回的页面包含双引号中出现的所有的词，连顺序也必须完全匹配，目前，百度和 Google 都支持这个指令，例如：搜索 “库特博客”。</p>
<h2 id="减号（-）"><a href="#减号（-）" class="headerlink" title="减号（-）"></a>减号（-）</h2><p>减号代表搜索不包含减号后面的词的页面，使用这个指令时减号前面必须是空格，减号后面没有空格，紧跟着需要排除的词。</p>
<p>目前，Google 和百度都支持这个指令，例如：“库特 – 资源” 返回的则是包含 “库特” 这个词，却不包含 “资源” 这个词的结果。</p>
<h2 id="星号（-）"><a href="#星号（-）" class="headerlink" title="星号（*）"></a>星号（<code>*</code>）</h2><p>星号是常用的通配符，也可以用在搜索中，目前，百度不支持号搜索指令。</p>
<p>比如在 Google 中搜索：“搜索 * 擎” 其中的 * 号代表任何文字，返回的结果就不仅包含 “搜索引擎”，还包含了 “搜索收擎”，“搜索巨擎” 等内容。</p>
<h2 id="小括号"><a href="#小括号" class="headerlink" title="小括号"></a>小括号</h2><p>利用 () 可以把多个关键词划分为一组，并进行优先查询，例如：键入 “(库特 + 库特博客)” 来搜索包含 “库特” 与 “库特博客” 的信息。</p>
<h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><p>在百度查询时，就算我们使用符号 “AND” 或 “+”，只要我们在每个关键词之间打上空格，百度会在多个以空格隔开的词语之间自动添加 “+”，提供符合您全部查询条件的资料，并把最相关的网页排在前列。</p>
<h2 id="index-命令"><a href="#index-命令" class="headerlink" title="index 命令"></a>index 命令</h2><p>在关键词输入框中输入 “index of mp4”，选择回车搜索，得到了一些网页，不要以为这是一些普通的页面，其实它们是一些 mp4 网站的资源列表，点击打开它来看看，怎么样？是不是所有资源一收眼底了？</p>
<h2 id="intitle"><a href="#intitle" class="headerlink" title="intitle:"></a>intitle:</h2><p>intitle: 指令返回的是页面 title 中包含关键词的页面，目前，百度和 Google 都支持 intitle 指令。</p>
<p>使用 intitle 指令找到的文件是更准确的竞争页面，如果关键词只出现在页面可见文字中，而没有出现在 title 中，大部分情况是并没有针对关键词进行优化，所以也不是有力的竞争对手。</p>
<p>Intitle 命令 – 表示后接的词限制在网页标题范围内</p>
<p>例如，找明星的个人资料页，一般来说，明星资料页的标题，通常是明星的名字，而在页面上，会有 “姓名”、“身高” 等词语出现。</p>
<p>比如：找陌小离的个人资料，就可以用 “陌小离 姓名 身高” 来查询，而由于明星的名字一般在网页标题中出现，因此，更精确的查询方式，可以是 “姓名 身高 intitle: 库特”。</p>
<h2 id="info"><a href="#info" class="headerlink" title="info:"></a>info:</h2><p>提交 <code>info:url</code> ，将会显示需要查询网站的一些信息。</p>
<h2 id="inanchor"><a href="#inanchor" class="headerlink" title="inanchor:"></a>inanchor:</h2><p>inanchor: 指令返回的结果是导入链接锚文字中包含搜索词的页面，目前，百度暂不支持 inanchor。</p>
<p>当我们用 inanchor 提交查询的时候，Google 会限制结果是那些在网页 anchor 链接里边包含了查询关键词的网页。</p>
<p>比如在 Google 搜索：“<code>inanchor: 点击这里</code>” 返回的结果页面本身并不一定包含 “点击这里” 这四个字，而是指向这些页面的链接锚文字中出现了 “点击这里” 这四个字。</p>
<p>例如：“<code>restaurants inanchor:gourmet</code>”，提交这个查询，Google 会查询那些在 anchor 信息里包含了关键词 “restaurants” 和关键词 “gourmet” 的网页。</p>
<p>此种指令可以用来找到某个关键词的竞争对手，而且这些竞争对手往往是做过 SEO 的，研究竞争对手页面有哪些外部链接，就可以找到很多链接资源。</p>
<h2 id="filetype"><a href="#filetype" class="headerlink" title="filetype:"></a>filetype:</h2><p>filetype 命令对搜索对象的文件类型做限制，冒号后是文档格式，如 PDF、DOC、XLS 等。</p>
<p>当我们在查询里边包含 filetype: 扩展名的时候，Google 会限制查询结果仅返回特定文件类型的网页。</p>
<p>用于搜索特定文件格式，目前，Google 和百度都支持 filetype 指令，比如搜索：“年终总结 filetype:ppt”，搜索返回的就是包含 “年终总结” 这个关键词的所有 ppt 文件，其它可用的特定文件类型格式查询还有 doc、txt、ppt、xls、rtf、swf、ps 等。</p>
<h2 id="allinanchor"><a href="#allinanchor" class="headerlink" title="allinanchor:"></a>allinanchor:</h2><p>anchor 是一处说明性的文字，它标注说明了这个链接可能跳转到其它的网页或跳转到当前网页的不同地方，当我们用 allinanchor 提交查询的时候，Google 会限制搜索结果必须是那些在 anchor 文字里包含了我们所有查询关键词的网页。</p>
<p>例如：“allinanchor: best museums Sydney”，提交这个查询，Google 仅仅会返回在网页 anchor 说明文字里边包含了关键词 “best”“museums” 和 “Sydney” 的网面。</p>
<h2 id="allintext"><a href="#allintext" class="headerlink" title="allintext:"></a>allintext:</h2><p>当我们用 allintext 提交查询的时候，Google 会限制搜索结果仅仅是在网页正文里边包含了我们所有查询关键词的网页。</p>
<p>例如：“allintext: travel packing list”，提交这个查询，Google 仅仅会返回在一个网页包含了三个关键词 “travel”“packing” 和 “list” 的网页。</p>
<h2 id="allintitle"><a href="#allintitle" class="headerlink" title="allintitle:"></a>allintitle:</h2><p>allintitle: 搜索返回的是页面标题中包含多组关键词的文件，当我们用 allintitle 提交查询的时候，Google 会限制搜索结果仅是那些在网页标题里边包含了我们所有查询关键词的网页。</p>
<p>例如：“<code>allintitle: detect plagiarism</code>”，提交这个查询，Google 仅会返回在网页标题里边包含了 “detect” 和 “plagiarism” 这两个关键词的网页。</p>
<p>而 intitle:SEO intitle: 搜索引擎优化返回的是标题中中既包含 “SEO”，也包含 “搜索引擎优化” 的页面。</p>
<h2 id="allinurl"><a href="#allinurl" class="headerlink" title="allinurl:"></a>allinurl:</h2><p>与 allintitle: 类似，allinurl:SEO 搜索引擎优化就相当于：inurl:SEO inurl: 搜索引擎优化。</p>
<p>当我们用 allinurl 提交查询的时候，Google 会限制搜索结果仅是那些在 URL（网址）里边包含了我们所有查询关键词的网页。</p>
<p>例如：“<code>allinurl: qoot php</code>”，提交这个查询，Google 仅会返回在 URL 里边包含了关键词 “qoot” 和 “php” 的网页，像 <a href="http://www.qoot.cool/sort/php/">www.qoot.cool/sort/php/</a> 等的网页。</p>
<h2 id="author"><a href="#author" class="headerlink" title="author:"></a>author:</h2><p>当我们用 author 进行查询的时候，Google 会限制返回 <a href="https://link.zhihu.com/?target=http://www.qoot.cool/">http://www.qoot.cool/</a> 结果仅仅是那些在 Google 论坛里边，包含了特定作者的新闻文章，在这里，作者名可以是全名，也可以是一部分或邮件地址。</p>
<p>例如：“php author: 库特 author:slinbo” 或 “php author:<a href="mailto:&#x61;&#x64;&#x6d;&#x69;&#110;&#64;&#x71;&#111;&#x6f;&#x74;&#46;&#99;&#111;&#111;&#x6c;">&#x61;&#x64;&#x6d;&#x69;&#110;&#64;&#x71;&#111;&#x6f;&#x74;&#46;&#99;&#111;&#111;&#x6c;</a>” 返回结果将是作者库特 <a href="http://www.qoot.cool/">www.qoot.cool</a> 或是 <a href="mailto:&#x61;&#100;&#x6d;&#x69;&#110;&#64;&#119;&#x77;&#119;&#x2e;&#113;&#111;&#111;&#x74;&#46;&#99;&#x6f;&#x6f;&#108;">&#x61;&#100;&#x6d;&#x69;&#110;&#64;&#119;&#x77;&#119;&#x2e;&#113;&#111;&#111;&#x74;&#46;&#99;&#x6f;&#x6f;&#108;</a> 写的，关于包含关键词 php 的文章。</p>
<h2 id="bphonebook"><a href="#bphonebook" class="headerlink" title="bphonebook:"></a>bphonebook:</h2><p>用 bphonebook 进行查询的时候，返回结果将是那些商务电话资料。</p>
<h2 id="cache"><a href="#cache" class="headerlink" title="cache:"></a>cache:</h2><p>提交 cache:url，Google 会显示当前网页的快照信息，从而替换网页的当前信息。</p>
<p>例如：“<code>cache:www.qoot.cool</code>”，提交这个查询，Google 会返回所有抓取的关于 [<a href="http://www.qoot.cool]">www.qoot.cool]</a> 的网页快照信息，在显示的网页快照信息里边，Google 会高亮显示查询关键词（在 cache: 和 URL 之间不能有空格）。</p>
<h2 id="datarange"><a href="#datarange" class="headerlink" title="datarange:"></a>datarange:</h2><p>当我们使用 datarange 进行查询的时候，Google 会将查询结果限制在一个特定的时间段内，这个时间相对于网站来说，是按网站被 google 收录的时间算的。</p>
<p>例如：“Geri Halliwell” “Spice Girls” daterange:2450958-2450968，这里的时间日期格式是按天文学的儒略日（这个搜索语法 Google 并不推荐使用，因为它会返回一些莫名其妙的东西）。</p>
<h2 id="define"><a href="#define" class="headerlink" title="define:"></a>define:</h2><p>当我们用 define 进行查询的时候，Google 会返回包含查询关键词定义的网面。</p>
<p>例如：“define: blog”，这个查询将会返回 Blog 的定义。</p>
<h2 id="group"><a href="#group" class="headerlink" title="group:"></a>group:</h2><p>当我们用 group 查询的时候，Google 会限制我们的论坛查询结果仅是某几个固定的论坛组或是某些特定主题组的新闻文章。</p>
<p>例如：“<code>sleep group:qoot.cool</code>”，提交这个查询，Google 仅会返回在用户组 qoot.cool 里边包含了查询关键字 “sleep” 的文章。</p>
<h2 id="related"><a href="#related" class="headerlink" title="related:"></a>related:</h2><p>related: 指令只适用于 Google，返回的结果是与某个网站有关联的页面。</p>
<p>比如搜索 <code>related:www.qoot.cool</code> 我们就可以得到 Google 所认为的与 <a href="http://www.qoot.cool/">www.qoot.cool</a> 有关联的其他页面。</p>
<p>这种关联到底指的是什么，Google 并没有明确说明，一般认为指的是有共同外部链接的网站。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>搜索引擎高级指令</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的pypy解释器是什么</title>
    <url>/2024/01/06/pypyInterpreter/</url>
    <content><![CDATA[<p>本文对pypy解释器进行了一些介绍</p>
<span id="more"></span>

<h2 id="一、从编程语言的自举说起"><a href="#一、从编程语言的自举说起" class="headerlink" title="一、从编程语言的自举说起"></a>一、从编程语言的自举说起</h2><p>自举（bootstrapping）字面理解就是自己能把自己给举起来，换做编程语言来讲就是，自己编译自己。</p>
<p>例如，在只有汇编的年代，自举一款Basic语言编译器的步骤大概如下（举例，不代表真实历史）：</p>
<ul>
<li>用汇编把第一个Basic编译器写出来，我们叫做编译器A</li>
<li>编译器A可用编译Basic语言，但其本身不是Basic写的，所以此时Basic语言还没有实现自举</li>
<li>用Basic语言写出第二版编译器，我们叫做编译器B。用编译器A编译编译器B的源代码</li>
<li>对编译器B进行修改和测试，此时的编译过程都用编译器B进行。如此反复多次直到所有测试用例都通过为止，以保证编译器B的源代码没有bug</li>
<li>最终得到的编译器B是Basic实现的，如果这个编译器未来有更新，也是用Basic实现，如此我们说这个语言完成了自举。</li>
</ul>
<p>许多编译型的编程语言都实现了自举，例如Basic、C、C++、Go等。仍有很多语言无法实现自举，这些语言以解释型语言为主，例如R和python（如果不算pypy这个解释器的话）。R语言的解释器是C语言实现的，python的主流解释器Cpython也是如此（强调“主流”是因为python语言有好几种不同实现的解释器，除了Cpython之外还有<a href="https://ironpython.net/">IronPython</a>、<a href="https://www.jython.org/">Jython</a>、<a href="https://cython.org/">cython</a>、<a href="https://www.pypy.org/">pypy</a>等，由于python严格意义上不算一种能够自举的语言，这些解释器可以理解为用不同语言开发的解释器）</p>
<p>python不能自举，但pypy有点自举的雏形，因为这个解释器是python语言实现的。</p>
<h2 id="二、编程语言类型划分"><a href="#二、编程语言类型划分" class="headerlink" title="二、编程语言类型划分"></a>二、编程语言类型划分</h2><blockquote>
<p>参考： <a href="https://zhuanlan.zhihu.com/p/435652722">pypy真的能让python比c还快？ - 肖恩的文章 - 知乎</a></p>
</blockquote>
<h3 id="（一）静态语言-vs-动态语言"><a href="#（一）静态语言-vs-动态语言" class="headerlink" title="（一）静态语言 vs 动态语言"></a>（一）静态语言 vs 动态语言</h3><p>如果在编译时知道变量的类型，则该语言为静态类型。静态类型语言的常见示例包括Java，C，C ++，FORTRAN，Pascal和Scala。在静态类型语言中，一旦使用类型声明了变量，就无法将其分配给其他不同类型的变量，这样做会在编译时引发类型错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># java</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line">data = <span class="number">50</span>;</span><br><span class="line">data = “Hello Game_404!”; <span class="comment">// causes an compilation error</span></span><br></pre></td></tr></table></figure>

<p>如果在运行时检查变量的类型，则语言是动态类型的。动态类型语言的常见示例包括JavaScript，Objective-C，PHP，Python，Ruby，Lisp和Tcl。 在动态类型语言中，变量在运行时通过赋值语句绑定到对象，并且可以在程序执行期间将相同的变量绑定到不同类型的对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line"></span><br><span class="line">data = <span class="number">10</span>;</span><br><span class="line">data = <span class="string">&quot;Hello Game_404!&quot;</span>; // no error caused</span><br><span class="line">data = data + <span class="built_in">str</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>一般来说静态语言编译成字节码执行，动态语言使用解释器执行。编译型语言性能更高，但是较难移植到不同的CPU架构体系和操作系统。解释型语言易于移植，性能会比编译语言要差得多。这是频谱的两个极端。</p>
<h3 id="（二）强类型语言-vs-弱类型语言"><a href="#（二）强类型语言-vs-弱类型语言" class="headerlink" title="（二）强类型语言 vs 弱类型语言"></a>（二）强类型语言 vs 弱类型语言</h3><p>强类型语言是一种变量被绑定到特定数据类型的语言，如果类型与表达式中的预期不一致，将导致类型错误，比如下面这个:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line"></span><br><span class="line">temp = “Hello Game_404!”</span><br><span class="line">temp = temp + <span class="number">10</span>; <span class="comment"># program terminates with below stated error (TypeError: must be str, not int)</span></span><br></pre></td></tr></table></figure>

<p>python虽然是动态类型语言，但是却是一种强类型语言。</p>
<blockquote>
<p>python和我们感觉不一致，背叛了弱类型语言，不像世界上最好的语言 :( </p>
</blockquote>
<p>弱类型语言则没有这种绑定，当类型与表达式中的预期不一致时会忽略错误继续执行，甚至对变量类型进行自动转换，例如php语言：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$temp</span> = “Hello Game_404!”;</span><br><span class="line"><span class="variable">$temp</span> = <span class="variable">$temp</span> + <span class="number">10</span>; <span class="comment">// no error caused; PHP Warning:  A non-numeric value encountered in php shell code on line 1</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$temp</span>; <span class="comment">// output: 10</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>果然，只有php才是世界上最好的语言 :-D</p>
</blockquote>
<h2 id="三、rpython"><a href="#三、rpython" class="headerlink" title="三、rpython"></a>三、rpython</h2><p><a href="https://rpython.readthedocs.io/en/latest/">RPython</a>可以理解为一种Python编程语言规范的子集，同样也是一种python解释器的实现。也就是说RPython仍然遵循Python的语法规范，但限制了一些功能，如一些动态语言特性和一些类型接口，从而提高运行速度。<strong>简而言之,RPython就是强调类型安全,而去除动态语言特性的的Python实现</strong>。RPython存在的目的就是一个能够将Python语言编译成低级平台代码实现的编译工具。</p>
<h2 id="四、pypy"><a href="#四、pypy" class="headerlink" title="四、pypy"></a>四、pypy</h2><blockquote>
<p> pypy的官网为： <a href="https://www.pypy.org/">https://www.pypy.org/</a></p>
<p>另外参考：</p>
<ul>
<li> <a href="https://zhuanlan.zhihu.com/p/447307410">第23篇 深入理解RPython(入门篇) - 铁甲万能狗的文章 - 知乎 </a></li>
<li> <a href="https://blog.ideawand.com/2019/11/11/pypy-simple-introduction/">pypy简要介绍(附Python代码加速对比实验) </a></li>
<li><a href="https://www.zhihu.com/question/437425778/answer/1656458665">pypy是编译器还是解释器？ - 南风的回答 - 知乎 </a></li>
<li><a href="https://zhuanlan.zhihu.com/p/435652722">pypy真的能让python比c还快？ - 肖恩的文章 - 知乎</a></li>
</ul>
</blockquote>
<p>pypy使用python的子集rpython实现了解释器，有点像是一种自举。具体来说，pypy由两个部分组成：</p>
<ul>
<li>用RPython编写的<strong>Python解析器</strong>。事实上PyPy实现就是基于RPython代码编写的,并且其解释器的可执行版本是通过RPython内置编译组件(翻<strong>译工具链</strong>)编译成C程序。</li>
<li>一个翻<strong>译工具链(Translation Tool Chain)。</strong> 可以将RPython代码转换成C代码的编译工具集,当中包含组成PyPy解释器重要的JIT实现、垃圾回收实现的核心组件。</li>
</ul>
<p>反常识的是rpython的解释器会比c实现的Cpython解释器快？ 主要是因为pypy使用了JIT技术。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20240107113631.png" alt="image.png"></p>
<p>Just-In-Time (JIT) Compiler 试图通过对机器码进行一些实际的编译和一些解释来获得两全其美的方法。简而言之，以下是JIT编译为提高性能而采取的步骤：</p>
<ol>
<li>标识代码中最常用的组件，例如循环中的函数。</li>
<li>在运行时将这些零件转换为机器码。</li>
<li>优化生成的机器码。</li>
<li>用优化的机器码版本交换以前的实现。</li>
</ol>
<p>pypy除了速度快外，还有下面一些特点:</p>
<ul>
<li>内存使用情况比cpython少</li>
<li>垃圾回收策略更优化</li>
<li>Stackless 协程模式默认支持，支持高并发（但是新版本的python（≥3.4）也支持协程了！）</li>
<li>兼容性好，高度兼容cpython实现，<strong>基本</strong>可以无缝切换（pypy官方宣称如此）</li>
</ul>
<p>然而，目前看来，python的解释器依然以Cpython为主流。既然pypy如此优秀，大家为什么不去用呢？</p>
<p>答案是多方面的。</p>
<ul>
<li>首先，尽管pypy对python语言本身的支持很好，但对Cpython的一些C语言扩展支持就不太好了。现在的python语言的用户有一大部分是做数据分析和机器学习的，需要用到的各种python模块如numpy、scipy、pytorch等无一例外都用到了C语言实现各自的一些功能（这提升了代码运行速度），而pypy无法使用这些扩展。</li>
<li>其次，pypy本身的那些优点并没有足够优秀，尽管在许多任务上pypy做得比Cpython快，但这种快是建立在Cpython原本就很慢的基础上。当Cpython使用numpy等C语言扩展模块进行加速以后，pypy的优点就显得略微有点不足了。</li>
</ul>
<p>尽管如此，pypy是有其存在意义的。对于<strong>纯python实现</strong>的程序（不使用任何第三方模块），用pypy进行解释执行可能会换来运行速度上的提升；此外，pypy也代表着一种python语言自举的可能性。</p>
<h2 id="五、补充：RPython、CPython、Cython的关系"><a href="#五、补充：RPython、CPython、Cython的关系" class="headerlink" title="五、补充：RPython、CPython、Cython的关系"></a>五、补充：RPython、CPython、Cython的关系</h2><p>前面说过，pypy是通过Rpython实现的，由于Rpython对动态类型等特性进行了限制，使得python代码有机会进行编译执行。</p>
<p>而Cython是另一种比Cpython更宽松的实现，允许在python中使用一些C语言的特性。Cython所走的路线是兼容CPython的所有特性，尤其Cython要完全兼容CPython的CPext接口，Cython编译的C扩展因此包含Python/C接口的实现细节，由此调用时会带来一定的性能开销。而RPython编译后的C程序则不存在这些代码开销。换句话说，绝大部分情况下，RPython会比Cython性能要高出许多的根本原因。</p>
<p>因此，我们可以用集合对这几种python的实现进行一个关系的展示：</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20240107120222.png" alt="image.png"></p>
<p>除了这三种python解释器以外，还有其他几种python解释器，例如C#语言编写的IronPython和pythonnet、Java编写的Jython等，此处不再赘述。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>python</tag>
        <tag>pypy</tag>
        <tag>Cpython</tag>
        <tag>解释器</tag>
      </tags>
  </entry>
  <entry>
    <title>更新日志（2024-1-14）与一些碎碎念</title>
    <url>/2024/01/14/20240114_updatelog/</url>
    <content><![CDATA[<p>本周更新了一篇技术文章。此外，对网站进行了一些调整，新增了文章搜索的功能。</p>
<span id="more"></span>


<p>这一周，过得好漫长。概况起来就是，周一到周三白天干活晚上刷小说，周四得知组会改期的消息后白天干活晚上赶PPT，终于在周六下午完成了年前的最后一次组会汇报。这一周锻炼也有所松懈，一直到昨天才完成这周的第一个三公里。</p>
<p>最近天气有所回升，阳光透过树叶和窗棂撒在走廊上，很温暖，很明亮，像极了早春三月。有时候（现在已经是“几乎每天了”），甚至还有几只松鼠窜到实验室外的窗台，一边吃着瓜子花生一边好奇的打量着大家。哦对，我们已经连着几个月在窗台上放花生喂小松鼠了，它们也从一开始的胆小怕人渐渐变得大胆起来，也和我们成功建立起信任和默契。320大院真是个奇妙的地方。</p>
<p>（松鼠吃花生1，这只好像是师姐口中最胖最能吃的那只hhh）</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/squirrel_01_FormatFactoryPart3.gif" alt="松鼠1"></p>
<p>（松鼠吃花生2，和上面是同一只）</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/FormatFactoryPart3.gif" alt="松鼠2"></p>
<p>最近莫名其妙的，突然有一种韶华易逝、时光荏苒的叹惋（甚至有时候会感觉到恐惧）。IBP的生活已经是三年前的事情了，大一大二的生活也已经过去了五六年，甚至高中生活已经是八九年前的事情。往事历历在目，甚至和高中好友一起学习一起玩耍一起上学放学的生活似乎还在昨天。可是转眼间研究生的生活已经过去快两年了，时间快得难以想象。我该如何做好自己？又该如何做好自己的科研和事业？</p>
<p>无解。</p>
<p>感觉自己荒废了不少时光。然而荒废的时光好像也没有干什么正经事，科研进展一直很慢，书也没看多少，社交网络更是和以前一样依然一团糟。之前不觉得什么，但元旦过后这种感觉特别明显。看来自己还是太嫩太不成熟了点啊。</p>
<p>咳咳，好像有点偏题了。不管怎么样，生活还是要继续的，就像窗外的小松鼠不论晴雨都会来吃花生，就像冬去春来植物还是要长出叶子开出花（这是什么奇怪的比喻？）……当然，该休息的时候还是要休息，休息好了再出发。</p>
<p>最重要的，可能还是永远保持信心和希望。</p>
<p>以上。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
        <tag>更新日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim代码编辑器的宏录制功能</title>
    <url>/2024/01/14/vim-marcos/</url>
    <content><![CDATA[<blockquote>
<p>“简单来说，normal模式中按下字母<code>q</code>进入录制模式，此时的操作会被记录。再次按下<code>q</code>录制完成。要执行已录制好的宏，只需要键入<code>n@a</code>即可，其中<code>n</code>是执行次数，<code>a</code>是宏名称”</p>
</blockquote>
<span id="more"></span>


<h2 id="Vim录制和回放宏"><a href="#Vim录制和回放宏" class="headerlink" title="Vim录制和回放宏"></a>Vim录制和回放宏</h2><p>宏（macros）可以理解为一段自动化的操作流程，或者批处理操作。绝大多数情况下，“宏”这个词的使用暗示着将小命令或动作转化为一系列指令。</p>
<p>许多软件都支持录制宏操作（把一些操作步骤录制下来当作一段批处理程序来使用），例如office三件套、adobe全家桶等。这种自动化操作介于纯手工干活和使用编程语言操作文件之间，既可以实现办公自动化，又不用编写很多代码，因此可以大大提高生产力。</p>
<p>vim作为一个强大的代码编辑器，当然也是支持宏录制和宏回放的。本文将简要介绍vim录制和使用宏的方法。</p>
<p>在vim的帮助系统中，宏操作位于“complex-repeat”帮助文件中，可以在vim程序的normal模式下输入<code>:help complex-repeat</code> 或<code>:help q</code>指令来阅读。</p>
<h3 id="（一）录制宏"><a href="#（一）录制宏" class="headerlink" title="（一）录制宏"></a>（一）录制宏</h3><p>要录制一段宏，可以在vim的normal模式下使用<code>q&#123;0-9a-zA-Z&#125;</code>指令，也就是先按下字母<code>q</code>然后按下任意字母或数字键，这样就会开始宏录制，其中后者会关联到一个与按下的键相同名称的“寄存器”（register），宏会存储在这个寄存器中。</p>
<p>例如，<code>qa</code>就是将宏录制到寄存器<code>a</code>里（这个指令很容易和<code>:qa</code>弄混，后者是退出vim编辑器的指令）。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20240114195345.png" alt="image.png"></p>
<p>如上图，按下<code>qa</code>后进入宏录制模式，此时编辑器的左下角会出现<code>记录中 @a</code>（或 <code>recording @a</code> ）的提示符，<code>@</code>字母后面跟着的就是存储宏的寄存器名称。</p>
<p>接下来的一切操作，都会作为宏的一部分被记录下来。要停止宏录制，需要再按一次<code>q</code>键，此时左下角的 <code>recording @a</code>提示符会消失。</p>
<h3 id="（二）回放宏"><a href="#（二）回放宏" class="headerlink" title="（二）回放宏"></a>（二）回放宏</h3><p>对宏的回放等同于让vim编辑器把宏里面记录的操作再进行一次。</p>
<p>要回放宏，也很简单，只需要在normal模式下按下<code>@</code>键，再接上宏寄存器的名称即可。</p>
<p>仍然以上面截图中的文件为例。现在我录制了一段宏操作，内容是进入插入模式（<code>i</code>），将光标移动到行尾（<code>&lt;END&gt;</code>），键入字符“<code>.</code>”，以及退出插入模式（<code>&lt;ESC&gt;</code>）。接下来，将光标移动到剩下的每一行，然后键入<code>@a</code>，vim就会自动完成这一套操作，为每一行文字加上句号（如下图）。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20240114201249.png" alt="image.png"></p>
<p>另一个指令<code>n@a</code>则可以指定宏的回放次数，其中<code>n</code>为具体数字。仍然以上面那个<code>hello.txt</code>为例，在normal模式下输入<code>10@a</code>可以将宏播放10次，最终的效果就是在行尾再添加十个句号（如下图）</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20240114201636.png" alt="image.png"></p>
<p>值得注意的是，vim会对回放宏视作一个单步的操作（不论回放的次数设置的是多少），因此在回放宏以后按下<code>u</code>撤销操作，会直接回到回放之前的状态。</p>
<p>此外，还有快捷指令<code>@@</code>可以一键执行最近一次回放的宏操作，而不需要给出具体的寄存器名称。</p>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><blockquote>
<ul>
<li><a href="https://leanpub.com/VimLikeAPro">“Use Vim Like A Pro”, an e-book written by Tim Ottinger</a></li>
<li><a href="https://vimhelp.org/">Vim online help file</a></li>
<li><a href="https://www.cnblogs.com/JoiT/p/recording_vim.html">vim 录制宏，自动循环执行组合操作</a></li>
<li><a href="https://blog.csdn.net/yueguangmuyu/article/details/113803959">vim的recording模式</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>vim</tag>
        <tag>宏录制</tag>
        <tag>macros</tag>
      </tags>
  </entry>
  <entry>
    <title>轻量级LaTeX环境安装与jupyter导出PDF的一些探索</title>
    <url>/2024/01/21/install-and-use-of-tinytex-and-xelatex/</url>
    <content><![CDATA[<p>通过R安装了TinyTeX这一LaTeX发行版，并探索了用其编译jupyter notebook的方法。</p>
<span id="more"></span>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p>参考：</p>
<p><a href="https://blog.csdn.net/Cai_deLong/article/details/113970205">【LaTex使用总结】LaTex，pdflatex，xelatex，xetex等的区别和关系</a></p>
<p><a href="https://www.overleaf.com/learn/latex/Articles/The_TeX_family_tree%3A_LaTeX%2C_pdfTeX%2C_XeTeX%2C_LuaTeX_and_ConTeXt">Tex家族树</a></p>
</blockquote>
<p>TeX是一种基于宏的排版语言，早在上个世纪70年代就被发明了出来。原版的TeX语法晦涩难懂，于是有了LaTeX （或写作 $L^AT_EX$ ），后者是建立在TeX 基础上的宏语言，依然使用TeX的排版引擎但语法更加简单。</p>
<p>随着排版语言的进一步发展，LaTeX 又出现了许多变种，如pdfLaTeX 能够将TeX代码编写的文档直接编译到PDF格式（在pdfLaTeX 诞生的年代，LaTeX只能做到将文档编译到PostScript打印机排版格式），再之后出现了XeTeX（XeLaTeX是其别名），可以原生处理utf-8编码的各种文字（例如中文），因此对于非英文编写的文档也可也正确编译。</p>
<p>上面提到的这些都属于排版引擎，而更多情况下我们接触到的是 <code>排版引擎+宏包+格式+驱动+编辑器+...</code> 形成的一个整体，即所谓“发行版”。常见的LaTeX发行版包括MikTex、CTeX、MacTex、TeX Live等。</p>
<blockquote>
<p>要想深入区分排版引擎和发行版的区别，可以阅读文章 <a href="https://zhuanlan.zhihu.com/p/181557253">《LaTeX引擎、格式、宏包、发行版大梳理》 - Rabbyt的文章 - 知乎</a></p>
</blockquote>
<h2 id="TinyTeX"><a href="#TinyTeX" class="headerlink" title="TinyTeX"></a>TinyTeX</h2><blockquote>
<p>参考： <a href="https://yihui.org/tinytex/">TinyTeX英文版介绍</a> 与 <a href="https://yihui.org/tinytex/cn/">中文版介绍</a></p>
</blockquote>
<p>TinyTeX是一个TeX Live的修改版，由R语言大佬、Rmarkdown核心开发人员谢益辉开发，主要用于R markdown文档向PDF的编译。其编译引擎是XeLaTeX。</p>
<p>熟悉Rstudio的同学应该对Rstudio的knitr一键编译功能印象深刻，这一功能可以实现从R markdown笔记源代码编译到好看的html网页。然而knitr是可以进行设置的，通过一些高级设置，可以让R markdown笔记直接编译到PDF格式，这一功能就是通过TinyTeX实现的。不过今天我们要讲的并非TinyTeX在Rstudio里的应用，而是在系统的命令行中调用这一工具，以及借助TinyTeX将jupyter notebook转换为PDF格式的文档。</p>
<p>TinyTex的安装方法如下（需要在R语言解释器中执行下面的代码）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">install.packages(&#x27;tinytex&#x27;) # 安装`tinytex`R包，这个包并非TinyTeX本身，而是后者的安装程序</span><br><span class="line">tinytex::install_tinytex()  # 使用`tinytex`R包安装TinyTeX发行版</span><br><span class="line"># 要卸载TinyTeX，请直接在此执行代码 `tinytex::uninstall_tinytex()`</span><br></pre></td></tr></table></figure>

<p>安装完成以后，可以直接在R语言中调用tinytex进行文档渲染。</p>
<p>当然，tinytex也提供了命令行调用的方式，即 <code>xelatex &lt;arguments&gt;</code> 。可以在命令行中使用<code>xelatex --version</code>查看版本信息（如下代码块所示）</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">~$ xelatex --version</span><br><span class="line">XeTeX 3.141592653-2.6-0.999995 (TeX Live 2023)</span><br><span class="line">kpathsea version 6.3.5</span><br><span class="line">Copyright 2023 SIL International, Jonathan Kew and Khaled Hosny.</span><br><span class="line">There is NO warranty.  Redistribution of this software is</span><br><span class="line">covered by the terms of both the XeTeX copyright and</span><br><span class="line">the Lesser GNU General Public License.</span><br><span class="line">For more information about these matters, see the file</span><br><span class="line">named COPYING and the XeTeX source.</span><br><span class="line">Primary author of XeTeX: Jonathan Kew.</span><br><span class="line">Compiled with ICU version 72.1; using 72.1</span><br><span class="line">Compiled with zlib version 1.2.13; using 1.2.13</span><br><span class="line">Compiled with FreeType2 version 2.13.0; using 2.13.0</span><br><span class="line">Compiled with Graphite2 version 1.3.14; using 1.3.14</span><br><span class="line">Compiled with HarfBuzz version 7.0.1; using 7.0.1</span><br><span class="line">Compiled with libpng version 1.6.39; using 1.6.39</span><br><span class="line">Compiled with pplib version v2.05 less toxic i hope</span><br><span class="line">Compiled with fontconfig version 2.14.2; using 2.14.2</span><br></pre></td></tr></table></figure>


<h2 id="Pandoc"><a href="#Pandoc" class="headerlink" title="Pandoc"></a>Pandoc</h2><p>jupyter notebook可以将<code>.ipynb</code>格式的笔记本导出为各种格式，包括<code>.html</code>格式，Latex源代码格式（<code>.zip</code>），PDF格式等。其中，jupyter对<code>.html</code>格式拥有原生的支持，而其他格式则需要一些额外的工具（换句话说，pandoc）。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20240121174349.png" alt="image.png"></p>
<p>当我们想将<code>.ipynb</code>格式的笔记本导出为其他各种文件格式时，jupyter会调用<a href="https://pandoc.org/index.html">pandoc</a>这一工具。当系统里面没有安装pandoc时，会出现如下的报错：</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20240121180822.png" alt="image.png"></p>
<p>至于pandoc，官网对其的介绍如下：</p>
<blockquote>
<p>If you need to convert files from one markup format into another, pandoc is your swiss-army knife. </p>
<p>（如果你需要将文件从一种标记语言格式转换为另一种格式，pandoc就是你的瑞士军刀）</p>
</blockquote>
<p>pandoc支持几十种格式之间的互转，具体支持的格式和使用方法请参考<a href="https://pandoc.org/MANUAL.html">官方文档</a>。安装方法见<a href="https://pandoc.org/installing.html">这个页面上的介绍</a> 。简单来说，在不同的系统上，可以分别使用下面的指令进行安装：</p>
<table>
<thead>
<tr>
<th>系统</th>
<th>指令</th>
</tr>
</thead>
<tbody><tr>
<td>Windows</td>
<td><code>choco install pandoc</code></td>
</tr>
<tr>
<td>macOS</td>
<td><code>brew install pandoc</code></td>
</tr>
<tr>
<td>Linux(Debian,Ubuntu,etc.)</td>
<td><code>sudo apt-get install pandoc</code></td>
</tr>
<tr>
<td>Chrome OS</td>
<td><code>crew install pandoc</code></td>
</tr>
</tbody></table>
<p>除了使用指令安装以外，还可以从其GitHub仓库的<a href="https://github.com/jgm/pandoc/releases">release页面</a>上直接下载编译好的二进制版本pandoc程序或安装包。</p>
<p>安装完成后，可以使用<code>which pandoc</code>指令检查pandoc的安装路径是否加入了系统的环境变量当中（除了Windows系统——Windows上没有which这个指令）。当然，也可也在命令行中输入<code>pandoc --version</code>查看pandoc是否安装成功。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">~$ which pandoc</span><br><span class="line">/usr/bin/pandoc</span><br><span class="line">~$ pandoc --version</span><br><span class="line">pandoc 2.9.2.1</span><br><span class="line">Compiled with pandoc-types 1.20, texmath 0.12.0.2, skylighting 0.8.5</span><br><span class="line">Default user data directory: /home/cyclin/.local/share/pandoc or /home/cyclin/.pandoc</span><br><span class="line">Copyright (C) 2006-2020 John MacFarlane</span><br><span class="line">Web:  https://pandoc.org</span><br><span class="line">This is free software; see the source for copying conditions.</span><br><span class="line">There is no warranty, not even for merchantability or fitness</span><br><span class="line">for a particular purpose.</span><br></pre></td></tr></table></figure>


<p>借助pandoc这一外部工具，就可以实现ipython notebook导出到各种文件格式的功能，其中导出到Latex源码格式只需要pandoc支持，而导出到PDF同时需要pandoc和latex引擎。</p>
<h2 id="从-ipynb到PDF"><a href="#从-ipynb到PDF" class="headerlink" title="从.ipynb到PDF"></a>从<code>.ipynb</code>到PDF</h2><p>大体上讲，有两种方法可以将jupyter notebook的文档导出为PDF：</p>
<ul>
<li>先导出为HTML，然后在浏览器中使用“打印当前网页为PDF”的功能获得PDF</li>
<li>通过LaTeX直接编译为PDF</li>
</ul>
<p>两种方法各有优劣。前一种方法兼容性最强，除了浏览器外基本不需要额外的软件；后一种可以生成媲美出版物的高质量PDF。</p>
<p>鉴于前一种方法非常简单无需多言，下面我们重点讲后一种方法的实现。</p>
<p>当然，前排提醒，经过笔者测试，后一种方法依然存在一点小问题，不过不影响使用。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20240121181423.png" alt="image.png"></p>
<p>（上图：目前存在的一些“小问题”。貌似jupyter生成的LaTeX源代码中存在一些XeLaTeX无法识别的控制语句。）</p>
<p>鉴于直接在jupyter里面导出到PDF可能会出错，我们可以先导出文档到latex源代码格式（File→Export and Save Notebook as→LaTeX），然后再渲染。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20240121181603.png" alt="image.png"></p>
<p>如上图，点击这个按钮后，会有一份<code>.zip</code>格式的源代码包被导出。我们首先要做的是解压这个源代码包。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">C:\Users\ab124\Downloads&gt;unzip model-test-2024-1-15.zip -d model-test-2024-1-15</span><br><span class="line">Archive:  model-test-2024-1-15.zip</span><br><span class="line">  inflating: model-test-2024-1-15.tex</span><br><span class="line">  inflating: output_18_0.png</span><br></pre></td></tr></table></figure>

<p>压缩包里面的东西很少，只有一个<code>.tex</code>格式的源码文件和一些图片资源文件。</p>
<p>接下来，只需要运行下面的指令即可进行PDF编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xelatex model-test-2024-1-15.tex</span><br></pre></td></tr></table></figure>

<p>输出大致如下图所示：</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20240121182027.png" alt="image.png"></p>
<p>注意到，在前面jupyter提到的一些报错信息，这里我们也遇到了。</p>
<p>但是，但是，但是！</p>
<p>这些报错其实是无关紧要的！（至少目前是这样，感觉是jupyter的锅。可以无视它们直接按回车键。最终会得到一份PDF文件）</p>
<p>所以我们一路摁回车，忽略这些报错信息。最终的输出如下图，其中列出了一些信息，包括日志文件路径和最终编译生成的PDF文件名称。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20240121182323.png" alt="image.png"></p>
<p>输出的PDF最终效果展示：</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20240121182726.png" alt="image.png"></p>
<p>当然，这个时候juyter notebook依然无法编译PDF，因为jupyter notebook无法自动忽略上面的那些报错。目前这个问题无解。</p>
<h2 id="一些问题的解决方法"><a href="#一些问题的解决方法" class="headerlink" title="一些问题的解决方法"></a>一些问题的解决方法</h2><h3 id="1-LaTeX缺少宏包的问题处理"><a href="#1-LaTeX缺少宏包的问题处理" class="headerlink" title="1. LaTeX缺少宏包的问题处理"></a>1. LaTeX缺少宏包的问题处理</h3><p>第一次编译latex可能会报错，这个时候可以看报错内容。有时候报错内容如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">! LaTeX Error: File `times.sty&#x27; not found.</span><br><span class="line"></span><br><span class="line">Type X to quit or &lt;RETURN&gt; to proceed,</span><br><span class="line">     or enter new name. (Default extension: sty)</span><br></pre></td></tr></table></figure>

<p>这种类型的报错意味着宏包没有安装完整，例如上面这段报错表明<code>times.sty</code>没有安装。这个时候我们可以搜索一下缺失的<code>sty</code>文件属于哪个包。可以使用<code>tlmgr</code>指令进行查找，后者是TeX Live自带的包管理器指令。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ tlmgr search --global --file &quot;/times.sty&quot;</span><br><span class="line">psnfss:</span><br><span class="line">        texmf-dist/tex/latex/psnfss/times.sty</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>如上的结果表明，<code>sty</code>文件属于<code>psnfss</code>包。于是我们可以使用下面的指令进行安装：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">tlmgr install psnfss</span><br><span class="line"># if the package contains executables (e.g., dvisvgm), run</span><br><span class="line">tlmgr path add </span><br></pre></td></tr></table></figure>

<p>其他宏包的缺失问题使用同样的方法解决。</p>
<h3 id="2-含有中文字符的LaTeX文档编译"><a href="#2-含有中文字符的LaTeX文档编译" class="headerlink" title="2. 含有中文字符的LaTeX文档编译"></a>2. 含有中文字符的LaTeX文档编译</h3><p>LaTeX原生只支持英文字符，如果文档含中文，编译出的PDF会在原本该出现中文的地方产生大片的空白。</p>
<p>要实现latex对中文的支持，需要在latex源代码文档首部添加如下的两行代码：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%-- coding: UTF-8 --</span></span><br><span class="line"><span class="keyword">\usepackage</span>[UTF8]&#123;ctex&#125;</span><br></pre></td></tr></table></figure>

<p>同时安装Ctex包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tlmgr install ctex</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">D:\R\TinyTex&gt;tlmgr install ctex</span><br><span class="line">tlmgr.pl: package repository https://mirrors.jlu.edu.cn/CTAN/systems/texlive/tlnet (not verified: gpg unavailable)</span><br><span class="line">[1/43, ??:??/??:??] install: adobemapping [2128k]</span><br><span class="line">... ...</span><br><span class="line">[43/43, 01:03/01:03] install: zhnumber [9k]</span><br><span class="line">running mktexlsr ...</span><br><span class="line">done running mktexlsr.</span><br><span class="line">running updmap-sys ...</span><br><span class="line">done running updmap-sys.</span><br><span class="line">regenerating fmtutil.cnf in D:/R/TinyTex/texmf-dist</span><br><span class="line">running fmtutil-sys --byengine eptex --no-error-if-no-format --no-error-if-no-engine=luametatex,luajithbtex,luajittex,mfluajit --status-file=C:\Users\ab124\AppData\Local\Temp\x7NIOgtsGR\O4ZA3wrLcd ...</span><br><span class="line">  OK: eptex.fmt/eptex ptex.fmt/eptex</span><br><span class="line">running fmtutil-sys --byengine euptex --no-error-if-no-format --no-error-if-no-engine=luametatex,luajithbtex,luajittex,mfluajit --status-file=C:\Users\ab124\AppData\Local\Temp\x7NIOgtsGR\O4ZA3wrLcd ...</span><br><span class="line">  OK: eptex.fmt/eptex ptex.fmt/eptex euptex.fmt/euptex uptex.fmt/euptex platex.fmt/euptex uplatex-dev.fmt/euptex platex-dev.fmt/euptex uplatex.fmt/euptex</span><br><span class="line">running fmtutil-sys --byfmt mptopdf --no-error-if-no-engine=luametatex,luajithbtex,luajittex,mfluajit --status-file=C:\Users\ab124\AppData\Local\Temp\x7NIOgtsGR\O4ZA3wrLcd ...</span><br><span class="line">  OK: eptex.fmt/eptex ptex.fmt/eptex euptex.fmt/euptex uptex.fmt/euptex platex.fmt/euptex uplatex-dev.fmt/euptex platex-dev.fmt/euptex uplatex.fmt/euptex mptopdf.fmt/pdftex</span><br><span class="line">tlmgr.pl: package log updated: D:/R/TinyTex/texmf-var/web2c/tlmgr.log</span><br><span class="line">tlmgr.pl: command log updated: D:/R/TinyTex/texmf-var/web2c/tlmgr-commands.log</span><br></pre></td></tr></table></figure>

<p>之后，就可以编译含中文字符的文档了。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>latex</tag>
        <tag>jupyter</tag>
        <tag>PDF</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Pickle库的Python对象序列化探索</title>
    <url>/2024/01/27/python-pickle-usage-demo/</url>
    <content><![CDATA[<p>R语言有<code>save()</code>和<code>save.image()</code>方法，可以保存整个工作区的镜像，用于下一次的使用。这个功能非常方便，可以节省调试过程中生成中间变量的时间。</p>
<p>那么python可以吗？</p>
<span id="more"></span>

<p>好像是可以的，<code>pickle</code>库是python的对象序列化模块。虽然它原则上只能序列化单个对象，但我们可以探索一下如何将全局变量进行序列化处理。</p>
<p>这里面需要用到的知识： <code>dir()</code>可以查看所有全局变量的名称。<code>globals()</code>可以以字典的方式访问所有全局变量。</p>
<p>探索结果如下：</p>
<h2 id="1-dir-和globals-可以查看python的所有全局变量"><a href="#1-dir-和globals-可以查看python的所有全局变量" class="headerlink" title="1. dir()和globals()可以查看python的所有全局变量"></a>1. <code>dir()</code>和<code>globals()</code>可以查看python的所有全局变量</h2><p><code>dir()</code>和<code>globals()</code>都属于python的内置函数，任何时候都能使用。其中，<code>dir()</code>用于返回当前本地作用域中的名称列表（即所有变量的名称）。而<code>globals()</code> 用于返回实现当前模块命名空间的字典，即变量的名称+变量的内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> struct,os,sys</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="built_in">dir</span>()   <span class="comment"># show the names in the module namespace  </span></span><br><span class="line"><span class="comment"># output: [&#x27;__annotations__&#x27;, &#x27;__builtins__&#x27;, &#x27;__doc__&#x27;, &#x27;__loader__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;__spec__&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;os&#x27;, &#x27;struct&#x27;, &#x27;sys&#x27;]</span></span><br><span class="line"><span class="built_in">globals</span>()</span><br><span class="line"><span class="comment"># output: &#123;&#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None, &#x27;__loader__&#x27;: &lt;class &#x27;_frozen_importlib.BuiltinImporter&#x27;&gt;, &#x27;__spec__&#x27;: None, &#x27;__annotations__&#x27;: &#123;&#125;, &#x27;__builtins__&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;, &#x27;struct&#x27;: &lt;module &#x27;struct&#x27; from &#x27;D:\\Anaconda3\\lib\\struct.py&#x27;&gt;, &#x27;os&#x27;: &lt;module &#x27;os&#x27; from &#x27;D:\\Anaconda3\\lib\\os.py&#x27;&gt;, &#x27;sys&#x27;: &lt;module &#x27;sys&#x27; (built-in)&gt;, &#x27;a&#x27;: 1, &#x27;b&#x27;: &#x27;Hello World&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，通过<code>dir()</code>函数可以查询到前面我们命名的变量<code>a</code>和<code>b</code>的名称，而通过<code>globals()</code>我们可以查询到变量<code>a</code>和<code>b</code>以及对应的内容。此外，还有一些名称中带有下划线的变量，如<code>__name__</code>等，这些属于python的内部变量。</p>
<h2 id="2-pickle模块导出python对象到文件"><a href="#2-pickle模块导出python对象到文件" class="headerlink" title="2. pickle模块导出python对象到文件"></a>2. <code>pickle</code>模块导出python对象到文件</h2><blockquote>
<p>模块 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> 实现了对一个 Python 对象结构的二进制序列化和反序列化。 <em>“pickling”</em> 是将 Python 对象及其所拥有的层次结构转化为一个字节流的过程，而 <em>“unpickling”</em> 是相反的操作，会将（来自一个 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-binary-file">binary file</a> 或者 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object">bytes-like object</a> 的）字节流转化回一个对象层次结构。</p>
<p>——python官方文档</p>
</blockquote>
<p>和R语言中的<code>load</code>和<code>save</code>函数一样，<code>pickle</code>也是为了对象结构的存储。<code>pickle</code>提供了 <code>pickle.dump</code>、<code>pickle.dumps</code>、<code>pickle.load</code>、<code>pickle.loads</code> 这四个函数用于对象结构的导入导出。其中：</p>
<ul>
<li><code>pickle.dump</code>将对象 <em>obj</em> 封存以后的对象写入已打开的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-file-object">file object</a> _file_。</li>
<li><code>pickle.dumps</code>将 <em>obj</em> 封存以后的对象作为 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 类型直接返回，而不是将其写入到文件。</li>
<li><code>pickle.load</code>从已打开的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-file-object">file object</a> <em>文件</em> 中读取封存后的对象，重建其中特定对象的层次结构并返回。</li>
<li><code>pickle.loads</code>重建并返回一个对象的封存表示形式 <em>data</em> 的对象层级结构。 <em>data</em> 必须为 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object">bytes-like object</a>。</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>导入导出</th>
<th>文件或对象</th>
</tr>
</thead>
<tbody><tr>
<td><code>pickle.dump</code></td>
<td>导出python对象</td>
<td>到文件</td>
</tr>
<tr>
<td><code>pickle.dumps</code></td>
<td>导出python对象</td>
<td>到一个二进制对象</td>
</tr>
<tr>
<td><code>pickle.load</code></td>
<td>导入python对象</td>
<td>到文件</td>
</tr>
<tr>
<td><code>pickle.loads</code></td>
<td>导入python对象</td>
<td>到一个二进制对象</td>
</tr>
</tbody></table>
<p>值得注意的是，python的<code>pickle</code>模块并没有R的<code>load()</code>和<code>save()</code>那样智能，一些对象、模块或函数无法被序列化，因此需要一些额外的处理逻辑才能实现“保存整个工作区的镜像”的效果。</p>
<h2 id="3-python保存整个工作区的镜像"><a href="#3-python保存整个工作区的镜像" class="headerlink" title="3. python保存整个工作区的镜像"></a>3. python保存整个工作区的镜像</h2><p>如题。前几天的时候我在用jupyer lab做实验，由于想要保存一些中间结果方便未来的调试，于是探索了使用pickle导出工作区镜像的方法。</p>
<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20240128194015.png" alt="image.png"></p>
<p>jupyter lab的环境中内置变量则更多（如上图），有一些类型的变量无法使用pickle进行导出。具体来说，一些module无法导出；对于一个同名的function，如果前后两次运行中修改了函数定义，这个函数也无法导出；此外，同一个类的对象，如果在实例化之后对类定义的代码也进行了修改，那么之前实例化的那些对象也无法导出。</p>
<p>如果强制导出这些变量，会出现类似下面这样的报错：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------------------------------</span><br><span class="line">PicklingError                             Traceback (most recent call last)</span><br><span class="line">Input In [662], in &lt;cell line: 4&gt;()</span><br><span class="line">      3 # 导出整个工作区镜像</span><br><span class="line">      4 with open(&#x27;temp-2024-01-17-ensemble_model.image.pickle&#x27;, &#x27;wb&#x27;) as f:</span><br><span class="line">----&gt; 5     pickle.dump(pipe2,f)</span><br><span class="line"></span><br><span class="line">PicklingError: Can&#x27;t pickle &lt;class &#x27;__main__.ensemblePipe&#x27;&gt;: it&#x27;s not the same object as __main__.ensemblePipe</span><br></pre></td></tr></table></figure>

<p>因此，我们定义<code>global_img</code>字典用于保存可导出的变量，预先剔除这些不可导出的变量。随后使用预导出的<code>global_img</code>代替<code>globals()</code>进行文件导出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 下面这段代码可以导出所有变量到`global_img`变量</span></span><br><span class="line">global_img = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">dir</span>():</span><br><span class="line">    obj = <span class="built_in">globals</span>()[i]</span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">type</span>(obj).__name__ <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&#x27;module&#x27;</span>,<span class="string">&#x27;function&#x27;</span>,<span class="string">&#x27;dict_keys&#x27;</span>]) <span class="keyword">and</span> \</span><br><span class="line">       (i <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&#x27;In&#x27;</span>,<span class="string">&#x27;Out&#x27;</span>,<span class="string">&#x27;base&#x27;</span>,<span class="string">&#x27;exit&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;get_ipython&#x27;</span>,<span class="string">&#x27;ensemblePipe&#x27;</span>,<span class="string">&#x27;utils&#x27;</span>,<span class="string">&#x27;pipe2&#x27;</span>,<span class="string">&#x27;pipe_5&#x27;</span>,<span class="string">&#x27;quit&#x27;</span>,<span class="string">&#x27;exit&#x27;</span>]) <span class="keyword">and</span> i[<span class="number">0</span>]!=<span class="string">&quot;_&quot;</span>):</span><br><span class="line">        global_img[i] = obj</span><br></pre></td></tr></table></figure>

<p>随后，使用下面的代码就可导出<code>global_img</code>到文件当中了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="comment"># 导出整个工作区镜像</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;temp-2024-01-17-ensemble_model.image.pickle&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    pickle.dump(global_img,f)</span><br></pre></td></tr></table></figure>

<p>要从pickle文件中恢复这些变量，使用下面的代码即可（变量暂时存储在<code>obj</code>里面，后续可以把它们进行其他操作）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="comment"># 将镜像文件导入到工作区</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;temp-2024-01-17-ensemble_model.image.pickle&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">	obj = pickle.load(f)</span><br></pre></td></tr></table></figure>

<p>除此之外，可以使用下面的代码段判断一个变量属于什么类型。这里使用了<code>type()</code>函数用来查看一个变量的类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> global_img.keys():</span><br><span class="line">    obj = <span class="built_in">globals</span>()[i]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span>:\t<span class="subst">&#123;<span class="built_in">type</span>(obj)&#125;</span>&quot;</span>)    </span><br></pre></td></tr></table></figure>

<p>以上。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>python</tag>
        <tag>pickle</tag>
        <tag>对象序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务器维护零碎知识点整理</title>
    <url>/2024/01/28/Linux-service-operation-notes-01/</url>
    <content><![CDATA[<p>如题。</p>
<p>原先的服务器快到期了，因此这周初新购进一台华为云的服务器。在配置服务器的时候，顺带温习了一下这些知识点。</p>
<span id="more"></span>


<h2 id="虚拟内存的分配与开启-关闭操作"><a href="#虚拟内存的分配与开启-关闭操作" class="headerlink" title="虚拟内存的分配与开启/关闭操作"></a>虚拟内存的分配与开启/关闭操作</h2><p>所谓虚拟内存，就是把硬盘上面的一部分空间当作内存来用，通过牺牲硬盘的一部分读写性能换取内存的提升。在Windows系统上，这样的技术被称为“分页文件”，而在Linux/Unix上，这样的技术被称为“交换文件”</p>
<h3 id="1-创建虚拟内存文件（交换文件）"><a href="#1-创建虚拟内存文件（交换文件）" class="headerlink" title="1. 创建虚拟内存文件（交换文件）"></a>1. 创建虚拟内存文件（交换文件）</h3><p>使用下面的指令，可以在当前目录下创建一个名为<code>swapfile</code>的交换文件。其中，<code>dd</code>指令用来将指令写入磁盘上的一片物理空间，<code>bs=1G count=6</code> 代表创建6个1GB大小的块，也就是这个交换文件大小为6GB（可以提供大约6GB的虚拟内存空间）。虚拟内存的大小设置为服务器物理内存大小的1-2倍比较合适，例如2GB的内存可以配4GB的虚拟内存，8GB的内存可以配8-16GB的虚拟内存。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=./swapfile bs=1G count=6</span><br></pre></td></tr></table></figure>

<p>上述指令的输出：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/$ sudo dd if=/dev/zero of=./swapfile bs=1G count=6</span><br><span class="line">6+0 records in</span><br><span class="line">6+0 records out</span><br><span class="line">6442450944 bytes (6.4 GB, 6.0 GiB) copied, 51.4058 s, 125 MB/s</span><br></pre></td></tr></table></figure>

<h3 id="2-将文件设置为交换文件"><a href="#2-将文件设置为交换文件" class="headerlink" title="2. 将文件设置为交换文件"></a>2. 将文件设置为交换文件</h3><p><code>mkswap</code> 指令可以将指定的文件设置为Linux交换文件。具体而言，指令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkswap swapfile</span><br></pre></td></tr></table></figure>

<p>上述指令的输出：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/$ sudo mkswap swapfile</span><br><span class="line">mkswap: swapfile: insecure permissions 0644, 0600 suggested.</span><br><span class="line">Setting up swapspace version 1, size = 6 GiB (6442446848 bytes)</span><br><span class="line">no label, UUID=13e8eb83-a3a7-4298-b5ef-9c6b3053a4ff</span><br></pre></td></tr></table></figure>

<p>请注意，将一个文件设置为交换文件不代表开启了服务器的交换文件功能，还需要进一步设置。</p>
<h3 id="3-启用交换文件（临时）"><a href="#3-启用交换文件（临时）" class="headerlink" title="3. 启用交换文件（临时）"></a>3. 启用交换文件（临时）</h3><p><code>swapon</code>和<code>swapoff</code>这两个指令用于开启和关闭服务器系统的交换文件功能。具体而言，指令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo swapon swapfile</span><br></pre></td></tr></table></figure>

<p>可以使用<code>free</code>指令查看开启这一功能前后的内存变化情况：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/$ free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:          3.6Gi       3.4Gi       129Mi       0.0Ki        89Mi        53Mi</span><br><span class="line">Swap:           0Gi         0Gi         0Gi</span><br><span class="line"></span><br><span class="line">/$ sudo swapon  swapfile # 开启交换文件</span><br><span class="line"></span><br><span class="line">/$ free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:          3.6Gi       3.4Gi       129Mi       0.0Ki        89Mi        53Mi</span><br><span class="line">Swap:         6.0Gi         0Gi       6.0Gi</span><br></pre></td></tr></table></figure>

<h3 id="4-启用交换文件（永久有效）"><a href="#4-启用交换文件（永久有效）" class="headerlink" title="4. 启用交换文件（永久有效）"></a>4. 启用交换文件（永久有效）</h3><p>在<code>/etc/fstab</code> 文件中添加下面这样一行内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/swapfile swap swap defaults 0 0</span><br></pre></td></tr></table></figure>

<p>其中，第一个参数代表交换文件的实际存储位置，此处的示例是<code>/swapfile</code>，在实际使用中请根据实际情况进行设置。另外5个参数的内容就按上述设置即可。</p>
<p>完成这一设置以后，重启系统，则交换文件即可生效。</p>
<h2 id="通过-htaccess-文件控制Apache-web-服务器文件的访问权限"><a href="#通过-htaccess-文件控制Apache-web-服务器文件的访问权限" class="headerlink" title="通过.htaccess 文件控制Apache web 服务器文件的访问权限"></a>通过<code>.htaccess</code> 文件控制Apache web 服务器文件的访问权限</h2><p><code>.htaccess</code> 文件是 Apache web 服务器中用于配置特定目录的文件。它允许开发者在目录级别上覆盖主配置文件中的一些配置，并可以用于设置权限、重定向、缓存控制等。</p>
<p>以下是一个简单的 <code>.htaccess</code> 文件的示例，以说明其中的一些基本概念：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;Files <span class="string">&quot;sensitive-file.txt&quot;</span>&gt;</span></span><br><span class="line">    <span class="attribute">Order</span> <span class="literal">allow</span>,<span class="literal">deny</span></span><br><span class="line">    <span class="attribute">Deny</span> from <span class="literal">all</span></span><br><span class="line"><span class="section">&lt;/Files&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">&lt;FilesMatch <span class="string">&quot;\.(xml|txt)$&quot;</span>&gt;</span></span><br><span class="line">    <span class="attribute">Order</span> <span class="literal">allow</span>,<span class="literal">deny</span></span><br><span class="line">    <span class="attribute">Allow</span> from <span class="literal">all</span></span><br><span class="line"><span class="section">&lt;/FilesMatch&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">&lt;IfModule mod_rewrite.c&gt;</span></span><br><span class="line">    <span class="attribute">RewriteEngine</span> <span class="literal">On</span></span><br><span class="line">    <span class="attribute">RewriteBase</span> /path/to/your/app</span><br><span class="line"></span><br><span class="line">    <span class="attribute">RewriteCond</span> <span class="variable">%&#123;REQUEST_FILENAME&#125;</span> !-f</span><br><span class="line">    <span class="attribute">RewriteCond</span> <span class="variable">%&#123;REQUEST_FILENAME&#125;</span> !-d</span><br><span class="line">    <span class="attribute">RewriteRule</span> ^(.*)$ index.php/$<span class="number">1</span><span class="meta"> [L]</span></span><br><span class="line"><span class="section">&lt;/IfModule&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">ErrorDocument</span> <span class="number">404</span> /errors/not-found.html</span><br></pre></td></tr></table></figure>

<p>上述示例包含了几个部分：</p>
<ol>
<li><p><code>&lt;Files&gt;</code> 部分：这部分指定了对 <code>sensitive-file.txt</code> 文件的访问控制。在这个例子中，对这个文件的访问被拒绝。</p>
</li>
<li><p><code>&lt;FilesMatch&gt;</code> 部分：这里使用正则表达式指定了对以 <code>.xml</code> 或 <code>.txt</code> 结尾的文件的访问控制。在这个例子中，对这些文件的访问是允许的。</p>
</li>
<li><p><code>&lt;IfModule&gt;</code> 部分：这是一个条件块，只有在 Apache 服务器加载了 <code>mod_rewrite</code> 模块时才会执行其中的指令。在这个例子中，启用了 URL 重写规则，将请求重定向到 <code>index.php</code>。</p>
</li>
<li><p><code>ErrorDocument</code> 指令：这部分定义了当发生404错误时，将用户重定向到 <code>/errors/not-found.html</code> 页面。</p>
</li>
</ol>
<p>这只是一个简单的示例，<code>.htaccess</code> 文件还可以包含其他指令，用于设置许多不同的配置选项。</p>
<p>必须要注意的是，仅仅对<code>.htaccess</code>文件进行设置并不能保证这些访问权限设置能够生效。还需要在web服务器程序的配置文件中启用对访问权限的覆盖功能，才可以生效。</p>
<p>web服务器程序的配置文件路径，根据服务器上具体使用的web服务程序的不同而有所不同，例如apache2的配置文件路径是<code>/etc/apache2/apache2.conf</code>，而httpd的配置文件路径是 <code>/etc/httpd/conf/httpd.conf</code> 。</p>
<p>以apache2为例。假设我们要使用<code>.htaccess</code>文件进行访问权限保护的网页存储在<code>/var/www/html</code>路径下面，那么在apache2配置文件里面，我们需要加上下面这几行内容：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;Directory /var/www/html&gt;</span><br><span class="line">        AllowOverride All</span><br><span class="line">        Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure>

<p>之后，我们需要重启一下web服务程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service apache2 restart</span><br></pre></td></tr></table></figure>

<p>这样，就可以通过<code>.htaccess</code>进行访问权限控制了。</p>
<h2 id="Linux的cron定时任务设置与踩坑"><a href="#Linux的cron定时任务设置与踩坑" class="headerlink" title="Linux的cron定时任务设置与踩坑"></a>Linux的cron定时任务设置与踩坑</h2><p><code>crond</code>是Linux上一个用于运行定时任务的守护进程。它的配置文件路径是<code>/etc/crontab</code>，里面的内容大概长这个样子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /etc/crontab: system-wide crontab</span></span><br><span class="line"><span class="comment"># Unlike any other crontab you don&#x27;t have to run the `crontab&#x27;</span></span><br><span class="line"><span class="comment"># command to install the new version when you edit this file</span></span><br><span class="line"><span class="comment"># and files in /etc/cron.d. These files also have username fields,</span></span><br><span class="line"><span class="comment"># that none of the other crontabs do.</span></span><br><span class="line"></span><br><span class="line">SHELL=/bin/sh</span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example of job definition:</span></span><br><span class="line"><span class="comment"># .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="comment"># |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="comment"># |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="comment"># |  |  |  |  |</span></span><br><span class="line"><span class="comment"># *  *  *  *  * user-name command to be executed</span></span><br><span class="line">17 *    * * *   root    <span class="built_in">cd</span> / &amp;&amp; run-parts --report /etc/cron.hourly</span><br><span class="line">25 6    * * *   root    <span class="built_in">test</span> -x /usr/sbin/anacron || ( <span class="built_in">cd</span> / &amp;&amp; run-parts --report /etc/cron.daily )</span><br><span class="line">47 6    * * 7   root    <span class="built_in">test</span> -x /usr/sbin/anacron || ( <span class="built_in">cd</span> / &amp;&amp; run-parts --report /etc/cron.weekly )</span><br><span class="line">52 6    1 * *   root    <span class="built_in">test</span> -x /usr/sbin/anacron || ( <span class="built_in">cd</span> / &amp;&amp; run-parts --report /etc/cron.monthly )</span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>


<p>每分钟，crond程序都会检查这个配置文件的更新，并在定时任务到时间时执行任务。上述配置文件中说明了添加定时任务的方法：在这个文件中新增一行内容，这一行内容需要包含任务的执行时间、以什么用户身份执行这个任务，以及要执行的任务脚本。</p>
<p>例如，假设我们在<code>/home/warrenz/</code>下有一个爬虫程序<code>spyder.py</code>，需要每天上午9点整准时以warrenz的用户身份执行，那么就需要向<code>crontab</code>中添加下面这样的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0 9 * * * warrenz /home/warrenz/spyder.py</span><br></pre></td></tr></table></figure>

<p>前五个数字分别代表定时任务的执行时间（分钟、小时、每个月的第几天、月份、每个星期的第几天），可以使用通配符<code>*</code>代表任何时间都执行。第六个参数是用户名，第七个参数是要执行的脚本内容或文件路径，必须使用完整路径。</p>
<p>另外，<code>crond</code>在执行任务时无法处理标准输入输出（也就是通常我们写程序时的<code>print()</code>那一堆操作）。因此，可以放在定时任务里执行的程序不应该有标准输入输出，即使有，也应该使用Linux输出重定向符号<code>&gt;</code>或<code>&gt;&gt;</code>写入到一个具体文件当中。</p>
<p><code>crond</code>执行任务没有输出，那么如何确定任务是否执行成功了呢？其中一种方法是查询<code>cron</code>服务的状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service cron status</span><br></pre></td></tr></table></figure>


<p><img src="https://wzblog-1311469384.cos.ap-shanghai.myqcloud.com/wzblog/20240128203011.png" alt="image.png"></p>
<p>如果这里出现了异常的报错或异常的会话关闭（”session closed“），则有可能是任务出错。（正常情况下执行完任务也会session closed，但这里是可以看crond的任务执行时间的，如果一个任务预估需要三五分钟跑完，结果crond只花了不到一秒就session closed了，那很有可能是程序报错了）</p>
<p>经过本人实践，造成crond定时任务出错的原因大概包括下面这样一些：</p>
<ul>
<li>python程序调用了未安装的模块（注意，如果使用root用户进行定时任务执行，则一些模块需要使用<code>sudo pip</code>或<code>sudo conda</code>进行全局安装）。</li>
<li>程序中有标准输入输出且未进行文件重定向。</li>
<li>使用非root用户身份执行定时任务时，没有给文件或目录相应的访问权限。</li>
<li>软件或程序本身的问题。</li>
</ul>
<p>按照上面的思路逐个情况排查，最终可以找到原因。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机技术杂谈</tag>
        <tag>Linux运维</tag>
        <tag>虚拟内存</tag>
        <tag>web服务</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
</search>
